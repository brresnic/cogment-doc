{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Note We recently introduced cogment v2 which a massive internal change to Cogment to learn more about the change and how to migrate please check the dedicated documentation . Cogment Framework Overview \u00b6 What is Cogment? \u00b6 Cogment is an innovative open source AI platform developed by AI Redefined , designed to leverage the advent of AI to benefit humankind through human-AI collaboration. Cogment enables AI researchers and engineers to build, train and operate AI agents in simulated or real environments shared with humans. When to use Cogment? \u00b6 Cogment is designed to allow the training of complex agent architectures in complex environments, with human users in the loop. It is especially well suited to address multi-agent contexts, regardless of their learning mechanisms (or, for that matter, whether they are of the learning kind or not). Cogment also allows for the Actor's abstraction, meaning that human users and learning or non-learning agents alike are treated in the same way from a high level point of view, rendering them interchangeable. As such, Cogment is suited for, among others, these contexts: Easily bootstrapping a given system by using human users, or heuristic agents, or both, then transitioning seamlessly to ML implementations Architecture multiple ML approaches to contribute to a single role, either by balancing them through specific rulesets, or specific performance metrics, or any other criteria Comparing different agent types/implementations without requiring any change in the implementation of the environment When not to use Cogment \u00b6 Cogment can be used in many other contexts it wasn't specifically designed for. However, for several types and scales of ML-powered projects, it may not be the most fitting approach: Simple projects focused around one learning agent Projects deployed only locally with no plans of larger scale distributed deployment Features \u00b6 Cogment main features are: Tech Stack Agnosticity. With the use of protobufs and gRPC, Cogment allows the development of tech-heterogeneous components working together regardless of the tech stacks used to develop them. It is fully compatible with current tools, langages and commonly used techniques. Multi-Method. Cogment doesn't enforce any particular approach to agents implementation. It doesn't favor learning over non-learning agents, nor does it learning techniques over others. Multi-Actor. Cogment was designed to allow multiple agents and multiple human users (all \"actors\") to exist, train, and work together within the same environment, interacting with one another and their environment. Multi-Reward Multiple Reinforcement Learning (RL) agents can use any number of reward sources in a Cogment project, whether they are from human users, an environment (real or simulated), or other agents. The same is true for the kind or mechanic of those rewards. Humans in the loop. Interaction with human users is a core feature of the Cogment framework, at any step of a project from the bootstrapping to the deployment and productionalization. There is no enforced limit to the complexity of said interaction. Multi-Experience learning. Several deployments (instances) of a Cogment project can contribute to the learning of their agents in a parallel way, i.e. each instance contributing to the learning of a single implementation of an agent. Actor hot-swap. Cogment allows for the swapping in and out of an actor from one implementation of an agent to another, or from a human user to another, or from a human user to a trained or untrained agent, and vice-versa. You can for example use simulated humans for a while before switching in real users, or switch from AI to human control. Custom agent architectures. Cogment allows the architecturing behind an agent's role to be as complex and specific as needed; hybridation between techniques, in particular, can be used to build individual capabilities and ultimately assemble them into one complex agent. Distributed computing & training. The physical location of any given component or part of a Cogment's project does not have to be the same, and neither do instances of a deployed Cogment project. Training and use can all happen in a distributed way, running one large algorithm or an array of decentralized agents. Live development. There is virtually no difference between dev and prod versions of a Cogment project; any Cogment project can be developed in an iterative way, with any part of it being live-developed so iteration cycles between simulated and real environment, for example, can happen as quickly as possible. Components \u00b6 The Cogment framework consists of multiple components: The Orchestrator , the heart of a Cogment app, is in charge of running the components. The SDKs are used to build your Cogment app services and clients. The SDKs are currently available in Python and Javascript only. A command like tool to facilitate the creation of Cogment apps. First steps \u00b6 The easiest way to get started is to use the cogment command line tool. Please see our installation instructions for details. Before diving right in, we recommend taking the time to read the Core concepts section, as well as our glossary , which details the terminology we use for several critical concepts of the Cogment Framework. You can then proceed to read on how to install the framework. Last but not least, a tutorial gives you a hands on introduction on using Cogment. Citations \u00b6 If you use Cogment in your research, please cite the white paper as follows: @misc{air2021cogment, title={Cogment: Open Source Framework For Distributed Multi-actor Training, Deployment & Operations}, author={AI Redefined and Sai Krishna Gottipati and Sagar Kurandwad and Clod\u00e9ric Mars and Gregory Szriftgiser and Fran\u00e7ois Chabot}, year={2021}, eprint={2106.11345}, archivePrefix={arXiv}, primaryClass={cs.AI} }","title":"Overview"},{"location":"#cogment-framework-overview","text":"","title":"Cogment Framework Overview"},{"location":"#what-is-cogment","text":"Cogment is an innovative open source AI platform developed by AI Redefined , designed to leverage the advent of AI to benefit humankind through human-AI collaboration. Cogment enables AI researchers and engineers to build, train and operate AI agents in simulated or real environments shared with humans.","title":"What is Cogment?"},{"location":"#when-to-use-cogment","text":"Cogment is designed to allow the training of complex agent architectures in complex environments, with human users in the loop. It is especially well suited to address multi-agent contexts, regardless of their learning mechanisms (or, for that matter, whether they are of the learning kind or not). Cogment also allows for the Actor's abstraction, meaning that human users and learning or non-learning agents alike are treated in the same way from a high level point of view, rendering them interchangeable. As such, Cogment is suited for, among others, these contexts: Easily bootstrapping a given system by using human users, or heuristic agents, or both, then transitioning seamlessly to ML implementations Architecture multiple ML approaches to contribute to a single role, either by balancing them through specific rulesets, or specific performance metrics, or any other criteria Comparing different agent types/implementations without requiring any change in the implementation of the environment","title":"When to use Cogment?"},{"location":"#when-not-to-use-cogment","text":"Cogment can be used in many other contexts it wasn't specifically designed for. However, for several types and scales of ML-powered projects, it may not be the most fitting approach: Simple projects focused around one learning agent Projects deployed only locally with no plans of larger scale distributed deployment","title":"When not to use Cogment"},{"location":"#features","text":"Cogment main features are: Tech Stack Agnosticity. With the use of protobufs and gRPC, Cogment allows the development of tech-heterogeneous components working together regardless of the tech stacks used to develop them. It is fully compatible with current tools, langages and commonly used techniques. Multi-Method. Cogment doesn't enforce any particular approach to agents implementation. It doesn't favor learning over non-learning agents, nor does it learning techniques over others. Multi-Actor. Cogment was designed to allow multiple agents and multiple human users (all \"actors\") to exist, train, and work together within the same environment, interacting with one another and their environment. Multi-Reward Multiple Reinforcement Learning (RL) agents can use any number of reward sources in a Cogment project, whether they are from human users, an environment (real or simulated), or other agents. The same is true for the kind or mechanic of those rewards. Humans in the loop. Interaction with human users is a core feature of the Cogment framework, at any step of a project from the bootstrapping to the deployment and productionalization. There is no enforced limit to the complexity of said interaction. Multi-Experience learning. Several deployments (instances) of a Cogment project can contribute to the learning of their agents in a parallel way, i.e. each instance contributing to the learning of a single implementation of an agent. Actor hot-swap. Cogment allows for the swapping in and out of an actor from one implementation of an agent to another, or from a human user to another, or from a human user to a trained or untrained agent, and vice-versa. You can for example use simulated humans for a while before switching in real users, or switch from AI to human control. Custom agent architectures. Cogment allows the architecturing behind an agent's role to be as complex and specific as needed; hybridation between techniques, in particular, can be used to build individual capabilities and ultimately assemble them into one complex agent. Distributed computing & training. The physical location of any given component or part of a Cogment's project does not have to be the same, and neither do instances of a deployed Cogment project. Training and use can all happen in a distributed way, running one large algorithm or an array of decentralized agents. Live development. There is virtually no difference between dev and prod versions of a Cogment project; any Cogment project can be developed in an iterative way, with any part of it being live-developed so iteration cycles between simulated and real environment, for example, can happen as quickly as possible.","title":"Features"},{"location":"#components","text":"The Cogment framework consists of multiple components: The Orchestrator , the heart of a Cogment app, is in charge of running the components. The SDKs are used to build your Cogment app services and clients. The SDKs are currently available in Python and Javascript only. A command like tool to facilitate the creation of Cogment apps.","title":"Components"},{"location":"#first-steps","text":"The easiest way to get started is to use the cogment command line tool. Please see our installation instructions for details. Before diving right in, we recommend taking the time to read the Core concepts section, as well as our glossary , which details the terminology we use for several critical concepts of the Cogment Framework. You can then proceed to read on how to install the framework. Last but not least, a tutorial gives you a hands on introduction on using Cogment.","title":"First steps"},{"location":"#citations","text":"If you use Cogment in your research, please cite the white paper as follows: @misc{air2021cogment, title={Cogment: Open Source Framework For Distributed Multi-actor Training, Deployment & Operations}, author={AI Redefined and Sai Krishna Gottipati and Sagar Kurandwad and Clod\u00e9ric Mars and Gregory Szriftgiser and Fran\u00e7ois Chabot}, year={2021}, eprint={2106.11345}, archivePrefix={arXiv}, primaryClass={cs.AI} }","title":"Citations"},{"location":"license/","text":"Apache License \u00b6 Version 2.0, January 2004 < http://www.apache.org/licenses/ > Terms and Conditions for use, reproduction, and distribution \u00b6 1. Definitions \u00b6 \u201cLicense\u201d shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document. \u201cLicensor\u201d shall mean the copyright owner or entity authorized by the copyright owner that is granting the License. \u201cLegal Entity\u201d shall mean the union of the acting entity and all other entities that control, are controlled by, or are under common control with that entity. For the purposes of this definition, \u201ccontrol\u201d means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity. \u201cYou\u201d (or \u201cYour\u201d) shall mean an individual or Legal Entity exercising permissions granted by this License. \u201cSource\u201d form shall mean the preferred form for making modifications, including but not limited to software source code, documentation source, and configuration files. \u201cObject\u201d form shall mean any form resulting from mechanical transformation or translation of a Source form, including but not limited to compiled object code, generated documentation, and conversions to other media types. \u201cWork\u201d shall mean the work of authorship, whether in Source or Object form, made available under the License, as indicated by a copyright notice that is included in or attached to the work (an example is provided in the Appendix below). \u201cDerivative Works\u201d shall mean any work, whether in Source or Object form, that is based on (or derived from) the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work and Derivative Works thereof. \u201cContribution\u201d shall mean any work of authorship, including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, \u201csubmitted\u201d means any form of electronic, verbal, or written communication sent to the Licensor or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as \u201cNot a Contribution.\u201d \u201cContributor\u201d shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been received by Licensor and subsequently incorporated within the Work. 2. Grant of Copyright License \u00b6 Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and such Derivative Works in Source or Object form. 3. Grant of Patent License \u00b6 Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by such Contributor that are necessarily infringed by their Contribution(s) alone or by combination of their Contribution(s) with the Work to which such Contribution(s) was submitted. If You institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the Work constitutes direct or contributory patent infringement, then any patent licenses granted to You under this License for that Work shall terminate as of the date such litigation is filed. 4. Redistribution \u00b6 You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with or without modifications, and in Source or Object form, provided that You meet the following conditions: (a) You must give any other recipients of the Work or Derivative Works a copy of this License; and (b) You must cause any modified files to carry prominent notices stating that You changed the files; and (c) You must retain, in the Source form of any Derivative Works that You distribute, all copyright, patent, trademark, and attribution notices from the Source form of the Work, excluding those notices that do not pertain to any part of the Derivative Works; and (d) If the Work includes a \u201cNOTICE\u201d text file as part of its distribution, then any Derivative Works that You distribute must include a readable copy of the attribution notices contained within such NOTICE file, excluding those notices that do not pertain to any part of the Derivative Works, in at least one of the following places: within a NOTICE text file distributed as part of the Derivative Works; within the Source form or documentation, if provided along with the Derivative Works; or, within a display generated by the Derivative Works, if and wherever such third-party notices normally appear. The contents of the NOTICE file are for informational purposes only and do not modify the License. You may add Your own attribution notices within Derivative Works that You distribute, alongside or as an addendum to the NOTICE text from the Work, provided that such additional attribution notices cannot be construed as modifying the License. You may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise complies with the conditions stated in this License. 5. Submission of Contributions \u00b6 Unless You explicitly state otherwise, any Contribution intentionally submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this License, without any additional terms or conditions. Notwithstanding the above, nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding such Contributions. 6. Trademarks \u00b6 This License does not grant permission to use the trade names, trademarks, service marks, or product names of the Licensor, except as required for reasonable and customary use in describing the origin of the Work and reproducing the content of the NOTICE file. 7. Disclaimer of Warranty \u00b6 Unless required by applicable law or agreed to in writing, Licensor provides the Work (and each Contributor provides its Contributions) on an \u201cAS IS\u201d BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining the appropriateness of using or redistributing the Work and assume any risks associated with Your exercise of permissions under this License. 8. Limitation of Liability \u00b6 In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall any Contributor be liable to You for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising as a result of this License or out of the use or inability to use the Work (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if such Contributor has been advised of the possibility of such damages. 9. Accepting Warranty or Additional Liability \u00b6 While redistributing the Work or Derivative Works thereof, You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this License. However, in accepting such obligations, You may act only on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, and only if You agree to indemnify, defend, and hold each Contributor harmless for any liability incurred by, or claims asserted against, such Contributor by reason of your accepting any such warranty or additional liability. Copyright 2019 Artificial Intelligence Redefined","title":"License"},{"location":"license/#apache-license","text":"Version 2.0, January 2004 < http://www.apache.org/licenses/ >","title":"Apache License"},{"location":"license/#terms-and-conditions-for-use-reproduction-and-distribution","text":"","title":"Terms and Conditions for use, reproduction, and distribution"},{"location":"license/#1-definitions","text":"\u201cLicense\u201d shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document. \u201cLicensor\u201d shall mean the copyright owner or entity authorized by the copyright owner that is granting the License. \u201cLegal Entity\u201d shall mean the union of the acting entity and all other entities that control, are controlled by, or are under common control with that entity. For the purposes of this definition, \u201ccontrol\u201d means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity. \u201cYou\u201d (or \u201cYour\u201d) shall mean an individual or Legal Entity exercising permissions granted by this License. \u201cSource\u201d form shall mean the preferred form for making modifications, including but not limited to software source code, documentation source, and configuration files. \u201cObject\u201d form shall mean any form resulting from mechanical transformation or translation of a Source form, including but not limited to compiled object code, generated documentation, and conversions to other media types. \u201cWork\u201d shall mean the work of authorship, whether in Source or Object form, made available under the License, as indicated by a copyright notice that is included in or attached to the work (an example is provided in the Appendix below). \u201cDerivative Works\u201d shall mean any work, whether in Source or Object form, that is based on (or derived from) the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work and Derivative Works thereof. \u201cContribution\u201d shall mean any work of authorship, including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, \u201csubmitted\u201d means any form of electronic, verbal, or written communication sent to the Licensor or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as \u201cNot a Contribution.\u201d \u201cContributor\u201d shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been received by Licensor and subsequently incorporated within the Work.","title":"1. Definitions"},{"location":"license/#2-grant-of-copyright-license","text":"Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and such Derivative Works in Source or Object form.","title":"2. Grant of Copyright License"},{"location":"license/#3-grant-of-patent-license","text":"Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by such Contributor that are necessarily infringed by their Contribution(s) alone or by combination of their Contribution(s) with the Work to which such Contribution(s) was submitted. If You institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the Work constitutes direct or contributory patent infringement, then any patent licenses granted to You under this License for that Work shall terminate as of the date such litigation is filed.","title":"3. Grant of Patent License"},{"location":"license/#4-redistribution","text":"You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with or without modifications, and in Source or Object form, provided that You meet the following conditions: (a) You must give any other recipients of the Work or Derivative Works a copy of this License; and (b) You must cause any modified files to carry prominent notices stating that You changed the files; and (c) You must retain, in the Source form of any Derivative Works that You distribute, all copyright, patent, trademark, and attribution notices from the Source form of the Work, excluding those notices that do not pertain to any part of the Derivative Works; and (d) If the Work includes a \u201cNOTICE\u201d text file as part of its distribution, then any Derivative Works that You distribute must include a readable copy of the attribution notices contained within such NOTICE file, excluding those notices that do not pertain to any part of the Derivative Works, in at least one of the following places: within a NOTICE text file distributed as part of the Derivative Works; within the Source form or documentation, if provided along with the Derivative Works; or, within a display generated by the Derivative Works, if and wherever such third-party notices normally appear. The contents of the NOTICE file are for informational purposes only and do not modify the License. You may add Your own attribution notices within Derivative Works that You distribute, alongside or as an addendum to the NOTICE text from the Work, provided that such additional attribution notices cannot be construed as modifying the License. You may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise complies with the conditions stated in this License.","title":"4. Redistribution"},{"location":"license/#5-submission-of-contributions","text":"Unless You explicitly state otherwise, any Contribution intentionally submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this License, without any additional terms or conditions. Notwithstanding the above, nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding such Contributions.","title":"5. Submission of Contributions"},{"location":"license/#6-trademarks","text":"This License does not grant permission to use the trade names, trademarks, service marks, or product names of the Licensor, except as required for reasonable and customary use in describing the origin of the Work and reproducing the content of the NOTICE file.","title":"6. Trademarks"},{"location":"license/#7-disclaimer-of-warranty","text":"Unless required by applicable law or agreed to in writing, Licensor provides the Work (and each Contributor provides its Contributions) on an \u201cAS IS\u201d BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining the appropriateness of using or redistributing the Work and assume any risks associated with Your exercise of permissions under this License.","title":"7. Disclaimer of Warranty"},{"location":"license/#8-limitation-of-liability","text":"In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall any Contributor be liable to You for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising as a result of this License or out of the use or inability to use the Work (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if such Contributor has been advised of the possibility of such damages.","title":"8. Limitation of Liability"},{"location":"license/#9-accepting-warranty-or-additional-liability","text":"While redistributing the Work or Derivative Works thereof, You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this License. However, in accepting such obligations, You may act only on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, and only if You agree to indemnify, defend, and hold each Contributor harmless for any liability incurred by, or claims asserted against, such Contributor by reason of your accepting any such warranty or additional liability. Copyright 2019 Artificial Intelligence Redefined","title":"9. Accepting Warranty or Additional Liability"},{"location":"cogment/cogment-api-guide/","text":"Cogment High-Level API guide \u00b6 NOTE: Some features aren't available in Javascript, if there's only python examples under a certain section, that feature is python only Prerequisites \u00b6 This document assumes the reader is familiar with the Cogment Fundamentals . The High-level Cogment API expects users to use protocol buffers to declare a project's data structures. The intricacies of protobufs are beyond the scope of this document. Basic knowledge of the technology and its usage is assumed. The spec file \u00b6 An actor class is primarily defined by its observation space and action space . The data structures describing these spaces are declared by using a protocol buffer message type. Observations and actions will simply be instances of the matching type. For example, in the following, driver and pedestrian share a common view of the environment, hence use the same observation space, but have different actions available to them. import: proto: - city.proto actors: driver: observation: space: city.Observation action: space: city.DriverAction pedestrian: observation: space: city.Observation action: space: city.PedestrianAction \u26a0\ufe0f This shows only the relevant part of the full spec file, you can find the full list of configurable options in the reference page . Compiling the spec file \u00b6 In order to use the spec file (typically named cogment.yaml ) within the various supported languages, it needs to be compiled. This is done by the code generation modules of the specific language's SDK you are using. Refer to the language specific documentation for instructions Environment \u00b6 Environments are implemented by a Python function that uses a cogment.EnvironmentSession instance. This function will be called once for each trial . This function usually consists of three sections. The environment's initialization , where its internal state can be initialized and processes started. It ends with the sending of the initial observations to the actors participating in the trial. Its event loop , where the environment iterates through the events occurring during the trial and produces observations as well as receives messages . In this loop the environment can end the trial on its own or the end can be requested by a controller . Its termination , where cleanup occurs. In the common case where all actors within a trial share the same observation, a bare-minimum environment service would look like this: async def environment(environment_session): # -- Initialization -- # Retrieve the actors participating in the trial actors = environment_session.get_active_actors() # Start the trial and send a starting observation to all actors environment_session.start([(\"*\", Observation())]) # -- Event loop -- async for event in environment_session.event_loop(): if event.actions: # `event.actions` is a list of the actions done by the actors actions = event.actions if event.type == cogment.EventType.ACTIVE: # The trial is active, produce an observation in response to the actions environment_session.produce_observations([(\"*\", Observation())]) # Alternatively the environment can decide to **end** the trial with the following # environment_session.end([(\"*\", Observation())]) else: # The trial termination has been requested by an external controller # Produce a final observation environment_session.end([(\"*\", Observation())]) for message in event.messages: # `event.messages` is a list of all the messages received by the environment (it can be empty) # Handle each message here. # -- Termination -- This environment implementation needs to be registered and served so that the orchestrator can reach it. This can be done through a Context instance. context = cogment.Context(user_id=\"my_user_id\", cog_settings=cog_settings) context.register_environment(impl=environment) await context.serve_all_registered(cogment.ServedEndpoint(port=9000)) Sending observations \u00b6 The environment session has 3 different methods able to send observations: start , produce_observations and end . Each of those methods takes a list of 2-tuples destination / observation. As demonstrated above, sending the same observation to all actors is done using \"*\" as the destination. environment_session.produce_observations([(\"*\", Observation(...))]) It is also possible to send different observations to different actors. This can be useful to send observations of the world from the point of view of the actor or to send partial observations. environment_session.produce_observations([ (\"my_first_actor_name\", Observation(...)), (\"my_second_actor_name\", Observation(...)) ]) Please note that the environment should always send observations such as each actor in the trial receives one. Actor \u00b6 Actors implementations look a lot like the environment's . They take a cogment.ActorSession instance and have the same three sections: initialization , event loop and termination . The event loops in Actors' implementations handle three basic types of events: observation produced by the environment and that should lead to an action being done. rewards sent by other actors or the environment, we'll talk about them in more details below . messages sent by other actors or the environment, we'll talk about them in more details below . A typical actor implementation would look like this: Python async def driver_actor(actor_session): # -- Initialization -- # Notify that the actor is ready for the trial to start. actor_session.start() async for event in actor_session.event_loop(): if event.observation: # `event.observation` is an instance of the Observation produced by the environment observation = event.observation if event.type == cogment.EventType.ACTIVE: # The trial is active, it is expecting the agent to do an action actor_session.do_action(DriverAction(...)) for reward in event.rewards: # `event.rewards` is a list of all the rewards received by the actor (it can be empty) # Handle each reward here. for message in event.messages: # `event.messages` is a list of all the messages received by the actor (it can be empty) # Handle each message here. Javascript const driverActor = async (actorSession) => { // -- Initialization -- // Notify that the actor is ready for the trial to start. actorSession.start(); for await (const event of actorSession.eventLoop()) { if (event.observation){ // `event.observation` is an instance of the Observation produced by the environment observation = event.observation if event.type == cogment.EventType.ACTIVE: // The trial is active, it is expecting the agent to do an action actorSession.sendAction(new DriverAction()) } for (const reward of event.rewards){ // `event.rewards` is a list of all the rewards received by the actor (it can be empty) // Handle each reward here. } for (const message of event.messages){ // `event.messages` is a list of all the messages received by the actor (it can be empty) // Handle each message here. } } } Service actor / Client actor \u00b6 A Cogment app can use two types of actors, they are identical in terms of implementation but differ in how they interact with the app's Orchestrator . Service actors are accessible in the same way the environment is, through a Context instance. context = cogment.Context(cog_settings=cog_settings, user_id=\"rps\") context.register_actor(impl=actor, impl_name=\"driver_actor\", actor_classes=[\"driver\"]) context.register_actor(impl=actor_slow, impl_name=\"driver_actor_slow\", actor_classes=[\"driver\"]) await context.serve_all_registered(cogment.ServedEndpoint(port=9000)) Note that it is also through this registrating that the implementation is associated with one or more actor classes it implements. Client actors , contrary to Service actors, are not served to the orchestrator . They connect as clients of the orchestrator and join a trial that has started. Python context = cogment.Context(cog_settings=cog_settings, user_id=\"rps\") context.register_actor(impl=actor, impl_name=\"driver_actor\", actor_classes=[\"driver\"]) await context.join_trial(trial_id=trial_id, cogment.Endpoint(url=\"grpc://orchestrator:9000\"), actor_name=\"Alice\") Javascript const grpcURL = \"http://someGrpcWebProxyEndpoint:port\" const service = cogment.createService({ cogSettings, grpcURL, }); const actor = { name: actorName, actorClass: actorClass }; service.registerActor( actor, actorImpl ) const trialController = service.createTrialController(); trialController.joinTrial(trialId, actor); Note that a trial including one or more client actors will wait for all of them to join before any actor can start processing events. Due to the different network requirements, client actors are a good fit when implementing a frontend for human actors. In addition to the python SDK demonstrated above, client actors can be implemented in javascript using the corresponding SDK. Controller \u00b6 Trials are started by clients of the Orchestrator using a Controller. Instances of a controller are built from the Context instance and connect to an Orchestrator endpoint. Python controller = context.get_controller(endpoint=cogment.Endpoint(url=\"grpc://orchestrator:9000\")) Javascript const service = cogment.createService({ cogSettings, \"grpc://orchestrator:9000\", }); const trialController = service.createTrialController(); The controller can then be used to create trials and request their termination. Python trial_id = await controller.start_trial(trial_config=TrialConfig()) # ... await controller.terminate_trial(trial_id) Javascript const {trialId} = await trialController.startTrial(someActorClass, new TrialConfig()); // ... await trialControler.terminateTrial(trialId) The controller can also be used to subscribe to events occuring in the trials run by the Orchestrator it connects to. For example, this can be used to wait for a trial's end: Python async for trial_info in controller.watch_trials(trial_state_filters=[cogment.TrialState.ENDED]): # The trial having id {trial_info.trial_id} ended. Javascript for await (const trialListEntry of trialController.watchTrials([ cogment.TrialState.ENDED ])) { // The trial having id {trialListEntry.getTrialId()} ended. } The full documentation for the controller can be found here . Rewards \u00b6 Creating \u00b6 Rewards are sent to actors from another actor or the environment . The session instance passed to their implementation can be used for this purpose. session.add_reward(value=-1, confidence=1, tick_id=-1, to=['an_actor_name']) Rewards consist of an arbitrary numerical value describing how the reward \"sender\" believes the actor performed. It is weighted by a value between 0 and 1 qualifying the confidence of the \"sender\" in its reward, from a very low confidence just above 0 to a very high confidence approaching 1. The confidence value is used to collate all the rewards sent to an actor at the same time. Optionally, a reward can be provided with arbitrary user data. Each reward applies to a list of recipients (either all the actors, all the actors of a given class or a specific actor) at a specific point in time, during the trial, defined as a tick . The full documentation for session.add_reward can be found here . Consuming \u00b6 All the rewards that are sent and destined to each specific actor for a given point in time are collated together by the framework. The actor can take into account the reward directly as the trial is running by consuming the \"reward\" event in their event loop. Python async for event in actor_session.event_loop(): # [...] for reward in event.rewards: # `reward.tick_id` is the id of the tick this reward concerns. tick_id = reward.tick_id # `reward.value` is the aggregated value of the reward. value = reward.value for source_reward in reward.all_sources(): # Iterate over individual source rewards. reward_value = source_reward.value reward_confidence = source_reward.confidence reward_sender = source_reward.sender reward_user_data = source_reward.user_data Javascript for await (const event of actorSession.eventLoop()) { // [...] for (const reward of event.rewards){ // `reward.tickId` is the id of the tick this reward concerns. const tickId = reward.tickId // `reward.value` is the aggregated value of the reward. const value = reward.value for (sourceReward of reward.sourcesList) { // Iterate over individual source rewards. const rewardValue = sourceReward.value const rewardConfidence = sourceReward.confidence const rewardSender = sourceReward.senderName const rewardUserData = sourceReward.userData } } } Messages \u00b6 Creating \u00b6 Messages can be created and sent between actors or the environment within a trial using their session instance. Python session.send_message( user_data=MyProtobufDataStructure(...), # any protobuf data structure can be used here. to=['pedestrian:*'], # send the message to all the actors of the \"pedestrian\" class ) Javascript const message = new Message(); message.setRequest(\"hello\"); // Now we serialize into an Any protobuf message. const anyPb = new MyProtobufDataStructure(); anyPb.pack(message.serializeBinary(), 'cogment_app.Message'); actorSession.sendMessage({ from: actorName, payload: anyPb, to: 'otherActorName', trialId, }); Messages consist of an arbitrary payload, their user_data/payload , defined as an instance of any protobuf data structure. A message can be sent to one, many or all actors in a trial and / or to the environment. The full documentation for session.send_message can be found here . Consuming \u00b6 All the messages that are sent and intended for each specific actor or environment will be received by the target actor or environment. Actors or the environment can use the message directly, live, as the trial is running by consuming message event in their event loop. Python async for event in actor_session.event_loop(): # [...] for message in event.messages: # `message.sender_name` is the name of the actor who sent a message sender_name = message.sender_name # `message.payload` is the content of the message, it needs to be unpacked payload = message.payload Javascript for await (const event of actorSession.eventLoop()) { // [...] for (const message of event.messages){ // `message.sender_name` is the name of the actor who sent a message const sender = message.sender // `message.data` is the content of the message, it needs to be unpacked const data = message.data const newMessage = data.unpack( (x: Uint8Array) => Message.deserializeBinary(x), 'cogment_app.Message', ); } } Pre-trial hook \u00b6 When starting a trial from a controller an instance of the message type defined in trial:config_type can be provided. This instance is then passed to the registered Pre trial hooks when the Orcehstrator was started. The role of these hooks is to fully parametrize the trial based on the provided config. To achieve that, they can modify the default trial params defined in the parameters to specify the environment (i.e. its endpoint, implementation name & configuration), the number and parameters of the participant actors (i.e. their name, class, endpoint, implementation name & configuration) as well as additional parameters for the trial. The pre-trial hook can therefore be used to dynamically configure trials, to act as a service endpoint registry, or a load balancer. Pre-trial hook implementations are registered in the same way the environment or actor implementation are and follow the same session pattern. async def my_pre_trial_hook(pre_hook_session): # The trial config provided by the controller can be retrieved like that trial_config = pre_hook_session.trial_config # The trial params can be edited directly pre_hook_session.environment_config = # [...] pre_hook_session.environment_endpoint = \"grpc://my_environment:9000\" pre_hook_session.actors = [ { \"name\": \"my_first_actor_name\", \"actor_class\": \"driver\", \"endpoint\": \"grpc://driver:9000\", \"implementation\": \"driver_actor\", \"config\": # [...], }, { \"name\": \"my_second_actor_name\", \"actor_class\": \"predestrian\", \"endpoint\": \"cogment://client\", \"config\": # [...], }, ] # And finally should be validated pre_hook_session.validate() context.register_pre_trial_hook(impl=my_pre_trial_hook)","title":"API Guide"},{"location":"cogment/cogment-api-guide/#cogment-high-level-api-guide","text":"NOTE: Some features aren't available in Javascript, if there's only python examples under a certain section, that feature is python only","title":"Cogment High-Level API guide"},{"location":"cogment/cogment-api-guide/#prerequisites","text":"This document assumes the reader is familiar with the Cogment Fundamentals . The High-level Cogment API expects users to use protocol buffers to declare a project's data structures. The intricacies of protobufs are beyond the scope of this document. Basic knowledge of the technology and its usage is assumed.","title":"Prerequisites"},{"location":"cogment/cogment-api-guide/#the-spec-file","text":"An actor class is primarily defined by its observation space and action space . The data structures describing these spaces are declared by using a protocol buffer message type. Observations and actions will simply be instances of the matching type. For example, in the following, driver and pedestrian share a common view of the environment, hence use the same observation space, but have different actions available to them. import: proto: - city.proto actors: driver: observation: space: city.Observation action: space: city.DriverAction pedestrian: observation: space: city.Observation action: space: city.PedestrianAction \u26a0\ufe0f This shows only the relevant part of the full spec file, you can find the full list of configurable options in the reference page .","title":"The spec file"},{"location":"cogment/cogment-api-guide/#compiling-the-spec-file","text":"In order to use the spec file (typically named cogment.yaml ) within the various supported languages, it needs to be compiled. This is done by the code generation modules of the specific language's SDK you are using. Refer to the language specific documentation for instructions","title":"Compiling the spec file"},{"location":"cogment/cogment-api-guide/#environment","text":"Environments are implemented by a Python function that uses a cogment.EnvironmentSession instance. This function will be called once for each trial . This function usually consists of three sections. The environment's initialization , where its internal state can be initialized and processes started. It ends with the sending of the initial observations to the actors participating in the trial. Its event loop , where the environment iterates through the events occurring during the trial and produces observations as well as receives messages . In this loop the environment can end the trial on its own or the end can be requested by a controller . Its termination , where cleanup occurs. In the common case where all actors within a trial share the same observation, a bare-minimum environment service would look like this: async def environment(environment_session): # -- Initialization -- # Retrieve the actors participating in the trial actors = environment_session.get_active_actors() # Start the trial and send a starting observation to all actors environment_session.start([(\"*\", Observation())]) # -- Event loop -- async for event in environment_session.event_loop(): if event.actions: # `event.actions` is a list of the actions done by the actors actions = event.actions if event.type == cogment.EventType.ACTIVE: # The trial is active, produce an observation in response to the actions environment_session.produce_observations([(\"*\", Observation())]) # Alternatively the environment can decide to **end** the trial with the following # environment_session.end([(\"*\", Observation())]) else: # The trial termination has been requested by an external controller # Produce a final observation environment_session.end([(\"*\", Observation())]) for message in event.messages: # `event.messages` is a list of all the messages received by the environment (it can be empty) # Handle each message here. # -- Termination -- This environment implementation needs to be registered and served so that the orchestrator can reach it. This can be done through a Context instance. context = cogment.Context(user_id=\"my_user_id\", cog_settings=cog_settings) context.register_environment(impl=environment) await context.serve_all_registered(cogment.ServedEndpoint(port=9000))","title":"Environment"},{"location":"cogment/cogment-api-guide/#sending-observations","text":"The environment session has 3 different methods able to send observations: start , produce_observations and end . Each of those methods takes a list of 2-tuples destination / observation. As demonstrated above, sending the same observation to all actors is done using \"*\" as the destination. environment_session.produce_observations([(\"*\", Observation(...))]) It is also possible to send different observations to different actors. This can be useful to send observations of the world from the point of view of the actor or to send partial observations. environment_session.produce_observations([ (\"my_first_actor_name\", Observation(...)), (\"my_second_actor_name\", Observation(...)) ]) Please note that the environment should always send observations such as each actor in the trial receives one.","title":"Sending observations"},{"location":"cogment/cogment-api-guide/#actor","text":"Actors implementations look a lot like the environment's . They take a cogment.ActorSession instance and have the same three sections: initialization , event loop and termination . The event loops in Actors' implementations handle three basic types of events: observation produced by the environment and that should lead to an action being done. rewards sent by other actors or the environment, we'll talk about them in more details below . messages sent by other actors or the environment, we'll talk about them in more details below . A typical actor implementation would look like this: Python async def driver_actor(actor_session): # -- Initialization -- # Notify that the actor is ready for the trial to start. actor_session.start() async for event in actor_session.event_loop(): if event.observation: # `event.observation` is an instance of the Observation produced by the environment observation = event.observation if event.type == cogment.EventType.ACTIVE: # The trial is active, it is expecting the agent to do an action actor_session.do_action(DriverAction(...)) for reward in event.rewards: # `event.rewards` is a list of all the rewards received by the actor (it can be empty) # Handle each reward here. for message in event.messages: # `event.messages` is a list of all the messages received by the actor (it can be empty) # Handle each message here. Javascript const driverActor = async (actorSession) => { // -- Initialization -- // Notify that the actor is ready for the trial to start. actorSession.start(); for await (const event of actorSession.eventLoop()) { if (event.observation){ // `event.observation` is an instance of the Observation produced by the environment observation = event.observation if event.type == cogment.EventType.ACTIVE: // The trial is active, it is expecting the agent to do an action actorSession.sendAction(new DriverAction()) } for (const reward of event.rewards){ // `event.rewards` is a list of all the rewards received by the actor (it can be empty) // Handle each reward here. } for (const message of event.messages){ // `event.messages` is a list of all the messages received by the actor (it can be empty) // Handle each message here. } } }","title":"Actor"},{"location":"cogment/cogment-api-guide/#service-actor-client-actor","text":"A Cogment app can use two types of actors, they are identical in terms of implementation but differ in how they interact with the app's Orchestrator . Service actors are accessible in the same way the environment is, through a Context instance. context = cogment.Context(cog_settings=cog_settings, user_id=\"rps\") context.register_actor(impl=actor, impl_name=\"driver_actor\", actor_classes=[\"driver\"]) context.register_actor(impl=actor_slow, impl_name=\"driver_actor_slow\", actor_classes=[\"driver\"]) await context.serve_all_registered(cogment.ServedEndpoint(port=9000)) Note that it is also through this registrating that the implementation is associated with one or more actor classes it implements. Client actors , contrary to Service actors, are not served to the orchestrator . They connect as clients of the orchestrator and join a trial that has started. Python context = cogment.Context(cog_settings=cog_settings, user_id=\"rps\") context.register_actor(impl=actor, impl_name=\"driver_actor\", actor_classes=[\"driver\"]) await context.join_trial(trial_id=trial_id, cogment.Endpoint(url=\"grpc://orchestrator:9000\"), actor_name=\"Alice\") Javascript const grpcURL = \"http://someGrpcWebProxyEndpoint:port\" const service = cogment.createService({ cogSettings, grpcURL, }); const actor = { name: actorName, actorClass: actorClass }; service.registerActor( actor, actorImpl ) const trialController = service.createTrialController(); trialController.joinTrial(trialId, actor); Note that a trial including one or more client actors will wait for all of them to join before any actor can start processing events. Due to the different network requirements, client actors are a good fit when implementing a frontend for human actors. In addition to the python SDK demonstrated above, client actors can be implemented in javascript using the corresponding SDK.","title":"Service actor / Client actor"},{"location":"cogment/cogment-api-guide/#controller","text":"Trials are started by clients of the Orchestrator using a Controller. Instances of a controller are built from the Context instance and connect to an Orchestrator endpoint. Python controller = context.get_controller(endpoint=cogment.Endpoint(url=\"grpc://orchestrator:9000\")) Javascript const service = cogment.createService({ cogSettings, \"grpc://orchestrator:9000\", }); const trialController = service.createTrialController(); The controller can then be used to create trials and request their termination. Python trial_id = await controller.start_trial(trial_config=TrialConfig()) # ... await controller.terminate_trial(trial_id) Javascript const {trialId} = await trialController.startTrial(someActorClass, new TrialConfig()); // ... await trialControler.terminateTrial(trialId) The controller can also be used to subscribe to events occuring in the trials run by the Orchestrator it connects to. For example, this can be used to wait for a trial's end: Python async for trial_info in controller.watch_trials(trial_state_filters=[cogment.TrialState.ENDED]): # The trial having id {trial_info.trial_id} ended. Javascript for await (const trialListEntry of trialController.watchTrials([ cogment.TrialState.ENDED ])) { // The trial having id {trialListEntry.getTrialId()} ended. } The full documentation for the controller can be found here .","title":"Controller"},{"location":"cogment/cogment-api-guide/#rewards","text":"","title":"Rewards"},{"location":"cogment/cogment-api-guide/#creating","text":"Rewards are sent to actors from another actor or the environment . The session instance passed to their implementation can be used for this purpose. session.add_reward(value=-1, confidence=1, tick_id=-1, to=['an_actor_name']) Rewards consist of an arbitrary numerical value describing how the reward \"sender\" believes the actor performed. It is weighted by a value between 0 and 1 qualifying the confidence of the \"sender\" in its reward, from a very low confidence just above 0 to a very high confidence approaching 1. The confidence value is used to collate all the rewards sent to an actor at the same time. Optionally, a reward can be provided with arbitrary user data. Each reward applies to a list of recipients (either all the actors, all the actors of a given class or a specific actor) at a specific point in time, during the trial, defined as a tick . The full documentation for session.add_reward can be found here .","title":"Creating"},{"location":"cogment/cogment-api-guide/#consuming","text":"All the rewards that are sent and destined to each specific actor for a given point in time are collated together by the framework. The actor can take into account the reward directly as the trial is running by consuming the \"reward\" event in their event loop. Python async for event in actor_session.event_loop(): # [...] for reward in event.rewards: # `reward.tick_id` is the id of the tick this reward concerns. tick_id = reward.tick_id # `reward.value` is the aggregated value of the reward. value = reward.value for source_reward in reward.all_sources(): # Iterate over individual source rewards. reward_value = source_reward.value reward_confidence = source_reward.confidence reward_sender = source_reward.sender reward_user_data = source_reward.user_data Javascript for await (const event of actorSession.eventLoop()) { // [...] for (const reward of event.rewards){ // `reward.tickId` is the id of the tick this reward concerns. const tickId = reward.tickId // `reward.value` is the aggregated value of the reward. const value = reward.value for (sourceReward of reward.sourcesList) { // Iterate over individual source rewards. const rewardValue = sourceReward.value const rewardConfidence = sourceReward.confidence const rewardSender = sourceReward.senderName const rewardUserData = sourceReward.userData } } }","title":"Consuming"},{"location":"cogment/cogment-api-guide/#messages","text":"","title":"Messages"},{"location":"cogment/cogment-api-guide/#creating_1","text":"Messages can be created and sent between actors or the environment within a trial using their session instance. Python session.send_message( user_data=MyProtobufDataStructure(...), # any protobuf data structure can be used here. to=['pedestrian:*'], # send the message to all the actors of the \"pedestrian\" class ) Javascript const message = new Message(); message.setRequest(\"hello\"); // Now we serialize into an Any protobuf message. const anyPb = new MyProtobufDataStructure(); anyPb.pack(message.serializeBinary(), 'cogment_app.Message'); actorSession.sendMessage({ from: actorName, payload: anyPb, to: 'otherActorName', trialId, }); Messages consist of an arbitrary payload, their user_data/payload , defined as an instance of any protobuf data structure. A message can be sent to one, many or all actors in a trial and / or to the environment. The full documentation for session.send_message can be found here .","title":"Creating"},{"location":"cogment/cogment-api-guide/#consuming_1","text":"All the messages that are sent and intended for each specific actor or environment will be received by the target actor or environment. Actors or the environment can use the message directly, live, as the trial is running by consuming message event in their event loop. Python async for event in actor_session.event_loop(): # [...] for message in event.messages: # `message.sender_name` is the name of the actor who sent a message sender_name = message.sender_name # `message.payload` is the content of the message, it needs to be unpacked payload = message.payload Javascript for await (const event of actorSession.eventLoop()) { // [...] for (const message of event.messages){ // `message.sender_name` is the name of the actor who sent a message const sender = message.sender // `message.data` is the content of the message, it needs to be unpacked const data = message.data const newMessage = data.unpack( (x: Uint8Array) => Message.deserializeBinary(x), 'cogment_app.Message', ); } }","title":"Consuming"},{"location":"cogment/cogment-api-guide/#pre-trial-hook","text":"When starting a trial from a controller an instance of the message type defined in trial:config_type can be provided. This instance is then passed to the registered Pre trial hooks when the Orcehstrator was started. The role of these hooks is to fully parametrize the trial based on the provided config. To achieve that, they can modify the default trial params defined in the parameters to specify the environment (i.e. its endpoint, implementation name & configuration), the number and parameters of the participant actors (i.e. their name, class, endpoint, implementation name & configuration) as well as additional parameters for the trial. The pre-trial hook can therefore be used to dynamically configure trials, to act as a service endpoint registry, or a load balancer. Pre-trial hook implementations are registered in the same way the environment or actor implementation are and follow the same session pattern. async def my_pre_trial_hook(pre_hook_session): # The trial config provided by the controller can be retrieved like that trial_config = pre_hook_session.trial_config # The trial params can be edited directly pre_hook_session.environment_config = # [...] pre_hook_session.environment_endpoint = \"grpc://my_environment:9000\" pre_hook_session.actors = [ { \"name\": \"my_first_actor_name\", \"actor_class\": \"driver\", \"endpoint\": \"grpc://driver:9000\", \"implementation\": \"driver_actor\", \"config\": # [...], }, { \"name\": \"my_second_actor_name\", \"actor_class\": \"predestrian\", \"endpoint\": \"cogment://client\", \"config\": # [...], }, ] # And finally should be validated pre_hook_session.validate() context.register_pre_trial_hook(impl=my_pre_trial_hook)","title":"Pre-trial hook"},{"location":"cogment/cogment-api-reference/cogment-v2-changes/","text":"Cogment 2.0 \u00b6 Note This document describes the full list of the changes for Cogment 2.O. A migration guide is available there . Cogment 2.0 is a massive internal change to Cogment, starting with the underlying gRPC API that has seen a major refactoring. But there is a minimal amount of changes that affect the use of cogment. The changes that affect users are in three categories: breaking changes, deprecated behavior and new functionalities. Breaking changes \u00b6 These are changes that, if the related features were used, will prevent Cogment v1 projects from working with Cogment v2. They represent the minimum changes necessary to upgrade to v2. Cogment.yaml \u00b6 Delta types of observations (and all related settings) are not supported anymore. This means that in cogment.yaml, these sections are now ignored: import::python import::javascript actor_classes::observation::delta actor_classes::observation::delta_apply_fn config (for trial, environment and actor) are not accepted in the parameters section anymore. Python SDK \u00b6 The Session.get_active_actors() method has been restricted to the environment only. This means that actors cannot call this method anymore (it will raise an exception). If actors need the full list of actors, there are a few possibilities: Create a controller in the actor implementation and use the Controller.get_actors() method. Receive the actor list in the config from the pre-trial hooks; the pre-trial hooks have implicit knowledge of all actors (at least the last hook). Add the information in the actors observation space. Send the information in a message. The EnvironmentSession.send_message() method will not accept a to_environment parameter anymore (since it does not make sense anyway). The Controller.terminate_trial() method parameter trial_id has been renamed trial_ids . The Controller.get_trial_info() method parameter trial_id has been renamed trial_ids . Javascript SDK \u00b6 Except for the following, everything has been subject to breaking changes: The shape of the observation object has remained the same You can keep the actor function that you have in your v1 project Please refer to the new Javascript API Reference Datalog sample \u00b6 Since the Datalog samples, unlike everything else in the SDK, used the raw API protobuf, it has implicitly changed. But in v2, there is now a wrapper for it, which replaces direct access to the protobuf content. If people still have serialized v1 data stored (e.g. in a database), v1 versions of the sample protobuf messages ( DatalogSample_v1 ) are provided in the API for convenience, so users can deserialize the data into v1 samples and extract the information. For more info, visit the gRPC api documentation Orchestrator \u00b6 The environment variables read by the Orchestrator on start have changed names to help prevent clashes. TRIAL_LIFECYCLE_PORT becomes COGMENT_LIFECYCLE_PORT TRIAL_ACTOR_PORT becomes COGMENT_ACTOR_PORT PROMETHEUS_PORT becomes COGMENT_ORCHESTRATOR_PROMETHEUS_PORT The Orchestrator does not search for the file named cogment.yaml as the default spec file anymore. The spec file name must be explicit on the command line using --config=cogment.yaml . For further information, refer to the Orchestrator documentation . Deprecated Behaviors \u00b6 These are changes that are optional to upgrade to Cogment v2, but will eventually be phased out and become breaking changes in a future version. If these features are used with Cogment v2, warnings will be issued. Cogment.yaml \u00b6 The spec file is not used by the Orchestrator anymore, and when used by the other components, these sections of the file will be ignored: The trial_params section is not needed anymore (since the Orchestrator has its own parameters file) The datalog section is deprecated (the details of the datalog have been moved to the Orchestrator parameters file) The trial:pre-hooks section is deprecated (these values are now passed to the Orchestrator on the command line) For more information, visit the Cogment.yaml documentation . Orchestrator \u00b6 Providing a spec file (cogment.yaml) to the Orchestrator is deprecated. The new behavior is as follows: Provide a YAML default parameters file (command line option --params ) with the top level section trial_params . Add the datalog section to the parameters (if desired), without type (for type none just omit the datalog section). I.e. Whereas the spec file was defining a single data logger for all trials, the new Orchestrator can have a different data logger for each trial, and thus a datalog section is now found in the trial default parameters. Example of the new parameters datalog section: trial_params: datalog: - endpoint: grpc://logger:9000 - exclude_fields: [messages, actions] The endpoint for a client actor in the parameters must now be cogment://client instead of just client . E.g.: trial_params: actors: - endpoint: cogment://client Pre-trial hooks are defined on the command line (or environment variable) as opposed to being found in the spec file. Note The Cogment Orchestrator and the generate tools ignore the sections of the YAML files that are not relevant to them, therefore the content of the spec and parameters files can be combined in a single file safely. The Orchestrator needs a parameters file or pre-trial hooks (or both). Thus with pre-trial hooks and no parameters file (or a carefully defined parameters file) the Orchestrator is now independent of any trial specifications (spec file) and can run any type of trial. With a fully defined parameters file and no hooks, the Orchestrator can work as before for simple projects. Python SDK \u00b6 The ActorSession.send_message() method should not use the to_environment parameter anymore. The environment is targeted using its name (defaulted to \"env\" if not given specifically, or ActorSession.env_name ). The joining of a trial by a client actor ( Context.join_trial() ) should now be made by providing an actor name or class (unlike previously where an implementation name was provided). This is to allow the pre-trial hooks to decide on the details of the actor (including implementation) that should be used, the same way as for service actors. In RecvObservation , the snapshot attribute is deprecated. A new attribute observation takes its place. The Controller.terminate_trial() method parameter trial_ids now takes a list of IDs (instead of a single string for one ID). The Controller.get_trial_info() method parameter trial_ids now takes a list of IDs (instead of a single string for one ID or None ). The url attribute of cogment.Endpoint must now be a gRPC type URL (i.e. start with grpc:// ). Endpoint is used to join a trial and to get a Controller. New Functionalities \u00b6 These are changes that are additional and transparent to a v1 project. Parameters \u00b6 These are the parameters defined in the new file given to the Orchestrator, and that can be changed by pre-trial hooks. The environment can be given a name , similarly to the actors. If not given, it defaults to \"env\". Python SDK \u00b6 When starting a trial ( Controller.start_trial() ), a new trial_id_requested parameter requests the trial ID to be a specific string instead of an automatic UUID. It is a \"request\" because the trial will not start if the id conflicts with another active trial; an empty ID string will be returned if the trial is not started. Controller.terminate_trial() method has a new parameter hard . This parameter forces a hard/immediate termination of the trial. As opposed to a \"soft\" termination which will wait for the next tick to terminate nicely. The ActorSession and EnvironmentSession have a new method sending_done() to indicate that they have finished sending data and will now only be listening until the end of the trial. This is required only if the new auto_done_sending parameter of the start() method is False (It is True by default for backward compatibility). This only needs to be manually done (i.e. auto_done_sending=False ) in special situations. PrehookSession.get_user_id() new method. PrehookSession.environment_name new attribute. DatalogSession.user_id new attribute (this info used to be available in the protobuf DatalogSample ). RecvAction.tick_id new attribute.","title":"Cogment 2.0"},{"location":"cogment/cogment-api-reference/cogment-v2-changes/#cogment-20","text":"Note This document describes the full list of the changes for Cogment 2.O. A migration guide is available there . Cogment 2.0 is a massive internal change to Cogment, starting with the underlying gRPC API that has seen a major refactoring. But there is a minimal amount of changes that affect the use of cogment. The changes that affect users are in three categories: breaking changes, deprecated behavior and new functionalities.","title":"Cogment 2.0"},{"location":"cogment/cogment-api-reference/cogment-v2-changes/#breaking-changes","text":"These are changes that, if the related features were used, will prevent Cogment v1 projects from working with Cogment v2. They represent the minimum changes necessary to upgrade to v2.","title":"Breaking changes"},{"location":"cogment/cogment-api-reference/cogment-v2-changes/#cogmentyaml","text":"Delta types of observations (and all related settings) are not supported anymore. This means that in cogment.yaml, these sections are now ignored: import::python import::javascript actor_classes::observation::delta actor_classes::observation::delta_apply_fn config (for trial, environment and actor) are not accepted in the parameters section anymore.","title":"Cogment.yaml"},{"location":"cogment/cogment-api-reference/cogment-v2-changes/#python-sdk","text":"The Session.get_active_actors() method has been restricted to the environment only. This means that actors cannot call this method anymore (it will raise an exception). If actors need the full list of actors, there are a few possibilities: Create a controller in the actor implementation and use the Controller.get_actors() method. Receive the actor list in the config from the pre-trial hooks; the pre-trial hooks have implicit knowledge of all actors (at least the last hook). Add the information in the actors observation space. Send the information in a message. The EnvironmentSession.send_message() method will not accept a to_environment parameter anymore (since it does not make sense anyway). The Controller.terminate_trial() method parameter trial_id has been renamed trial_ids . The Controller.get_trial_info() method parameter trial_id has been renamed trial_ids .","title":"Python SDK"},{"location":"cogment/cogment-api-reference/cogment-v2-changes/#javascript-sdk","text":"Except for the following, everything has been subject to breaking changes: The shape of the observation object has remained the same You can keep the actor function that you have in your v1 project Please refer to the new Javascript API Reference","title":"Javascript SDK"},{"location":"cogment/cogment-api-reference/cogment-v2-changes/#datalog-sample","text":"Since the Datalog samples, unlike everything else in the SDK, used the raw API protobuf, it has implicitly changed. But in v2, there is now a wrapper for it, which replaces direct access to the protobuf content. If people still have serialized v1 data stored (e.g. in a database), v1 versions of the sample protobuf messages ( DatalogSample_v1 ) are provided in the API for convenience, so users can deserialize the data into v1 samples and extract the information. For more info, visit the gRPC api documentation","title":"Datalog sample"},{"location":"cogment/cogment-api-reference/cogment-v2-changes/#orchestrator","text":"The environment variables read by the Orchestrator on start have changed names to help prevent clashes. TRIAL_LIFECYCLE_PORT becomes COGMENT_LIFECYCLE_PORT TRIAL_ACTOR_PORT becomes COGMENT_ACTOR_PORT PROMETHEUS_PORT becomes COGMENT_ORCHESTRATOR_PROMETHEUS_PORT The Orchestrator does not search for the file named cogment.yaml as the default spec file anymore. The spec file name must be explicit on the command line using --config=cogment.yaml . For further information, refer to the Orchestrator documentation .","title":"Orchestrator"},{"location":"cogment/cogment-api-reference/cogment-v2-changes/#deprecated-behaviors","text":"These are changes that are optional to upgrade to Cogment v2, but will eventually be phased out and become breaking changes in a future version. If these features are used with Cogment v2, warnings will be issued.","title":"Deprecated Behaviors"},{"location":"cogment/cogment-api-reference/cogment-v2-changes/#cogmentyaml_1","text":"The spec file is not used by the Orchestrator anymore, and when used by the other components, these sections of the file will be ignored: The trial_params section is not needed anymore (since the Orchestrator has its own parameters file) The datalog section is deprecated (the details of the datalog have been moved to the Orchestrator parameters file) The trial:pre-hooks section is deprecated (these values are now passed to the Orchestrator on the command line) For more information, visit the Cogment.yaml documentation .","title":"Cogment.yaml"},{"location":"cogment/cogment-api-reference/cogment-v2-changes/#orchestrator_1","text":"Providing a spec file (cogment.yaml) to the Orchestrator is deprecated. The new behavior is as follows: Provide a YAML default parameters file (command line option --params ) with the top level section trial_params . Add the datalog section to the parameters (if desired), without type (for type none just omit the datalog section). I.e. Whereas the spec file was defining a single data logger for all trials, the new Orchestrator can have a different data logger for each trial, and thus a datalog section is now found in the trial default parameters. Example of the new parameters datalog section: trial_params: datalog: - endpoint: grpc://logger:9000 - exclude_fields: [messages, actions] The endpoint for a client actor in the parameters must now be cogment://client instead of just client . E.g.: trial_params: actors: - endpoint: cogment://client Pre-trial hooks are defined on the command line (or environment variable) as opposed to being found in the spec file. Note The Cogment Orchestrator and the generate tools ignore the sections of the YAML files that are not relevant to them, therefore the content of the spec and parameters files can be combined in a single file safely. The Orchestrator needs a parameters file or pre-trial hooks (or both). Thus with pre-trial hooks and no parameters file (or a carefully defined parameters file) the Orchestrator is now independent of any trial specifications (spec file) and can run any type of trial. With a fully defined parameters file and no hooks, the Orchestrator can work as before for simple projects.","title":"Orchestrator"},{"location":"cogment/cogment-api-reference/cogment-v2-changes/#python-sdk_1","text":"The ActorSession.send_message() method should not use the to_environment parameter anymore. The environment is targeted using its name (defaulted to \"env\" if not given specifically, or ActorSession.env_name ). The joining of a trial by a client actor ( Context.join_trial() ) should now be made by providing an actor name or class (unlike previously where an implementation name was provided). This is to allow the pre-trial hooks to decide on the details of the actor (including implementation) that should be used, the same way as for service actors. In RecvObservation , the snapshot attribute is deprecated. A new attribute observation takes its place. The Controller.terminate_trial() method parameter trial_ids now takes a list of IDs (instead of a single string for one ID). The Controller.get_trial_info() method parameter trial_ids now takes a list of IDs (instead of a single string for one ID or None ). The url attribute of cogment.Endpoint must now be a gRPC type URL (i.e. start with grpc:// ). Endpoint is used to join a trial and to get a Controller.","title":"Python SDK"},{"location":"cogment/cogment-api-reference/cogment-v2-changes/#new-functionalities","text":"These are changes that are additional and transparent to a v1 project.","title":"New Functionalities"},{"location":"cogment/cogment-api-reference/cogment-v2-changes/#parameters","text":"These are the parameters defined in the new file given to the Orchestrator, and that can be changed by pre-trial hooks. The environment can be given a name , similarly to the actors. If not given, it defaults to \"env\".","title":"Parameters"},{"location":"cogment/cogment-api-reference/cogment-v2-changes/#python-sdk_2","text":"When starting a trial ( Controller.start_trial() ), a new trial_id_requested parameter requests the trial ID to be a specific string instead of an automatic UUID. It is a \"request\" because the trial will not start if the id conflicts with another active trial; an empty ID string will be returned if the trial is not started. Controller.terminate_trial() method has a new parameter hard . This parameter forces a hard/immediate termination of the trial. As opposed to a \"soft\" termination which will wait for the next tick to terminate nicely. The ActorSession and EnvironmentSession have a new method sending_done() to indicate that they have finished sending data and will now only be listening until the end of the trial. This is required only if the new auto_done_sending parameter of the start() method is False (It is True by default for backward compatibility). This only needs to be manually done (i.e. auto_done_sending=False ) in special situations. PrehookSession.get_user_id() new method. PrehookSession.environment_name new attribute. DatalogSession.user_id new attribute (this info used to be available in the protobuf DatalogSample ). RecvAction.tick_id new attribute.","title":"Python SDK"},{"location":"cogment/cogment-api-reference/cogment-yaml/","text":"Spec File \u00b6 The spec file (typically named cogment.yaml ) is central to every Cogment project that use a Cogment SDK. This file is used to define the specifics of a type of trials. It can also contain data (the commands section) used by the Cogment CLI tool. A generator tool specific to each SDK takes this file as its main input to, among other things, configure the SDK. The top level sections in the file are: import : Used to import other proto files into the definition of the project commands : Optional. Defines commands that can be run by the Cogment CLI trial : Define trial speficic properties environment : Define environment specific properties actor_classes : Define actor specific properties (for each actor class) In this document, \"section\" refers to YAML mappings. Import \u00b6 The import section is used to specify external data structures, and optionally code, that is referenced in other parts of the file. The referenced files must be in the same folder as the spec file. The import sections are: proto : List of protobuf definition files. Message types defined in these files are used to communicate between the various components All Cogment projects will need at least one proto import to define the data structures exchanged between the various components. E.g.: import: proto: - filename1.proto - filename2.proto \u26a0\ufe0f N.B. When using message types imported from a .proto file, types need to be referred through their package namespace, not the filename containing them. Commands \u00b6 This section is optional and defines commands that can then be executed using the Cogment CLI run command. The commands will be executed by a sub-shell and thus can be any shell command. The commands can also recursively call Cogment, either built-in CLI commands, or other commands defined here. But care should be taken not to create infinite recursive calls. E.g.: commands: generate: | cd client && python -m cogment.generate --spec cogment.yaml && cd .. cd environment && python -m cogment.generate --spec cogment.yaml && cd .. copy: cogment copy cogment.yaml *.proto params.yaml client environment start: docker-compose up orchestrator agent env play: cogment run start && docker-compose run launcher To run one of these commands, the Cogment CLI command run must be used, e.g.: cogment run start . And as such there is no problem differentiating between cogment run copy and cogment copy (the latter is the builtin CLI command, and the former is the command defined in the cogment.yaml file). The cogment command section exists so that commands can be executed in a platform independant manner. Trial \u00b6 This section defines properties related to the trial and trial management. It has the properties: config_type : (optional) The protobuf message type (data structure) that will be passed on to the pre-trial hooks. E.g.: trial: config_type: namespace.DataType Environment \u00b6 This section defines properties related to the environment. It has the properties: config_type : (optional) The protobuf message type used to configure the environment environment: config_type: namespace.DataType Actor Classes \u00b6 Arguably the most important section of the spec file, the actor classes section describes the actor types that can be present in the project's trials. The content of this section is a list of actor classes, each containing the necessary properties to define an actor class. These properties are: name : The name by which this actor class is known action : Mapping of properties- space : The protobuf message type that represents all the possible actions that this actor class can perform (its action space) observation : Mapping of properties space : The protobuf message type that represents a snapshot of the data that this actor class has access to (its observation space) config_type : (optional) Defines the protobuf message type used to configure this actor class Each actor class should define both an observation and action space as protobuf message types. actor_classes: - name: BigPlayer action: space: namespace.PlayerAction observation: space: namespace.PlayerObservation config_type: namespace.PlayerConfig - name: SmallPlayer action: space: namespace.PlayerAction observation: space: namespace.PlayerObservation config_type: namespace.PlayerConfig - name: Referee action: space: namespace.RefereeAction observation: space: namespace.RefereeObservation config_type: namespace.RefereeConfig","title":"Spec file (cogment.yaml)"},{"location":"cogment/cogment-api-reference/cogment-yaml/#spec-file","text":"The spec file (typically named cogment.yaml ) is central to every Cogment project that use a Cogment SDK. This file is used to define the specifics of a type of trials. It can also contain data (the commands section) used by the Cogment CLI tool. A generator tool specific to each SDK takes this file as its main input to, among other things, configure the SDK. The top level sections in the file are: import : Used to import other proto files into the definition of the project commands : Optional. Defines commands that can be run by the Cogment CLI trial : Define trial speficic properties environment : Define environment specific properties actor_classes : Define actor specific properties (for each actor class) In this document, \"section\" refers to YAML mappings.","title":"Spec File"},{"location":"cogment/cogment-api-reference/cogment-yaml/#import","text":"The import section is used to specify external data structures, and optionally code, that is referenced in other parts of the file. The referenced files must be in the same folder as the spec file. The import sections are: proto : List of protobuf definition files. Message types defined in these files are used to communicate between the various components All Cogment projects will need at least one proto import to define the data structures exchanged between the various components. E.g.: import: proto: - filename1.proto - filename2.proto \u26a0\ufe0f N.B. When using message types imported from a .proto file, types need to be referred through their package namespace, not the filename containing them.","title":"Import"},{"location":"cogment/cogment-api-reference/cogment-yaml/#commands","text":"This section is optional and defines commands that can then be executed using the Cogment CLI run command. The commands will be executed by a sub-shell and thus can be any shell command. The commands can also recursively call Cogment, either built-in CLI commands, or other commands defined here. But care should be taken not to create infinite recursive calls. E.g.: commands: generate: | cd client && python -m cogment.generate --spec cogment.yaml && cd .. cd environment && python -m cogment.generate --spec cogment.yaml && cd .. copy: cogment copy cogment.yaml *.proto params.yaml client environment start: docker-compose up orchestrator agent env play: cogment run start && docker-compose run launcher To run one of these commands, the Cogment CLI command run must be used, e.g.: cogment run start . And as such there is no problem differentiating between cogment run copy and cogment copy (the latter is the builtin CLI command, and the former is the command defined in the cogment.yaml file). The cogment command section exists so that commands can be executed in a platform independant manner.","title":"Commands"},{"location":"cogment/cogment-api-reference/cogment-yaml/#trial","text":"This section defines properties related to the trial and trial management. It has the properties: config_type : (optional) The protobuf message type (data structure) that will be passed on to the pre-trial hooks. E.g.: trial: config_type: namespace.DataType","title":"Trial"},{"location":"cogment/cogment-api-reference/cogment-yaml/#environment","text":"This section defines properties related to the environment. It has the properties: config_type : (optional) The protobuf message type used to configure the environment environment: config_type: namespace.DataType","title":"Environment"},{"location":"cogment/cogment-api-reference/cogment-yaml/#actor-classes","text":"Arguably the most important section of the spec file, the actor classes section describes the actor types that can be present in the project's trials. The content of this section is a list of actor classes, each containing the necessary properties to define an actor class. These properties are: name : The name by which this actor class is known action : Mapping of properties- space : The protobuf message type that represents all the possible actions that this actor class can perform (its action space) observation : Mapping of properties space : The protobuf message type that represents a snapshot of the data that this actor class has access to (its observation space) config_type : (optional) Defines the protobuf message type used to configure this actor class Each actor class should define both an observation and action space as protobuf message types. actor_classes: - name: BigPlayer action: space: namespace.PlayerAction observation: space: namespace.PlayerObservation config_type: namespace.PlayerConfig - name: SmallPlayer action: space: namespace.PlayerAction observation: space: namespace.PlayerObservation config_type: namespace.PlayerConfig - name: Referee action: space: namespace.RefereeAction observation: space: namespace.RefereeObservation config_type: namespace.RefereeConfig","title":"Actor Classes"},{"location":"cogment/cogment-api-reference/javascript/","text":"Javascript SDK \u00b6 Installation \u00b6 The simplest way to install the Javascript SDK is to just install it using npm: npm install @cogment/cogment-js-sdk General usage \u00b6 The spec file \u00b6 The spec cogment.yaml file (including imported files) defines the message types of each component of Cogment. For example, an actor class is defined by its required observation space and action space . These \"spaces\" are defined by using protobuf message types (from the imported files). Observations and actions will simply be instances of the appropriate type. Messages and feedback user data don't have a set type, they can be any type as long as the receiver can manage that type. The type is determined by the provided message from the originator. They will mostly arrive as an instance of cogment.MessageBase and have fields according to their definition in your proto files. Trial Parameters \u00b6 The trial parameters either come from the default parameters provided to the Orchestrator on startup, or they are dynamically generated by the pre-trial hooks (themselves provided to the Orchestrator on startup). Or both, since the default parameters are initially provided to the pre-trial hooks. The parameters are mostly indepedent of the spec file, except that the active actors listed in the parameters must have their actor class match an actor class defined in the spec file. Below, when we refer to the trial parameters, we mean the final parameters after any pre-trial hooks. Compiling the spec file \u00b6 In order to use the specification found in the spec file within Javascript scripts, it needs to be compiled into Javascript modules. This is done by a tool called \"cogment-js-sdk-generate\". CogSettings.js \u00b6 All API entry points require a cogment specification object. This specification object can be determined from the content of a project's spec file. As such, it should be generated using the cogment-js-sdk-generate tool npx cogment-js-sdk-generate config.yaml This will generate both a CogSettings.js file, as well as any required compiled protocol buffer files. Imports \u00b6 Whether a script implements an actor or environment, it should import both the cogment module (generic Javascript SDK for Cogment) and the cogSettings module (project specific definitions created from the spec file). import { cogSettings } from './CogSettings'; import * as cogment from '@cogment/cogment-js-sdk' class cogment.Context \u00b6 Class to setup and run all the different aspects of trials. constructor(userId, cogSettings) \u00b6 Parameters: userId : string - Identifier for the user of this context. cogSettings : cogment.CogSettings - Settings module associated with trials that will be run ( cogSettings namespace). getController(endpoint) \u00b6 Method to get a controller instance to manage trials (start, stop, inquire, etc). Parameters: endpoint : string - URL of the connection to the Orchestrator. Return: Controller - An instance of the Controller class used to manage trials. async joinTrial(trialId, endpoint, actorName) \u00b6 Method for an actor to asynchronously join an existing trial. This task will normally end after the user implementation has exited. Parameters: trialId : string - The UUID of the trial to join. endpoint : string - URL of the connection to the Orchestrator. actorName : string - Name of the actor joining the trial. Return: void registerActor(impl, actorName, actorClass) \u00b6 Method to register the asynchronous callback function that will run an actor for a trial. Parameters: impl : async function(ActorSession instance) - Callback function to be registered. actorName : string - Name for the actor implementation being run by the given callback function. actorClass : string - The actor class name that can be run by the given callback function. The possible names are specified in spec file under section actorClasses:name . If the list is empty, this implementation can run any actor class. Return: void class Controller \u00b6 Class containing data and methods to control and manage trials. async startTrial(trialConfig = undefined, trialIdRequested = undefined) \u00b6 Method to start a new trial. The parameters of the trial will be set by the pre-trial hooks (registered in cogment.Context ), and the hooks will receive the provided trial config. Parameters: trialConfig : cogment.MessageBase - Configuration for the trial. The type is specified in the spec file under the section trial:config_type . Can be undefined if no configuration is provided. This is provided to the first pre-trial hook. trialIdRequested : string - The trial identifier requested for the new trial. It must be unique among all active trials and a limited set of the latest ended trials (this list of trials can be retrieved with getTrialInfo or watchTrial ). If provided, the Orchestrator will try to use this trialId, otherwise, a UUID will be created. Return: string - The newly started trial ID. terminate_trial(trialIds, hard = false) \u00b6 Method to request the end of a trial. Parameters: trialIds : string[] - The trial ID(s) to request to terminate. There must be at least one ID. hard : boolean - If true , the termination will be forced and not wait for any action or observation. If false , the trial will wait for the next tick, to end gracefully (i.e. wait for the next full set of actions and response observations). Return: void async getTrialInfo(trialIds) \u00b6 Method to get information about a trial. Parameters: trialIds : string[] - The trial ID(s) from which to request information. If no ID is provided, returns information about all trials. Note that ended trials may only appear for a short time in this list after they have ended. Return: TrialInfo[] - List of trial information, one per trial. Can be empty if no trial matches. async watchTrials(trialStateFilters=[]) \u00b6 Generator method to iterate, in real-time, through all trial states matching the filters. When called, it will first iterate over the current states matching the filters, for all trials. Afterwards, it will iterate in real-time over the matching states as they change. Parameters: trialStateFilters : cogment.TrialState[] - List of enum values from cogment.TrialState for which we are interested in receiving state changes. Return: generator(TrialInfo instance) - A generator for the state changes that arrive. The TrialInfo received here only contains the trial ID and the state. async getActors(trialId) \u00b6 Method to get the list of configured actors in a trial. Parameters: trialId : string - The trial ID from which to request the list of actors. Return: ActorInfo[] - List of actors configured in this trial. async getRemoteVersions() \u00b6 Method to get the versions from the remote Orchestrator. Parameters: None Return: {[key: string]: string} - The key of the object is the name of the component ( string ), and the value is the version ( string ). class Session \u00b6 Abstract class that manages aspects of a trial. Contains data and methods common to all sessions . getTrialId() \u00b6 Method to get the UUID of the trial managed by this session. Parameters: None Return: string - UUID of the trial. getTickId() \u00b6 Method to get the current tick id of the trial (i.e. time step). Parameters: None Return: number - The current tick id. isTrialOver() \u00b6 Method to inquire if the current trial has ended. Parameters: None Return: boolean - True if the trial has ended, false otherwise. sendingDone() \u00b6 Method to notify the Orchestrator that all data for the trial, from this session, has been sent. This can be called only when the session is ending. When starting the session (see ActorSession ), if the autoDoneSending parameter is True, this method should not be called, and if the parameter is False, it MUST be called to end the trial properly. Parameters: None Return: void class ActorSession extends Session \u00b6 start(autoDoneSending=True) \u00b6 Method to start the actor. This method should be called before any other method in the session. Parameters: autoDoneSending : boolean - Controls when to notify the Orchestrator that all data has been sent. If True, the session will automatically send the notification after receiving the last observation. If False, the user MUST call sendingDone to end the trial properly. Return: void async *eventLoop() \u00b6 Generator method to iterate over all events (observations, rewards, messages) as they are received. This will block and wait for an event. When this generator exits, the callback function (registered with registerActor ) should return to end the trial cleanly. The generator will exit for various reasons indicating the end of the trial, a loss of communication with the orchestrator, or if the generator is sent \"False\". Parameters: None Return: AsyncGenerator - A generator for the events that arrive. The RecvEvent instances received from this generator will not contain actions. When receiving an observation in the event, the this.doAction method is normally used to \"reply\" (if the event type is EventType.ACTIVE ). doAction(action) \u00b6 Method to send actions to the environment. Parameters: action : ActionT - An instance of the action space class specified in the corresponding section actorClasses:action:space of the spec file. If undefined , then no action space is sent (empty content) and the environment will receive a default initialized action space of the appropriate type. Return: void sendMessage(payload, to) \u00b6 Method to send a message related to the current time step (tick id). Parameters: payload : cogment.MessageBase - The message data to be sent. The class can be any protobuf class. It is the responsibility of the receiving actor to manage the class received. to : string[] - Targets of feedback. Each value could be the name of an actor in the trial, or the name of the environment (from this.envName ). Or it could represent a set of actors (with wildcards); A set of actors can be represented with the wildcard character \" * \" for all actors (of all classes), or \" actorClass.* \" for all actors of a specific class (the actorClass must match one of the classes listed in the trial parameters). Note that the wildcard does not include the environment. Return: void enum cogment.TrialState \u00b6 Enum representing the various states of trials. UNKNOWN: Should not be used. INITIALIZING: The trial is in the process of starting. PENDING: The trial is waiting for its final parameters, before running. RUNNING: The trial is running. TERMINATING: The trial is in the process of terminating (either a request to terminate has been received or the last observation has been received). ENDED: The trial has ended. Only a set number of ended trials will be kept (configured in the Orchestrator). class TrialInfo \u00b6 Class enclosing the details of a trial. trialId : string - The trial ID to which the details pertain. state : cogment.TrialState - The current state of the trial. envName : string - The name of the environment running the trial. tickId : number - The time step that the information relates to. Only provided from a call to getTrialInfo . duration : number - The time (in nanoseconds) that the trial has run. Only provided from a call to getTrialInfo . class RecvEvent \u00b6 Class representing a received event (for environments and actors). It can contain any combination of data according to the receiver needs, or even be empty, but it will always have a type. type : EventType - Type of event the enclosed data represents. observation : ObservationT - Observation data. This can only be received by actors. undefined if not present. actions : ActionT - Action data from actors. This can only be received by the environment. The list is empty if not present. rewards : Reward[] - Reward values and data. This can only be received by actors. The list is empty if not present. messages : MessageBase[] - Message data. The list is empty if not present. enum cogment.EventType \u00b6 Enum representing the type of an event. EventType.NONE : Empty event. This kind of event should never be received. EventType.ACTIVE : Normal event from an active trial. Most events will be of this type. EventType.ENDING : Events from a trial in the process of ending. For the environment, this means that these events contain the last actions from the actors, and the trial is awaiting a final observation. For the actors, this means that the trial is ending and no action can/need to be sent in response. Note that because of network timing, there may be ACTIVE events (e.g. rewards or messages) arriving after some ENDING events, but the trial is ending regardless. EventType.FINAL : Final event for the trial. This does not contain data. The event loop will exit after this event is delivered. This event can be ignored if nothing needs to be done before exiting the loop. type ObservationT \u00b6 Type containing the details of an actor's observation. This will be different depending on what the ActionSpace defined in your spec file contains type ActionT \u00b6 Type containing the details of an action from an actor. This will be different depending on what the ActionSpace defined in your spec file contains class MessageBase \u00b6 Base Class of all messages, this will contain different fields depending on what fields are in the specific message you are receiving (defined in proto files) type Reward \u00b6 type containing the details of a received reward. tickId : number - The tick id (time step) for which the reward should be applied. receiverName : string - Name of the receiver for the reward (the name of an actor, or wildcard string). value : float - Value of the reward (aggregated from the sources) sources : IRewardSource[] - List of sources that gave this reward interface IRewardSource \u00b6 senderName : string - Name of the reward sender; value : number - Value of the reward; confidence : number - Confidence of this reward; userData : google.protobuf.IAny - Extra data;","title":"Javascript/Typescript SDK"},{"location":"cogment/cogment-api-reference/javascript/#javascript-sdk","text":"","title":"Javascript SDK"},{"location":"cogment/cogment-api-reference/javascript/#installation","text":"The simplest way to install the Javascript SDK is to just install it using npm: npm install @cogment/cogment-js-sdk","title":"Installation"},{"location":"cogment/cogment-api-reference/javascript/#general-usage","text":"","title":"General usage"},{"location":"cogment/cogment-api-reference/javascript/#the-spec-file","text":"The spec cogment.yaml file (including imported files) defines the message types of each component of Cogment. For example, an actor class is defined by its required observation space and action space . These \"spaces\" are defined by using protobuf message types (from the imported files). Observations and actions will simply be instances of the appropriate type. Messages and feedback user data don't have a set type, they can be any type as long as the receiver can manage that type. The type is determined by the provided message from the originator. They will mostly arrive as an instance of cogment.MessageBase and have fields according to their definition in your proto files.","title":"The spec file"},{"location":"cogment/cogment-api-reference/javascript/#trial-parameters","text":"The trial parameters either come from the default parameters provided to the Orchestrator on startup, or they are dynamically generated by the pre-trial hooks (themselves provided to the Orchestrator on startup). Or both, since the default parameters are initially provided to the pre-trial hooks. The parameters are mostly indepedent of the spec file, except that the active actors listed in the parameters must have their actor class match an actor class defined in the spec file. Below, when we refer to the trial parameters, we mean the final parameters after any pre-trial hooks.","title":"Trial Parameters"},{"location":"cogment/cogment-api-reference/javascript/#compiling-the-spec-file","text":"In order to use the specification found in the spec file within Javascript scripts, it needs to be compiled into Javascript modules. This is done by a tool called \"cogment-js-sdk-generate\".","title":"Compiling the spec file"},{"location":"cogment/cogment-api-reference/javascript/#cogsettingsjs","text":"All API entry points require a cogment specification object. This specification object can be determined from the content of a project's spec file. As such, it should be generated using the cogment-js-sdk-generate tool npx cogment-js-sdk-generate config.yaml This will generate both a CogSettings.js file, as well as any required compiled protocol buffer files.","title":"CogSettings.js"},{"location":"cogment/cogment-api-reference/javascript/#imports","text":"Whether a script implements an actor or environment, it should import both the cogment module (generic Javascript SDK for Cogment) and the cogSettings module (project specific definitions created from the spec file). import { cogSettings } from './CogSettings'; import * as cogment from '@cogment/cogment-js-sdk'","title":"Imports"},{"location":"cogment/cogment-api-reference/javascript/#class-cogmentcontext","text":"Class to setup and run all the different aspects of trials.","title":"class cogment.Context"},{"location":"cogment/cogment-api-reference/javascript/#constructoruserid-cogsettings","text":"Parameters: userId : string - Identifier for the user of this context. cogSettings : cogment.CogSettings - Settings module associated with trials that will be run ( cogSettings namespace).","title":"constructor(userId, cogSettings)"},{"location":"cogment/cogment-api-reference/javascript/#getcontrollerendpoint","text":"Method to get a controller instance to manage trials (start, stop, inquire, etc). Parameters: endpoint : string - URL of the connection to the Orchestrator. Return: Controller - An instance of the Controller class used to manage trials.","title":"getController(endpoint)"},{"location":"cogment/cogment-api-reference/javascript/#async-jointrialtrialid-endpoint-actorname","text":"Method for an actor to asynchronously join an existing trial. This task will normally end after the user implementation has exited. Parameters: trialId : string - The UUID of the trial to join. endpoint : string - URL of the connection to the Orchestrator. actorName : string - Name of the actor joining the trial. Return: void","title":"async joinTrial(trialId, endpoint, actorName)"},{"location":"cogment/cogment-api-reference/javascript/#registeractorimpl-actorname-actorclass","text":"Method to register the asynchronous callback function that will run an actor for a trial. Parameters: impl : async function(ActorSession instance) - Callback function to be registered. actorName : string - Name for the actor implementation being run by the given callback function. actorClass : string - The actor class name that can be run by the given callback function. The possible names are specified in spec file under section actorClasses:name . If the list is empty, this implementation can run any actor class. Return: void","title":"registerActor(impl, actorName, actorClass)"},{"location":"cogment/cogment-api-reference/javascript/#class-controller","text":"Class containing data and methods to control and manage trials.","title":"class Controller"},{"location":"cogment/cogment-api-reference/javascript/#async-starttrialtrialconfig-undefined-trialidrequested-undefined","text":"Method to start a new trial. The parameters of the trial will be set by the pre-trial hooks (registered in cogment.Context ), and the hooks will receive the provided trial config. Parameters: trialConfig : cogment.MessageBase - Configuration for the trial. The type is specified in the spec file under the section trial:config_type . Can be undefined if no configuration is provided. This is provided to the first pre-trial hook. trialIdRequested : string - The trial identifier requested for the new trial. It must be unique among all active trials and a limited set of the latest ended trials (this list of trials can be retrieved with getTrialInfo or watchTrial ). If provided, the Orchestrator will try to use this trialId, otherwise, a UUID will be created. Return: string - The newly started trial ID.","title":"async startTrial(trialConfig = undefined, trialIdRequested = undefined)"},{"location":"cogment/cogment-api-reference/javascript/#terminate_trialtrialids-hard-false","text":"Method to request the end of a trial. Parameters: trialIds : string[] - The trial ID(s) to request to terminate. There must be at least one ID. hard : boolean - If true , the termination will be forced and not wait for any action or observation. If false , the trial will wait for the next tick, to end gracefully (i.e. wait for the next full set of actions and response observations). Return: void","title":"terminate_trial(trialIds, hard = false)"},{"location":"cogment/cogment-api-reference/javascript/#async-gettrialinfotrialids","text":"Method to get information about a trial. Parameters: trialIds : string[] - The trial ID(s) from which to request information. If no ID is provided, returns information about all trials. Note that ended trials may only appear for a short time in this list after they have ended. Return: TrialInfo[] - List of trial information, one per trial. Can be empty if no trial matches.","title":"async getTrialInfo(trialIds)"},{"location":"cogment/cogment-api-reference/javascript/#async-watchtrialstrialstatefilters","text":"Generator method to iterate, in real-time, through all trial states matching the filters. When called, it will first iterate over the current states matching the filters, for all trials. Afterwards, it will iterate in real-time over the matching states as they change. Parameters: trialStateFilters : cogment.TrialState[] - List of enum values from cogment.TrialState for which we are interested in receiving state changes. Return: generator(TrialInfo instance) - A generator for the state changes that arrive. The TrialInfo received here only contains the trial ID and the state.","title":"async watchTrials(trialStateFilters=[])"},{"location":"cogment/cogment-api-reference/javascript/#async-getactorstrialid","text":"Method to get the list of configured actors in a trial. Parameters: trialId : string - The trial ID from which to request the list of actors. Return: ActorInfo[] - List of actors configured in this trial.","title":"async getActors(trialId)"},{"location":"cogment/cogment-api-reference/javascript/#async-getremoteversions","text":"Method to get the versions from the remote Orchestrator. Parameters: None Return: {[key: string]: string} - The key of the object is the name of the component ( string ), and the value is the version ( string ).","title":"async getRemoteVersions()"},{"location":"cogment/cogment-api-reference/javascript/#class-session","text":"Abstract class that manages aspects of a trial. Contains data and methods common to all sessions .","title":"class Session"},{"location":"cogment/cogment-api-reference/javascript/#gettrialid","text":"Method to get the UUID of the trial managed by this session. Parameters: None Return: string - UUID of the trial.","title":"getTrialId()"},{"location":"cogment/cogment-api-reference/javascript/#gettickid","text":"Method to get the current tick id of the trial (i.e. time step). Parameters: None Return: number - The current tick id.","title":"getTickId()"},{"location":"cogment/cogment-api-reference/javascript/#istrialover","text":"Method to inquire if the current trial has ended. Parameters: None Return: boolean - True if the trial has ended, false otherwise.","title":"isTrialOver()"},{"location":"cogment/cogment-api-reference/javascript/#sendingdone","text":"Method to notify the Orchestrator that all data for the trial, from this session, has been sent. This can be called only when the session is ending. When starting the session (see ActorSession ), if the autoDoneSending parameter is True, this method should not be called, and if the parameter is False, it MUST be called to end the trial properly. Parameters: None Return: void","title":"sendingDone()"},{"location":"cogment/cogment-api-reference/javascript/#class-actorsession-extends-session","text":"","title":"class ActorSession extends Session"},{"location":"cogment/cogment-api-reference/javascript/#startautodonesendingtrue","text":"Method to start the actor. This method should be called before any other method in the session. Parameters: autoDoneSending : boolean - Controls when to notify the Orchestrator that all data has been sent. If True, the session will automatically send the notification after receiving the last observation. If False, the user MUST call sendingDone to end the trial properly. Return: void","title":"start(autoDoneSending=True)"},{"location":"cogment/cogment-api-reference/javascript/#async-eventloop","text":"Generator method to iterate over all events (observations, rewards, messages) as they are received. This will block and wait for an event. When this generator exits, the callback function (registered with registerActor ) should return to end the trial cleanly. The generator will exit for various reasons indicating the end of the trial, a loss of communication with the orchestrator, or if the generator is sent \"False\". Parameters: None Return: AsyncGenerator - A generator for the events that arrive. The RecvEvent instances received from this generator will not contain actions. When receiving an observation in the event, the this.doAction method is normally used to \"reply\" (if the event type is EventType.ACTIVE ).","title":"async *eventLoop()"},{"location":"cogment/cogment-api-reference/javascript/#doactionaction","text":"Method to send actions to the environment. Parameters: action : ActionT - An instance of the action space class specified in the corresponding section actorClasses:action:space of the spec file. If undefined , then no action space is sent (empty content) and the environment will receive a default initialized action space of the appropriate type. Return: void","title":"doAction(action)"},{"location":"cogment/cogment-api-reference/javascript/#sendmessagepayload-to","text":"Method to send a message related to the current time step (tick id). Parameters: payload : cogment.MessageBase - The message data to be sent. The class can be any protobuf class. It is the responsibility of the receiving actor to manage the class received. to : string[] - Targets of feedback. Each value could be the name of an actor in the trial, or the name of the environment (from this.envName ). Or it could represent a set of actors (with wildcards); A set of actors can be represented with the wildcard character \" * \" for all actors (of all classes), or \" actorClass.* \" for all actors of a specific class (the actorClass must match one of the classes listed in the trial parameters). Note that the wildcard does not include the environment. Return: void","title":"sendMessage(payload, to)"},{"location":"cogment/cogment-api-reference/javascript/#enum-cogmenttrialstate","text":"Enum representing the various states of trials. UNKNOWN: Should not be used. INITIALIZING: The trial is in the process of starting. PENDING: The trial is waiting for its final parameters, before running. RUNNING: The trial is running. TERMINATING: The trial is in the process of terminating (either a request to terminate has been received or the last observation has been received). ENDED: The trial has ended. Only a set number of ended trials will be kept (configured in the Orchestrator).","title":"enum cogment.TrialState"},{"location":"cogment/cogment-api-reference/javascript/#class-trialinfo","text":"Class enclosing the details of a trial. trialId : string - The trial ID to which the details pertain. state : cogment.TrialState - The current state of the trial. envName : string - The name of the environment running the trial. tickId : number - The time step that the information relates to. Only provided from a call to getTrialInfo . duration : number - The time (in nanoseconds) that the trial has run. Only provided from a call to getTrialInfo .","title":"class TrialInfo"},{"location":"cogment/cogment-api-reference/javascript/#class-recvevent","text":"Class representing a received event (for environments and actors). It can contain any combination of data according to the receiver needs, or even be empty, but it will always have a type. type : EventType - Type of event the enclosed data represents. observation : ObservationT - Observation data. This can only be received by actors. undefined if not present. actions : ActionT - Action data from actors. This can only be received by the environment. The list is empty if not present. rewards : Reward[] - Reward values and data. This can only be received by actors. The list is empty if not present. messages : MessageBase[] - Message data. The list is empty if not present.","title":"class RecvEvent"},{"location":"cogment/cogment-api-reference/javascript/#enum-cogmenteventtype","text":"Enum representing the type of an event. EventType.NONE : Empty event. This kind of event should never be received. EventType.ACTIVE : Normal event from an active trial. Most events will be of this type. EventType.ENDING : Events from a trial in the process of ending. For the environment, this means that these events contain the last actions from the actors, and the trial is awaiting a final observation. For the actors, this means that the trial is ending and no action can/need to be sent in response. Note that because of network timing, there may be ACTIVE events (e.g. rewards or messages) arriving after some ENDING events, but the trial is ending regardless. EventType.FINAL : Final event for the trial. This does not contain data. The event loop will exit after this event is delivered. This event can be ignored if nothing needs to be done before exiting the loop.","title":"enum cogment.EventType"},{"location":"cogment/cogment-api-reference/javascript/#type-observationt","text":"Type containing the details of an actor's observation. This will be different depending on what the ActionSpace defined in your spec file contains","title":"type ObservationT"},{"location":"cogment/cogment-api-reference/javascript/#type-actiont","text":"Type containing the details of an action from an actor. This will be different depending on what the ActionSpace defined in your spec file contains","title":"type ActionT"},{"location":"cogment/cogment-api-reference/javascript/#class-messagebase","text":"Base Class of all messages, this will contain different fields depending on what fields are in the specific message you are receiving (defined in proto files)","title":"class MessageBase"},{"location":"cogment/cogment-api-reference/javascript/#type-reward","text":"type containing the details of a received reward. tickId : number - The tick id (time step) for which the reward should be applied. receiverName : string - Name of the receiver for the reward (the name of an actor, or wildcard string). value : float - Value of the reward (aggregated from the sources) sources : IRewardSource[] - List of sources that gave this reward","title":"type Reward"},{"location":"cogment/cogment-api-reference/javascript/#interface-irewardsource","text":"senderName : string - Name of the reward sender; value : number - Value of the reward; confidence : number - Confidence of this reward; userData : google.protobuf.IAny - Extra data;","title":"interface IRewardSource"},{"location":"cogment/cogment-api-reference/parameters/","text":"Trial Parameters \u00b6 The trial parameters are a set of parameters that define the details of a trial. They are generated from the pre-trial hooks and/or from the default parameters provided to the Orchestrator. Parameter file \u00b6 The parameter file serves to initialize the Orchestrator default parameters. It is able to set all parameters for trials except the config protobuf messages (defined in the spec file). The config messages can only be set by the pre-trial hooks, but these configs are not relevant for simple projects without pre-trial hooks. The parameters in this file be used if no pre-trial hooks are defined. And if hooks are defined, they will be sent to the first hook as initial parameters to be updated by the hooks. The file uses the YAML configuration language. It consists of one YAML section called trial_params . Any other section will be ignored. The section defines the default trial parameters. The final parameters are set by the pre-trial hooks (if any are defined). These parameters are: max_steps : The maximum number of time steps (ticks) that the trial will run before terminating. If 0, the trial will not be auto terminated (the environment and a Controller can still terminate the trial). If not provided, a default of 0 will be used. max_inactivity : The number of seconds of inactivity after which a trial will be terminated. If 0, the trial will not be terminated because of inactivity. If not provided, a default of 30 seconds will be used. datalog : List of properties related to the data logger. If this section is not present, data logging is disabled. endpoint : The URL where the datalogger gRPC server resides. exclude_fields : List of fields to exclude from the data to send for logging environment : List of properties for the environment name : The name of the environment (defaults to \"env\" if not provided) endpoint : The URL where the environment gRPC server resides implementation : The name of the implementation to be used for this instance of the environment. This must match an implementation that is defined at the endpoint. If not defined, an arbitraary implementation will be chosen at runtime actors : List of actor properties. The number of actors may not be suited for all trials. name : The name of this actor (i.e. name of the specific instance of the actor class) actor_class : The name of the actor class. This is specific to a type of trial and must match values in the corresponding spec file. endpoint : The URL where the actor gRPC server resides. If this is cogment://client , the actor will connect as a client (the Orchestrator being the server in this case). implementation : The name of the implementation to be used for this actor instance. This must match an implementation that is defined at the endpoint. If not defined, an arbitraary implementation will be chosen at runtime. E.g.: trial_params: max_steps: 1000 max_inactivity: 5 # seconds datalog: endpoint: grpc://logserver:9000 exclude_fields: [messages, actions] environment: name: Arena endpoint: grpc://env:9000 implementation: simple actors: - name: Alice actor_class: BigPlayer endpoint: grpc://bp1:9000 implementation: - name: Bob actor_class: BigPlayer endpoint: grpc://bp2:9000 implementation: Test - name: Carol actor_class: SmallPlayer endpoint: grpc://sp:9000 implementation: DQN_Hotel3 - name: Dave actor_class: SmallPlayer endpoint: grpc://sp:9000 implementation: DNN_Karma3.1.17 - name: Olivia actor_class: Referee endpoint: cogment://client implementation: Standard Parameters and pre-trial hooks \u00b6 Pre-trial hooks are gRPC services that will be called to set up the parameters for a new trial. Multiple hooks can be defined and they will all be called in order, in a pipeline fashion (i.e. the output of one becomes the input of the next). The first hook service to be called will receive the default parameters, in addition with the config given to the start_trial function call. The output of the last hook is used to start the new trial. The response of the last hook will be waited on before the trial starts. The hooks will be called to update or generate all the parameter data (presented here) in addition to the configurations for the environment and the actors (if needed). Pre-trial hooks are defined on the command line (or an environment variable) when starting the Orchestrator.","title":"Parameters"},{"location":"cogment/cogment-api-reference/parameters/#trial-parameters","text":"The trial parameters are a set of parameters that define the details of a trial. They are generated from the pre-trial hooks and/or from the default parameters provided to the Orchestrator.","title":"Trial Parameters"},{"location":"cogment/cogment-api-reference/parameters/#parameter-file","text":"The parameter file serves to initialize the Orchestrator default parameters. It is able to set all parameters for trials except the config protobuf messages (defined in the spec file). The config messages can only be set by the pre-trial hooks, but these configs are not relevant for simple projects without pre-trial hooks. The parameters in this file be used if no pre-trial hooks are defined. And if hooks are defined, they will be sent to the first hook as initial parameters to be updated by the hooks. The file uses the YAML configuration language. It consists of one YAML section called trial_params . Any other section will be ignored. The section defines the default trial parameters. The final parameters are set by the pre-trial hooks (if any are defined). These parameters are: max_steps : The maximum number of time steps (ticks) that the trial will run before terminating. If 0, the trial will not be auto terminated (the environment and a Controller can still terminate the trial). If not provided, a default of 0 will be used. max_inactivity : The number of seconds of inactivity after which a trial will be terminated. If 0, the trial will not be terminated because of inactivity. If not provided, a default of 30 seconds will be used. datalog : List of properties related to the data logger. If this section is not present, data logging is disabled. endpoint : The URL where the datalogger gRPC server resides. exclude_fields : List of fields to exclude from the data to send for logging environment : List of properties for the environment name : The name of the environment (defaults to \"env\" if not provided) endpoint : The URL where the environment gRPC server resides implementation : The name of the implementation to be used for this instance of the environment. This must match an implementation that is defined at the endpoint. If not defined, an arbitraary implementation will be chosen at runtime actors : List of actor properties. The number of actors may not be suited for all trials. name : The name of this actor (i.e. name of the specific instance of the actor class) actor_class : The name of the actor class. This is specific to a type of trial and must match values in the corresponding spec file. endpoint : The URL where the actor gRPC server resides. If this is cogment://client , the actor will connect as a client (the Orchestrator being the server in this case). implementation : The name of the implementation to be used for this actor instance. This must match an implementation that is defined at the endpoint. If not defined, an arbitraary implementation will be chosen at runtime. E.g.: trial_params: max_steps: 1000 max_inactivity: 5 # seconds datalog: endpoint: grpc://logserver:9000 exclude_fields: [messages, actions] environment: name: Arena endpoint: grpc://env:9000 implementation: simple actors: - name: Alice actor_class: BigPlayer endpoint: grpc://bp1:9000 implementation: - name: Bob actor_class: BigPlayer endpoint: grpc://bp2:9000 implementation: Test - name: Carol actor_class: SmallPlayer endpoint: grpc://sp:9000 implementation: DQN_Hotel3 - name: Dave actor_class: SmallPlayer endpoint: grpc://sp:9000 implementation: DNN_Karma3.1.17 - name: Olivia actor_class: Referee endpoint: cogment://client implementation: Standard","title":"Parameter file"},{"location":"cogment/cogment-api-reference/parameters/#parameters-and-pre-trial-hooks","text":"Pre-trial hooks are gRPC services that will be called to set up the parameters for a new trial. Multiple hooks can be defined and they will all be called in order, in a pipeline fashion (i.e. the output of one becomes the input of the next). The first hook service to be called will receive the default parameters, in addition with the config given to the start_trial function call. The output of the last hook is used to start the new trial. The response of the last hook will be waited on before the trial starts. The hooks will be called to update or generate all the parameter data (presented here) in addition to the configurations for the environment and the actors (if needed). Pre-trial hooks are defined on the command line (or an environment variable) when starting the Orchestrator.","title":"Parameters and pre-trial hooks"},{"location":"cogment/cogment-api-reference/python/","text":"Python SDK \u00b6 The Python SDK is designed to run concurently and asynchronously using the Python asyncio library. As such, it should be run in an asyncio.Task . E.g. asyncio.run(MyMainFunction()) Installation \u00b6 The simplest way to install the python SDK is to just install it using pip: pip install cogment . And to install the generator (for cog_settings.py ) it is done similarly with pip: pip install cogment[generate] . Note that the generator is not installed by default when installing the Cogment SDK, it must be explcitly installed. The basic requirement is Python 3.7. General usage \u00b6 Trial Specifications \u00b6 The specifications of a trial type are contained in a spec file and the imported files defined in the spec. This file is typically named cogment.yaml . For example, an actor class is defined by its required observation space and action space . These \"spaces\" are defined by using protobuf message types (from the imported files). Observations and actions will simply be instances of the appropriate type. Messages and feedback user data don't have a set type, they can be any type of protobuf message as long as the receiver can manage that type (i.e. the object received is an instance of google.protobuf.Any and the contained type should be checked against known types before handling). The type is determined by the provided message from the originator. Trial Parameters \u00b6 The trial parameters either come from the default parameters provided to the Orchestrator on startup, or they are dynamically generated/updated by the pre-trial hooks (which are provided to the Orchestrator on startup). Or both, since any default parameters are initially provided to the first pre-trial hook. The parameters are mostly indepedent of the spec file (cogment.yaml), except that the active actors listed in the parameters must have their actor class match an actor class defined in the spec file. Below, when we refer to the trial parameters, we mean the final parameters after any pre-trial hooks. Note that environment config and actor config can only be provided by pre-trial hooks. Compiling the spec file into cog_settings.py \u00b6 In order to use the specifications within python scripts, the spec file needs to be compiled into python modules. This is done by the Python SDK generator (see [#installation]). The generator is used this way: $ python3 -m cogment.generate --spec cogment.yaml --output ./cog_settings.py This will create a cog_settings.py module in the current directory ( --output ./ ). The generator will also compile the imported *.proto files into python modules that will be saved in the same location as the specified output file ( cog_settings.py ) and they will be named according to their proto names ( *_pb2.py ). The cog_settings.py Python module is required by all API entry points. Top-level import \u00b6 The main module of the Cogment SDK is cogment . But all cogment scripts need to start with a cogment.Context , which also requires the generated module cog_settings (project specific definitions created from the spec file). If one needs to create a cogment.LogParams from scratch, the cog_settings module is also required. import cog_settings import cogment class cogment.Context \u00b6 Class to setup and run all the different aspects of trials. __init__(self, user_id, cog_settings, prometheus_registry=prometheus_client.core.REGISTRY) \u00b6 Parameters: user_id : str - Identifier for the user of this context. cog_settings : module - Settings module associated with trials that will be run ( cog_settings namespace). prometheus_registry : prometheus_client.core.CollectorRegistry instance - Prometheus registry that'll be used by the Cogment metrics in this context. Can be set to None to completely deactivate them. The default value is Prometheus' default global registry. async serve_all_registered(self, served_endpoint, prometheus_port = 8000) \u00b6 Method to start and run the communication server for the registered components (environment, actor, prehook, datalog). This coroutine will end when all activity has stopped. Parameters: served_endpoint : ServedEndpoint instance - Details of the connection for the served components. prometheus_port : int - TCP/IP port number for Prometheus. Can be set to None to deactivate the Prometheus metrics server. Return: None get_controller(self, endpoint) \u00b6 Method to get a controller instance to manage trials (start, stop, inquire, etc). Parameters: endpoint : Endpoint instance - Details of the connection to the Orchestrator. Return: Controller instance - An instance of the Controller class used to manage trials. async join_trial(self, trial_id, endpoint, impl_name=None, actor_name=None, actor_class=None) \u00b6 Method for an actor to asynchronously join an existing trial. This task will normally end after the user implementation has exited. Parameters: trial_id : str - The UUID of the trial to join. endpoint : Endpoint instance - Details of the connection to the Orchestrator. impl_name : str - deprecated actor_name : str - Name of the actor joining the trial. If None , actor_class will be used to find the actor to join. The name must match an active actor in the trial as found in the trial parameters in the sections trial_params:actors:name with trial_params:actors:endpoint set to \"cogment://client\". actor_class : str - The class of actor to join the trial. If None , actor_name will be used to find the actor to join. The class must match an active actor in the trial as found in the trial parameters in the sections trial_params:actors:actor_class with trial_params:actors:endpoint set to \"cogment://client\". Return: None register_environment(self, impl, impl_name = \"default\") \u00b6 Method to register the asynchronous callback function that will run an environment for a trial. Parameters: impl : async function(EnvironmentSession instance) - Callback function to be registered. impl_name : str - Name for the environment being run by the given callback function. Return: None register_actor(self, impl, impl_name, actor_classes=[]) \u00b6 Method to register the asynchronous callback function that will run an actor for a trial. Parameters: impl : async func(ActorSession instance) - Callback function to be registered. impl_name : str - Name for the actor implementation being run by the given callback function. actor_classes : list[str] - The actor class name(s) that can be run by the given callback function. The possible names are specified in the spec file under section actor_classes:name . If the list is empty, this implementation can run any actor class. Return: None register_pre_trial_hook(self, impl) \u00b6 Method to register an asynchronous callback function that will be called before a trial is started. Only one such function can be registered. But there may be multiple hook services for an Orchestrator. They are provided to the Orchestrator at startup. All hooks registered with the Orchestrator will be called in a pipeline fashion before each new trial. Parameters: impl : async func(PrehookSession instance) - Callback function to be registered. The PrehookSession instance member data should be changed as needed for the new trial before returning from this function. Return: None register_datalog(self, impl) \u00b6 Method to register an asynchronous callback function that will be called for each trial to serve log requests. Only one such function can be registered. This service is addressed in the trial parameters in the datalog section. Parameters: impl : async func(DatalogSession instance) - Callback function to be registered Return: None class Controller \u00b6 Class containing data and methods to control and manage trials. async start_trial(self, trial_config=None, trial_id_requested=None) \u00b6 Method to start a new trial. The parameters of the trial will be set by the pre-trial hooks (registered in cogment.Context ), and the hooks will receive the provided trial config. Parameters: trial_config : protobuf class instance - Configuration for the trial. The type is specified in the spec file under the section trial:config_type . Can be None if no configuration is provided. This is provided to the first pre-trial hook. trial_id_requested : str - The trial identifier requested for the new trial. It must be unique among all active trials and a limited set of the latest ended trials (this list of trials can be retrieved with get_trial_info or watch_trial ). If provided, the Orchestrator will try to use this trial_id, otherwise, a UUID will be created. Return: str - The newly started trial ID. An empty string if the trial was not started due to a non-unique ID. terminate_trial(self, trial_ids, hard=False) \u00b6 Method to request the end of a trial. Parameters: trial_ids : list[str] - The trial ID(s) to request to terminate. There must be at least one ID. hard : bool - If True , the termination will be forced and not wait for any action or observation. If False , the trial will wait for the next tick, to end gracefully (i.e. wait for the next full set of actions and response observations). Return: None async get_trial_info(self, trial_ids) \u00b6 Method to get information about a trial. Parameters: trial_ids : list[str] - The trial ID(s) from which to request information. If no ID is provided, returns information about all trials. Note that ended trials may only appear for a short time in this list after they have ended. Return: list[TrialInfo instance] - List of trial information, one per trial. Can be empty if no trial matches. async watch_trials(self, trial_state_filters=[]) \u00b6 Generator method to iterate, in real-time, through all trial states matching the filters. When called, it will first iterate over the current states matching the filters, for all trials. Afterwards, it will iterate in real-time over the matching states as they change. Parameters: trial_state_filters : list[cogment.TrialState] - List of enum values from cogment.TrialState for which we are interested in receiving state changes. Return: generator(TrialInfo instance) - A generator for the state changes that arrive. The TrialInfo received here only contains the trial ID and the state. async get_actors(self, trial_id) \u00b6 Method to get the list of configured actors in a trial. Parameters: trial_id : str - The trial ID from which to request the list of actors. Return: list[ActorInfo instance] - List of actors configured in this trial. async get_remote_versions(self) \u00b6 Method to get the versions from the remote Orchestrator. Parameters: None Return: dict - The key of the dictionary is the name of the component ( str ), and the value is the version ( str ). class Session \u00b6 Abstract class that manages aspects of a trial. Contains data and methods common to all sessions . get_trial_id(self) \u00b6 Method to get the UUID of the trial managed by this session. Parameters: None Return: str - UUID of the trial. get_tick_id(self) \u00b6 Method to get the current tick id of the trial (i.e. time step). Parameters: None Return: int - The current tick id. is_trial_over(self) \u00b6 Method to inquire if the current trial has ended. Parameters: None Return: bool - True if the trial has ended, false otherwise. sending_done(self) \u00b6 Method to notify the Orchestrator that all data for the trial, from this session, has been sent. This can be called only when the session is ending. When starting the session (see EnvironmentSession and ActorSession ), if the auto_done_sending parameter is True, this method should not be called, and if the parameter is False, it MUST be called to end the trial properly. Parameters: None Return: None add_reward(self, value, confidence, to, tick_id=-1, user_data=None) \u00b6 Method to send a reward to one or more actors. Parameters: value : float - Value of the reward. This will be aggregated with other rewards for the same target actor. confidence : float - Weight of this reward value in determining the final aggregated reward. Should be > 0. to : list[str] - Target(s) of reward. A list value could be the name of an actor in the trial. Or it could represent a set of actors; A set of actors can be represented with the wildcard character \" * \" for all actors (of all classes), or \" actor_class.* \" for all actors of a specific class (the actor_class is the name of the class as specified in the spec file). tick_id : int - The tick id (time step) for which the reward should be applied. If \"-1\", then the reward applies to the current time step. user_data : protobuf class instance - Extra user data to be sent with the reward. The class can be any protobuf class. It is the responsibility of the receiving actor to manage the class received (packed in a google.protobuf.Any ). Return: None class EnvironmentSession(Session) \u00b6 Abstract class based on Session , containing session data and methods necessary to run an environment for a trial. An instance of this class is passed as an argument to the environment callback function registered with cogment.Context.register_environment . impl_name : str - Name of the implementation running this environment. config : protobuf class instance - User configuration received for this environment instance. Can be None if no configuration was provided. The type of the protobuf class is specified in the spec file in the section environment:config_type . name : str - Name of the environment this instance represents. start(self, observations = None, auto_done_sending=True) \u00b6 Method to report that the environment is starting to run the trial. The method should be called before any other method in the session. Parameters: observations : list[tuple(str, protobuf class instance)] - The initial observations from which the environment is starting the trial. This is the same as the parameter for self.produce_observations . If not provided, then the first observation sent with produce_observation will be used to initiate the trial (note that no actions will be received until the first observation is sent). auto_done_sending : bool - Controls when to notify the Orchestrator that all data has been sent. If True, the session will automatically send the notification after end is called. If False, the user MUST call sending_done (after end ) to end the trial properly. Return: None async event_loop(self) \u00b6 Generator method to iterate over all events (actions, messages) as they are received. This will block and wait for an event. When this generator exits, the callback function (registered with register_environment ) should return to end the trial cleanly. The generator will exit for various reasons indicating the termination of the trial, a loss of communication with the orchestrator, or if the generator is sent \"False\" (in which case the callback function does not necessarily need to exit). Parameters: None Return: generator(RecvEvent instance) - A generator for the events that arrive. The RecvEvent instances received from this generator will only contain actions or messages; no observations nor rewards. When receiving actions in the event, the self.produce_observation method is normally used to \"reply\" (or self.end to end the trial). produce_observations(self, observations) \u00b6 Method to send observations to actors. If called after receiving an event of type EventType.ENDING , the observation will be consired the final observation (equivalent to calling end() ). Parameters: observations : list[tuple(str, protobuf class instance)] - The observations to send to actors. The string in the tuple is the name of the destination actor (or \"*\" for all actors). The name of the actors can be found in trial parameters under trial_params:actors:name . The protobuf class is the Observation Space for that actor, found in the spec file in the corresponding section actor_classes:observation:space . Return: None end(self, final_observations) \u00b6 Method to report the end of the environment. This will effectively end the trial. Message events can still arrive after this call. Parameters: final_observations : list[tuple(str, protobuf class instance)] - The final observations to send to the actors. This is the same as the parameter for self.produce_observations . Return: None get_active_actors(self) \u00b6 Method to get the list of active actors in the trial. Parameters: None Return: list[ActorInfo instance] - List of active actors and classes involved in this trial. send_message(self, payload, to) \u00b6 Method to send a message related to the current time step (tick id). Parameters: payload : protobuf class instance - The message data to be sent. The class can be any protobuf class. It is the responsibility of the receiving environment to manage the class received (packed in a google.protobuf.Any ). to : list[str] - Targets of feedback. Each value could be the name of an actor in the trial. Or it could represent a set of actors (with wildcards); A set of actors can be represented with the wildcard character \" * \" for all actors (of all classes), or \" actor_class.* \" for all actors of a specific class (the actor_class must match one of the classes listed in the trial parameters). Note that the wildcard does not include the environment. Return: None class ActorSession(Session) \u00b6 Abstract class based on Session , containing session/trial data and methods necessary to run an actor for a trial. An instance of this class is passed as argument to the actor callback function registered with cogment.Context.register_actor . class_name : str - Name of the class of actor this instance represents. Specified in the spec file as actor_classes:name . impl_name : str - Name of the implementation of the actor represented by this instance. config : protobuf class instance - User configuration received for this actor instance. Can be None is no configuration was provided. The type of the protobuf class is specified in the spec file in the section actor_classes:config_type . name : str - Name of the actor this instance represents. env_name : str - Name of the environment running the trial this actor is participating in (used to send messages to the environment). start(self, auto_done_sending=True) \u00b6 Method to start the actor. This method should be called before any other method in the session. Parameters: auto_done_sending : bool - Controls when to notify the Orchestrator that all data has been sent. If True, the session will automatically send the notification after receiving the last observation. If False, the user MUST call sending_done to end the trial properly. Return: None async event_loop(self) \u00b6 Generator method to iterate over all events (observations, rewards, messages) as they are received. This will block and wait for an event. When this generator exits, the callback function (registered with register_actor ) should return to end the trial cleanly. The generator will exit for various reasons indicating the end of the trial, a loss of communication with the orchestrator, or if the generator is sent \"False\". Parameters: None Return: generator(RecvEvent instance) - A generator for the events that arrive. The RecvEvent instances received from this generator will not contain actions. When receiving an observation in the event, the self.do_action method is normally used to \"reply\" (if the event type is EventType.ACTIVE ). do_action(self, action) \u00b6 Method to send actions to the environment. Parameters: action : protobuf class instance - An instance of the action space class specified in the corresponding section actor_classes:action:space of the spec file. If None , then no action space is sent (empty content) and the environment will receive a default initialized action space of the appropriate type. Return: None send_message(self, payload, to) \u00b6 Method to send a message related to the current time step (tick id). Parameters: payload : protobuf class instance - The message data to be sent. The class can be any protobuf class. It is the responsibility of the receiving actor to manage the class received (packed in a google.protobuf.Any ). to : list[str] - Targets of feedback. Each value could be the name of an actor in the trial, or the name of the environment (from self.env_name ). Or it could represent a set of actors (with wildcards); A set of actors can be represented with the wildcard character \" * \" for all actors (of all classes), or \" actor_class.* \" for all actors of a specific class (the actor_class must match one of the classes listed in the trial parameters). Note that the wildcard does not include the environment. Return: None class PrehookSession \u00b6 Abstract class containing trial configuration data to define the specifics of a trial. An instance of this class is passed as argument to the pre-trial hook callback function registered with cogment.Context.register_pre_trial_hook . The first pre-trial hook to be called will receive the default parameters set in the Orchestrator, the following hooks will receive the parameters set by the preceding hooks. trial_config : protobuf class instance - Configuration for the new trial. The type is specified in the spec file under the section trial:config_type . The first pre-trial hook receives the config that came from the Controller.start_trial() function. If None , no config will be sent to the next pre-trial hook. trial_max_steps : int - The maximum number of time steps (ticks) that the trial will run before terminating. If 0 (or None ), the trial will not be auto terminated (the environment and a Controller can still terminate the trial). trial_max_inactivity : int - The number of seconds of inactivity after which a trial will be terminated. If 0 (or None ), the trial will not be terminated because of inactivity. datalog_endpoint : str - The URL to connect to the data logger. The protocol must be \"grpc\". E.g. \"grpc://mydb:9000\". If None , no datalog service will be connected. datalog_exclude : list[str] - List of fields to exclude from the data to send for logging. environment_config : protobuf class instance - Configuration for the environment in the new trial. This configuration will be sent to the environment on start. The type is specified in the spec file under the section environment:config_type . If None , no config will be sent to the environment. environment_endpoint : str - The URL to connect to the environment. The protocol must be \"grpc\". E.g. \"grpc://myenv:9000\" environment_name : str - The name of the environment. environment_implementation : str - The name of the implementation to run the environment. actors : list[dict] - Each item (dictionary) of the list represents an actor. Each actor dictionary contains these key-value pairs: \"name\" : str - Name of the actor \"actor_class\" : str - The actor class for the actor. This is specific to a type of trial and must match values in the spec file under section actor_classes:name . \"endpoint\" : str - The URL to connect to the actor. If, instead of a gRPC URL, the value is \"cogment://client\", then this actor will connect in (rather than be connected to), and the actor will need to provide the gRPC URL to connect to the orchestrator. \"implementation\" : str - The name of the implementation to run this actor \"config\" : protobuf class instance - The configuration data for the actor. The type is specified in the spec file under the section actor_classes:config_type for the corresponding actor. If None , no config will be sent to the actor. get_trial_id(self) \u00b6 Method to retrieve the ID of the trial. Parameters: None Return: str - ID of the trial. get_user_id(self) \u00b6 Method to retrieve the identifier of the user that started the trial. Parameters: None Return: str - Identifier of the user that started the trial. validate(self) \u00b6 Method to validate that the data is valid. This is a superficial check; even if the data validates successfully, there can still be problems with the data. This method should be called if changes have been made to the data members of the class. Exceptions are raised on error. Parameters: None Return: None class DatalogSession \u00b6 Abstract class containing session data and methods necessary to manage the logging of trial run data. An instance of this class is passed as an argument to the datalog callback function registered with cogment.Context.register_datalog . trial_id : str - UUID of the trial managed by this instance. user_id : str - Identifier of the user that started the trial. trial_params : cogment.LogParam instance - Parameters of the trial. start(self) \u00b6 Method to start receiving samples. Parameters: None Return: None get_all_samples(self) \u00b6 Generator method to iterate over all samples as they are received (waiting for each in turn). Parameters: None Return: generator(cogment.LogSample instance) - A generator for the samples received. class cogment.Endpoint \u00b6 Class enclosing the details for connecting to an Orchestrator. url : str - The URL where to connect to the Orchestrator. private_key : str - To use TLS for the connection, this must be set to the PEM-encoded private key. root_certificates : str - If using TLS for the connection (i.e. the private_key is not None ), this can be set to the PEM-encoded root certificates. If not set and using TLS for the connection, the root certificates will be fetched from the system default location. certificate_chain : str - If using TLS for the connection, this can be set to the PEM-encoded certificate chain. __init__(self, url) \u00b6 Parameters: url : str - The URL where to connect to the Orchestrator. class cogment.ServedEndpoint \u00b6 Class enclosing the details for connection from an Orchestrator. port : str - The TCP/IP port where the service will be awaiting the Orchestrator connection. private_key_certificate_chain_pairs : list[tupple(str, str)] - To use TLS for incoming connections, this must be set to a list of tuples of the form (PEM-encoded private key, PEM-encoded certificate chain). root_certificates : str - If using TLS for the connection (i.e. private_key_certificate_chain_pairs is not None ), this should be set to PEM-encoded Orchestrator root certificates that the server will use to verify Orchestrator authentication. __init__(self, port) \u00b6 Parameters: port : int - The TCP/IP port where the service will be awaiting the Orchestrator connection. class cogment.TrialState(enum.Enum) \u00b6 Enum representing the various states of trials. UNKNOWN: Should not be used. INITIALIZING: The trial is in the process of starting. PENDING: The trial is waiting for its final parameters, before running. RUNNING: The trial is running. TERMINATING: The trial is in the process of terminating (either a request to terminate has been received or the last observation has been received). ENDED: The trial has ended. Only a set number of ended trials will be kept (configured in the Orchestrator). class TrialInfo \u00b6 Class enclosing the details of a trial. trial_id : str - The trial ID to which the details pertain. state : cogment.TrialState - The current state of the trial. env_name : str - The name of the environment running the trial. tick_id : int - The time step that the information relates to. Only provided from a call to get_trial_info . duration : int - The time (in nanoseconds) that the trial has run. Only provided from a call to get_trial_info . class ActorInfo \u00b6 Class enclosing the details of an actor. actor_name : str - The name of the actor. actor_class_name : str - The name of the actor's class (as defined in the spec file). class RecvEvent \u00b6 Class representing a received event (for environments and actors). It can contain any combination of data according to the receiver needs, or even be empty, but it will always have a type. type : Enum EventType - Type of event the enclosed data represents. observation : RecvObservation instance - Observation data. This can only be received by actors. None if not present. actions : list[RecvAction instance] - Action data from actors. This can only be received by the environment. The list is empty if not present. rewards : list[RecvReward instance] - Reward values and data. This can only be received by actors. The list is empty if not present. messages : *list[RecvMessage instance] - Message data. The list is empty if not present. class cogment.EventType(enum.Enum) \u00b6 Enum representing the type of an event. EventType.NONE : Empty event. This kind of event should never be received. EventType.ACTIVE : Normal event from an active trial. Most events will be of this type. EventType.ENDING : Events from a trial in the process of ending. For the environment, this means that these events contain the last actions from the actors, and the trial is awaiting a final observation. For the actors, this means that the trial is ending and no action can/need to be sent in response. Note that because of network timing, there may be ACTIVE events (e.g. rewards or messages) arriving after some ENDING events, but the trial is ending regardless. EventType.FINAL : Final event for the trial. This does not contain data. The event loop will exit after this event is delivered. This event can be ignored if nothing needs to be done before exiting the loop. class RecvObservation \u00b6 Class containing the details of an observation for an actor. tick_id : int - The time step that the observation relates to. timestamp : int - Unix style Epoch timestamp in nanoseconds (time since 00:00:00 UTC Jan 1, 1970). observation : protobuf class instance - Observation received from the environment. The class of the observation is defined as observation space for the actor class. This is specified in section actor_classes:observation:space in the spec file for the appropriate/receiving actor class. class RecvAction \u00b6 Class containing the details of an action from an actor. tick_id : int - The time step that the action relates to. timestamp : int - Unix style Epoch timestamp in nanoseconds (time since 00:00:00 UTC Jan 1, 1970). actor_index : int - Index of the actor in the list of all trial actors (returned by Session.get_active_actors ). action : protobuf class instance - Action from the actor which has index actor_index in the trial. The class of the action is defined as action space for the specific actor in the section actor_classes:action:space in the spec file. class RecvMessage \u00b6 Class containing a message. tick_id : int - The time step that the message relates to. receiver_name : str - Name of the receiver for the message (the name of an actor, or wildcard string). sender_name : str - Name of the sender of the message (the name of an actor, or the environment). payload : google.protobuf.Any instance - Data for a received message. The class enclosed in google.protobuf.Any is of the type set by the sender; It is the responsibility of the receiver to manage the data received (i.e. determine the type and unpack the data). class RecvReward \u00b6 Class containing the details of a received reward. tick_id : int - The tick id (time step) for which the reward should be applied. receiver_name : str - Name of the receiver for the reward (the name of an actor, or wildcard string). value : float - Value of the reward (aggregated from the sources) get_nb_sources(self) \u00b6 Return the number of source rewards this reward is based upon. Parameters: None Return: int - Number of sources. all_sources(self) \u00b6 Generator method to iterate over all sources making up this reward. Parameters: None Return: generator(RecvRewardSource instance) - A generator for the sources in the reward (simple rewards that make up this final/aggregate reward). class RecvRewardSource \u00b6 Class containing the details of a received single source reward. value : float - Value of the reward from the sender. confidence : float - Confidence level of this reward value. sender_name : str - Name of the sender of this reward (the name of an actor, or the environment). user_data : google.protobuf.Any instance - Data for a user-specific reward format. Can be None if no specific data was provided. The class enclosed in google.protobuf.Any is of the type set by the sender; it is the responsibility of the receiver to manage the data received (i.e. determine the type and unpack the data). class cogment.LogParams \u00b6 Class containing the paramaters of the trial. max_steps : int - The maximum number of steps/ticks that the trial should run. After this number of steps/ticks, an end request will be sent to the environment. max_inactivity : int - The maximum amount of time (in seconds) that the trial should be without activity before it is forcefully terminated. \"Activity\" is defined as a message received by the Orchestrator from a user component. nb_actors : int - The number of actors participating in the trial. datalog : dict - The datalog related parameters. The dictionary contains these key-value pairs: \"endpoint\" : str - The URL to connect to the datalog service. \"exclude\" : list(str) - Fields to exclude from the samples sent to the datalog service. environment : dict - The environment related parameters. The dictionary contains these key-value pairs: \"name\" : str - Name of the environment \"endpoint\" : str - The URL to connect to the environment. \"implementation\" : str - The name of the implementation to run the environment __init__(self, cog_settings) \u00b6 Parameter: cog_settings : module - Settings module associated with trials that will be run ( cog_settings namespace). get_serialization_type(self) \u00b6 Return the type of serial data produced by serialize and accepted by deserialize . The type represents an ID dependent on TrialParams defined in the low level gRPC API. Parameters: None Return: int - The type of the serialization string data. This is the type of string that is returned by serialize , and the only type accepted by deserialize ; it is undefined behavior to try to deserialize the wrong type of data. This value is strictly larger than 1. serialize(self) \u00b6 Return a binary string equivalent of the parameters. Parameters: None Return: str - Serialized parameters. deserialize(self, raw_string) \u00b6 Takes a serialized parameter string and sets the LogParams instance. Parameter: raw_string : str - Binary string representing a serialized LogParam of the same type. get_trial_config(self) \u00b6 Returns the trial config. Parameters: None Return: protobuf class instance - Configuration for the trial. The type is specified in the spec file under the section trial:config_type . get_environment_config(self) \u00b6 Returns the environment config. Parameters: None Return: protobuf class instance - Configuration for the environment. The type is specified in the spec file under the section environment:config_type . get_actor_index(self, actor_name) \u00b6 Returns the index of the given actor, or None if the actor is not in the trial. Parameters: actor_name : str - Name of the actor to look for in the trial parameters. Return: int - Index of actor if found. None if not found. This index is constant in the trial and relates to the complete list of actors provided by cogment (e.g. Controller.get_actors() ). get_actor_name(self, actor_index) \u00b6 Returns the name of an actor in the trial. Parameters: actor_index : int - Index of the actor to retrieve. This number is constant in the trial and relates to the complete list of actors provided by cogment (e.g. Controller.get_actors() ). The value must be between 0 and self.nb_actors (exclusively). Return: str - Name of the actor in the trial parameters. get_actor(self, actor_index) \u00b6 Returns information about a particular actor in the trial. Parameters: actor_index : int - Index of the actor to retrieve. This number is constant in the trial and relates to the complete list of actors provided by cogment (e.g. Controller.get_actors() ). The value must be between 0 and self.nb_actors (exclusively). Return: dict - Dictionary containing the details of the actor parameters. The dictionary contains these key-value pairs: \"name\" : str - Name of the actor. \"actor_class\" : str - The actor class for the actor. This is specific to a type of trial and must match values in the spec file under section actor_classes:name . \"endpoint\" : str - The URL to connect to the service actor, or \"cogment://client\" for client actors that will connect in. \"implementation\" : str - The name of the implementation to run the actor. \"config\" : protobuf class instance - The configuration data for the actor. The type is specified in the spec file under the section actor_classes:config_type for the specific actor class of the actor. class cogment.LogSample \u00b6 Class containing a datalog sample. A sample starts and ends with the arrival of new observations from the environment. The last sample will end after all components have acknowledged the end of the trial (the state of that sample will then be TrialState.ENDED ). Note that some of the data may not be available ( None ) if it was excluded from the sample (see datalog parameters LogParams.datalog[\"exclude\"] ). tick_id : int - The time step that the sample data relates to. state : cogment.TrialState - The state of the trial at the end of the sample period. timestamp : int - Unix style Epoch timestamp in nanoseconds (time since 00:00:00 UTC Jan 1, 1970) at the beginning of the sample period. events : str - Description of special events that happened during the timeframe of the sample. __init__(self, params) \u00b6 Parameter: params : LogParams instance - The parameters of the trial. get_serialization_type(self) \u00b6 Returns the type of serial data produced by serialize and accepted by deserialize . The type represents an ID dependent on DatalogSample defined in the low level gRPC API. Parameters: None Return: int - The type of the serialization string data. This is the type of string that is returned by serialize , and the only type accepted by deserialize ; it is undefined behavior to try to deserialize the wrong type of data. This value is strictly larger than 1. serialize(self) \u00b6 Returns a binary string equivalent of the sample. Parameters: None Return: str - Serialized sample. deserialize(self, raw_string) \u00b6 Takes a serialized sample string and sets the LogSample instance. Parameter: raw_string : str - Binary string representing a serialized LogSample of the same type. all_actor_names(self) \u00b6 Generator method to iterate over all actors in the trial. This information can also be retrieved from the parameters of the trial. Parameters: None Return: generator(str) - A generator for the names of the actors in the trial. get_action(self, actor) \u00b6 Retrieves the action from the actor in the sample. Parameters: actor : str or int - The name or index of the actor for which to retrieve the action. The number, index and name of actors can be retrieved from the parameters of the trial. Return: RecvAction instance - The action of the actor in the sample. get_observation(self, actor) \u00b6 Retrieve the observation destined for the actor in the sample. Parameters: actor : str or int - The name or index of the actor for which to retrieve the observation. The number, index and name of actors can be retrieved from the parameters of the trial. Return: RecvObservation instance - The observation of the actor in the sample. all_rewards(self) \u00b6 Generator method to iterate over all the rewards in the sample. Parameters: None Return: generator(RecvReward instance) - A generator for the rewards in the sample. all_messages(self) \u00b6 Generator method to iterate over all the messages in the sample. Parameters: None Return: generator(RecvMessage instance) - A generator for the messages in the sample.","title":"Python SDK"},{"location":"cogment/cogment-api-reference/python/#python-sdk","text":"The Python SDK is designed to run concurently and asynchronously using the Python asyncio library. As such, it should be run in an asyncio.Task . E.g. asyncio.run(MyMainFunction())","title":"Python SDK"},{"location":"cogment/cogment-api-reference/python/#installation","text":"The simplest way to install the python SDK is to just install it using pip: pip install cogment . And to install the generator (for cog_settings.py ) it is done similarly with pip: pip install cogment[generate] . Note that the generator is not installed by default when installing the Cogment SDK, it must be explcitly installed. The basic requirement is Python 3.7.","title":"Installation"},{"location":"cogment/cogment-api-reference/python/#general-usage","text":"","title":"General usage"},{"location":"cogment/cogment-api-reference/python/#trial-specifications","text":"The specifications of a trial type are contained in a spec file and the imported files defined in the spec. This file is typically named cogment.yaml . For example, an actor class is defined by its required observation space and action space . These \"spaces\" are defined by using protobuf message types (from the imported files). Observations and actions will simply be instances of the appropriate type. Messages and feedback user data don't have a set type, they can be any type of protobuf message as long as the receiver can manage that type (i.e. the object received is an instance of google.protobuf.Any and the contained type should be checked against known types before handling). The type is determined by the provided message from the originator.","title":"Trial Specifications"},{"location":"cogment/cogment-api-reference/python/#trial-parameters","text":"The trial parameters either come from the default parameters provided to the Orchestrator on startup, or they are dynamically generated/updated by the pre-trial hooks (which are provided to the Orchestrator on startup). Or both, since any default parameters are initially provided to the first pre-trial hook. The parameters are mostly indepedent of the spec file (cogment.yaml), except that the active actors listed in the parameters must have their actor class match an actor class defined in the spec file. Below, when we refer to the trial parameters, we mean the final parameters after any pre-trial hooks. Note that environment config and actor config can only be provided by pre-trial hooks.","title":"Trial Parameters"},{"location":"cogment/cogment-api-reference/python/#compiling-the-spec-file-into-cog_settingspy","text":"In order to use the specifications within python scripts, the spec file needs to be compiled into python modules. This is done by the Python SDK generator (see [#installation]). The generator is used this way: $ python3 -m cogment.generate --spec cogment.yaml --output ./cog_settings.py This will create a cog_settings.py module in the current directory ( --output ./ ). The generator will also compile the imported *.proto files into python modules that will be saved in the same location as the specified output file ( cog_settings.py ) and they will be named according to their proto names ( *_pb2.py ). The cog_settings.py Python module is required by all API entry points.","title":"Compiling the spec file into cog_settings.py"},{"location":"cogment/cogment-api-reference/python/#top-level-import","text":"The main module of the Cogment SDK is cogment . But all cogment scripts need to start with a cogment.Context , which also requires the generated module cog_settings (project specific definitions created from the spec file). If one needs to create a cogment.LogParams from scratch, the cog_settings module is also required. import cog_settings import cogment","title":"Top-level import"},{"location":"cogment/cogment-api-reference/python/#class-cogmentcontext","text":"Class to setup and run all the different aspects of trials.","title":"class cogment.Context"},{"location":"cogment/cogment-api-reference/python/#__init__self-user_id-cog_settings-prometheus_registryprometheus_clientcoreregistry","text":"Parameters: user_id : str - Identifier for the user of this context. cog_settings : module - Settings module associated with trials that will be run ( cog_settings namespace). prometheus_registry : prometheus_client.core.CollectorRegistry instance - Prometheus registry that'll be used by the Cogment metrics in this context. Can be set to None to completely deactivate them. The default value is Prometheus' default global registry.","title":"__init__(self, user_id, cog_settings, prometheus_registry=prometheus_client.core.REGISTRY)"},{"location":"cogment/cogment-api-reference/python/#async-serve_all_registeredself-served_endpoint-prometheus_port-8000","text":"Method to start and run the communication server for the registered components (environment, actor, prehook, datalog). This coroutine will end when all activity has stopped. Parameters: served_endpoint : ServedEndpoint instance - Details of the connection for the served components. prometheus_port : int - TCP/IP port number for Prometheus. Can be set to None to deactivate the Prometheus metrics server. Return: None","title":"async serve_all_registered(self, served_endpoint, prometheus_port = 8000)"},{"location":"cogment/cogment-api-reference/python/#get_controllerself-endpoint","text":"Method to get a controller instance to manage trials (start, stop, inquire, etc). Parameters: endpoint : Endpoint instance - Details of the connection to the Orchestrator. Return: Controller instance - An instance of the Controller class used to manage trials.","title":"get_controller(self, endpoint)"},{"location":"cogment/cogment-api-reference/python/#async-join_trialself-trial_id-endpoint-impl_namenone-actor_namenone-actor_classnone","text":"Method for an actor to asynchronously join an existing trial. This task will normally end after the user implementation has exited. Parameters: trial_id : str - The UUID of the trial to join. endpoint : Endpoint instance - Details of the connection to the Orchestrator. impl_name : str - deprecated actor_name : str - Name of the actor joining the trial. If None , actor_class will be used to find the actor to join. The name must match an active actor in the trial as found in the trial parameters in the sections trial_params:actors:name with trial_params:actors:endpoint set to \"cogment://client\". actor_class : str - The class of actor to join the trial. If None , actor_name will be used to find the actor to join. The class must match an active actor in the trial as found in the trial parameters in the sections trial_params:actors:actor_class with trial_params:actors:endpoint set to \"cogment://client\". Return: None","title":"async join_trial(self, trial_id, endpoint, impl_name=None, actor_name=None, actor_class=None)"},{"location":"cogment/cogment-api-reference/python/#register_environmentself-impl-impl_name-default","text":"Method to register the asynchronous callback function that will run an environment for a trial. Parameters: impl : async function(EnvironmentSession instance) - Callback function to be registered. impl_name : str - Name for the environment being run by the given callback function. Return: None","title":"register_environment(self, impl, impl_name = \"default\")"},{"location":"cogment/cogment-api-reference/python/#register_actorself-impl-impl_name-actor_classes","text":"Method to register the asynchronous callback function that will run an actor for a trial. Parameters: impl : async func(ActorSession instance) - Callback function to be registered. impl_name : str - Name for the actor implementation being run by the given callback function. actor_classes : list[str] - The actor class name(s) that can be run by the given callback function. The possible names are specified in the spec file under section actor_classes:name . If the list is empty, this implementation can run any actor class. Return: None","title":"register_actor(self, impl, impl_name, actor_classes=[])"},{"location":"cogment/cogment-api-reference/python/#register_pre_trial_hookself-impl","text":"Method to register an asynchronous callback function that will be called before a trial is started. Only one such function can be registered. But there may be multiple hook services for an Orchestrator. They are provided to the Orchestrator at startup. All hooks registered with the Orchestrator will be called in a pipeline fashion before each new trial. Parameters: impl : async func(PrehookSession instance) - Callback function to be registered. The PrehookSession instance member data should be changed as needed for the new trial before returning from this function. Return: None","title":"register_pre_trial_hook(self, impl)"},{"location":"cogment/cogment-api-reference/python/#register_datalogself-impl","text":"Method to register an asynchronous callback function that will be called for each trial to serve log requests. Only one such function can be registered. This service is addressed in the trial parameters in the datalog section. Parameters: impl : async func(DatalogSession instance) - Callback function to be registered Return: None","title":"register_datalog(self, impl)"},{"location":"cogment/cogment-api-reference/python/#class-controller","text":"Class containing data and methods to control and manage trials.","title":"class Controller"},{"location":"cogment/cogment-api-reference/python/#async-start_trialself-trial_confignone-trial_id_requestednone","text":"Method to start a new trial. The parameters of the trial will be set by the pre-trial hooks (registered in cogment.Context ), and the hooks will receive the provided trial config. Parameters: trial_config : protobuf class instance - Configuration for the trial. The type is specified in the spec file under the section trial:config_type . Can be None if no configuration is provided. This is provided to the first pre-trial hook. trial_id_requested : str - The trial identifier requested for the new trial. It must be unique among all active trials and a limited set of the latest ended trials (this list of trials can be retrieved with get_trial_info or watch_trial ). If provided, the Orchestrator will try to use this trial_id, otherwise, a UUID will be created. Return: str - The newly started trial ID. An empty string if the trial was not started due to a non-unique ID.","title":"async start_trial(self, trial_config=None, trial_id_requested=None)"},{"location":"cogment/cogment-api-reference/python/#terminate_trialself-trial_ids-hardfalse","text":"Method to request the end of a trial. Parameters: trial_ids : list[str] - The trial ID(s) to request to terminate. There must be at least one ID. hard : bool - If True , the termination will be forced and not wait for any action or observation. If False , the trial will wait for the next tick, to end gracefully (i.e. wait for the next full set of actions and response observations). Return: None","title":"terminate_trial(self, trial_ids, hard=False)"},{"location":"cogment/cogment-api-reference/python/#async-get_trial_infoself-trial_ids","text":"Method to get information about a trial. Parameters: trial_ids : list[str] - The trial ID(s) from which to request information. If no ID is provided, returns information about all trials. Note that ended trials may only appear for a short time in this list after they have ended. Return: list[TrialInfo instance] - List of trial information, one per trial. Can be empty if no trial matches.","title":"async get_trial_info(self, trial_ids)"},{"location":"cogment/cogment-api-reference/python/#async-watch_trialsself-trial_state_filters","text":"Generator method to iterate, in real-time, through all trial states matching the filters. When called, it will first iterate over the current states matching the filters, for all trials. Afterwards, it will iterate in real-time over the matching states as they change. Parameters: trial_state_filters : list[cogment.TrialState] - List of enum values from cogment.TrialState for which we are interested in receiving state changes. Return: generator(TrialInfo instance) - A generator for the state changes that arrive. The TrialInfo received here only contains the trial ID and the state.","title":"async watch_trials(self, trial_state_filters=[])"},{"location":"cogment/cogment-api-reference/python/#async-get_actorsself-trial_id","text":"Method to get the list of configured actors in a trial. Parameters: trial_id : str - The trial ID from which to request the list of actors. Return: list[ActorInfo instance] - List of actors configured in this trial.","title":"async get_actors(self, trial_id)"},{"location":"cogment/cogment-api-reference/python/#async-get_remote_versionsself","text":"Method to get the versions from the remote Orchestrator. Parameters: None Return: dict - The key of the dictionary is the name of the component ( str ), and the value is the version ( str ).","title":"async get_remote_versions(self)"},{"location":"cogment/cogment-api-reference/python/#class-session","text":"Abstract class that manages aspects of a trial. Contains data and methods common to all sessions .","title":"class Session"},{"location":"cogment/cogment-api-reference/python/#get_trial_idself","text":"Method to get the UUID of the trial managed by this session. Parameters: None Return: str - UUID of the trial.","title":"get_trial_id(self)"},{"location":"cogment/cogment-api-reference/python/#get_tick_idself","text":"Method to get the current tick id of the trial (i.e. time step). Parameters: None Return: int - The current tick id.","title":"get_tick_id(self)"},{"location":"cogment/cogment-api-reference/python/#is_trial_overself","text":"Method to inquire if the current trial has ended. Parameters: None Return: bool - True if the trial has ended, false otherwise.","title":"is_trial_over(self)"},{"location":"cogment/cogment-api-reference/python/#sending_doneself","text":"Method to notify the Orchestrator that all data for the trial, from this session, has been sent. This can be called only when the session is ending. When starting the session (see EnvironmentSession and ActorSession ), if the auto_done_sending parameter is True, this method should not be called, and if the parameter is False, it MUST be called to end the trial properly. Parameters: None Return: None","title":"sending_done(self)"},{"location":"cogment/cogment-api-reference/python/#add_rewardself-value-confidence-to-tick_id-1-user_datanone","text":"Method to send a reward to one or more actors. Parameters: value : float - Value of the reward. This will be aggregated with other rewards for the same target actor. confidence : float - Weight of this reward value in determining the final aggregated reward. Should be > 0. to : list[str] - Target(s) of reward. A list value could be the name of an actor in the trial. Or it could represent a set of actors; A set of actors can be represented with the wildcard character \" * \" for all actors (of all classes), or \" actor_class.* \" for all actors of a specific class (the actor_class is the name of the class as specified in the spec file). tick_id : int - The tick id (time step) for which the reward should be applied. If \"-1\", then the reward applies to the current time step. user_data : protobuf class instance - Extra user data to be sent with the reward. The class can be any protobuf class. It is the responsibility of the receiving actor to manage the class received (packed in a google.protobuf.Any ). Return: None","title":"add_reward(self, value, confidence, to, tick_id=-1, user_data=None)"},{"location":"cogment/cogment-api-reference/python/#class-environmentsessionsession","text":"Abstract class based on Session , containing session data and methods necessary to run an environment for a trial. An instance of this class is passed as an argument to the environment callback function registered with cogment.Context.register_environment . impl_name : str - Name of the implementation running this environment. config : protobuf class instance - User configuration received for this environment instance. Can be None if no configuration was provided. The type of the protobuf class is specified in the spec file in the section environment:config_type . name : str - Name of the environment this instance represents.","title":"class EnvironmentSession(Session)"},{"location":"cogment/cogment-api-reference/python/#startself-observations-none-auto_done_sendingtrue","text":"Method to report that the environment is starting to run the trial. The method should be called before any other method in the session. Parameters: observations : list[tuple(str, protobuf class instance)] - The initial observations from which the environment is starting the trial. This is the same as the parameter for self.produce_observations . If not provided, then the first observation sent with produce_observation will be used to initiate the trial (note that no actions will be received until the first observation is sent). auto_done_sending : bool - Controls when to notify the Orchestrator that all data has been sent. If True, the session will automatically send the notification after end is called. If False, the user MUST call sending_done (after end ) to end the trial properly. Return: None","title":"start(self, observations = None, auto_done_sending=True)"},{"location":"cogment/cogment-api-reference/python/#async-event_loopself","text":"Generator method to iterate over all events (actions, messages) as they are received. This will block and wait for an event. When this generator exits, the callback function (registered with register_environment ) should return to end the trial cleanly. The generator will exit for various reasons indicating the termination of the trial, a loss of communication with the orchestrator, or if the generator is sent \"False\" (in which case the callback function does not necessarily need to exit). Parameters: None Return: generator(RecvEvent instance) - A generator for the events that arrive. The RecvEvent instances received from this generator will only contain actions or messages; no observations nor rewards. When receiving actions in the event, the self.produce_observation method is normally used to \"reply\" (or self.end to end the trial).","title":"async event_loop(self)"},{"location":"cogment/cogment-api-reference/python/#produce_observationsself-observations","text":"Method to send observations to actors. If called after receiving an event of type EventType.ENDING , the observation will be consired the final observation (equivalent to calling end() ). Parameters: observations : list[tuple(str, protobuf class instance)] - The observations to send to actors. The string in the tuple is the name of the destination actor (or \"*\" for all actors). The name of the actors can be found in trial parameters under trial_params:actors:name . The protobuf class is the Observation Space for that actor, found in the spec file in the corresponding section actor_classes:observation:space . Return: None","title":"produce_observations(self, observations)"},{"location":"cogment/cogment-api-reference/python/#endself-final_observations","text":"Method to report the end of the environment. This will effectively end the trial. Message events can still arrive after this call. Parameters: final_observations : list[tuple(str, protobuf class instance)] - The final observations to send to the actors. This is the same as the parameter for self.produce_observations . Return: None","title":"end(self, final_observations)"},{"location":"cogment/cogment-api-reference/python/#get_active_actorsself","text":"Method to get the list of active actors in the trial. Parameters: None Return: list[ActorInfo instance] - List of active actors and classes involved in this trial.","title":"get_active_actors(self)"},{"location":"cogment/cogment-api-reference/python/#send_messageself-payload-to","text":"Method to send a message related to the current time step (tick id). Parameters: payload : protobuf class instance - The message data to be sent. The class can be any protobuf class. It is the responsibility of the receiving environment to manage the class received (packed in a google.protobuf.Any ). to : list[str] - Targets of feedback. Each value could be the name of an actor in the trial. Or it could represent a set of actors (with wildcards); A set of actors can be represented with the wildcard character \" * \" for all actors (of all classes), or \" actor_class.* \" for all actors of a specific class (the actor_class must match one of the classes listed in the trial parameters). Note that the wildcard does not include the environment. Return: None","title":"send_message(self, payload, to)"},{"location":"cogment/cogment-api-reference/python/#class-actorsessionsession","text":"Abstract class based on Session , containing session/trial data and methods necessary to run an actor for a trial. An instance of this class is passed as argument to the actor callback function registered with cogment.Context.register_actor . class_name : str - Name of the class of actor this instance represents. Specified in the spec file as actor_classes:name . impl_name : str - Name of the implementation of the actor represented by this instance. config : protobuf class instance - User configuration received for this actor instance. Can be None is no configuration was provided. The type of the protobuf class is specified in the spec file in the section actor_classes:config_type . name : str - Name of the actor this instance represents. env_name : str - Name of the environment running the trial this actor is participating in (used to send messages to the environment).","title":"class ActorSession(Session)"},{"location":"cogment/cogment-api-reference/python/#startself-auto_done_sendingtrue","text":"Method to start the actor. This method should be called before any other method in the session. Parameters: auto_done_sending : bool - Controls when to notify the Orchestrator that all data has been sent. If True, the session will automatically send the notification after receiving the last observation. If False, the user MUST call sending_done to end the trial properly. Return: None","title":"start(self, auto_done_sending=True)"},{"location":"cogment/cogment-api-reference/python/#async-event_loopself_1","text":"Generator method to iterate over all events (observations, rewards, messages) as they are received. This will block and wait for an event. When this generator exits, the callback function (registered with register_actor ) should return to end the trial cleanly. The generator will exit for various reasons indicating the end of the trial, a loss of communication with the orchestrator, or if the generator is sent \"False\". Parameters: None Return: generator(RecvEvent instance) - A generator for the events that arrive. The RecvEvent instances received from this generator will not contain actions. When receiving an observation in the event, the self.do_action method is normally used to \"reply\" (if the event type is EventType.ACTIVE ).","title":"async event_loop(self)"},{"location":"cogment/cogment-api-reference/python/#do_actionself-action","text":"Method to send actions to the environment. Parameters: action : protobuf class instance - An instance of the action space class specified in the corresponding section actor_classes:action:space of the spec file. If None , then no action space is sent (empty content) and the environment will receive a default initialized action space of the appropriate type. Return: None","title":"do_action(self, action)"},{"location":"cogment/cogment-api-reference/python/#send_messageself-payload-to_1","text":"Method to send a message related to the current time step (tick id). Parameters: payload : protobuf class instance - The message data to be sent. The class can be any protobuf class. It is the responsibility of the receiving actor to manage the class received (packed in a google.protobuf.Any ). to : list[str] - Targets of feedback. Each value could be the name of an actor in the trial, or the name of the environment (from self.env_name ). Or it could represent a set of actors (with wildcards); A set of actors can be represented with the wildcard character \" * \" for all actors (of all classes), or \" actor_class.* \" for all actors of a specific class (the actor_class must match one of the classes listed in the trial parameters). Note that the wildcard does not include the environment. Return: None","title":"send_message(self, payload, to)"},{"location":"cogment/cogment-api-reference/python/#class-prehooksession","text":"Abstract class containing trial configuration data to define the specifics of a trial. An instance of this class is passed as argument to the pre-trial hook callback function registered with cogment.Context.register_pre_trial_hook . The first pre-trial hook to be called will receive the default parameters set in the Orchestrator, the following hooks will receive the parameters set by the preceding hooks. trial_config : protobuf class instance - Configuration for the new trial. The type is specified in the spec file under the section trial:config_type . The first pre-trial hook receives the config that came from the Controller.start_trial() function. If None , no config will be sent to the next pre-trial hook. trial_max_steps : int - The maximum number of time steps (ticks) that the trial will run before terminating. If 0 (or None ), the trial will not be auto terminated (the environment and a Controller can still terminate the trial). trial_max_inactivity : int - The number of seconds of inactivity after which a trial will be terminated. If 0 (or None ), the trial will not be terminated because of inactivity. datalog_endpoint : str - The URL to connect to the data logger. The protocol must be \"grpc\". E.g. \"grpc://mydb:9000\". If None , no datalog service will be connected. datalog_exclude : list[str] - List of fields to exclude from the data to send for logging. environment_config : protobuf class instance - Configuration for the environment in the new trial. This configuration will be sent to the environment on start. The type is specified in the spec file under the section environment:config_type . If None , no config will be sent to the environment. environment_endpoint : str - The URL to connect to the environment. The protocol must be \"grpc\". E.g. \"grpc://myenv:9000\" environment_name : str - The name of the environment. environment_implementation : str - The name of the implementation to run the environment. actors : list[dict] - Each item (dictionary) of the list represents an actor. Each actor dictionary contains these key-value pairs: \"name\" : str - Name of the actor \"actor_class\" : str - The actor class for the actor. This is specific to a type of trial and must match values in the spec file under section actor_classes:name . \"endpoint\" : str - The URL to connect to the actor. If, instead of a gRPC URL, the value is \"cogment://client\", then this actor will connect in (rather than be connected to), and the actor will need to provide the gRPC URL to connect to the orchestrator. \"implementation\" : str - The name of the implementation to run this actor \"config\" : protobuf class instance - The configuration data for the actor. The type is specified in the spec file under the section actor_classes:config_type for the corresponding actor. If None , no config will be sent to the actor.","title":"class PrehookSession"},{"location":"cogment/cogment-api-reference/python/#get_trial_idself_1","text":"Method to retrieve the ID of the trial. Parameters: None Return: str - ID of the trial.","title":"get_trial_id(self)"},{"location":"cogment/cogment-api-reference/python/#get_user_idself","text":"Method to retrieve the identifier of the user that started the trial. Parameters: None Return: str - Identifier of the user that started the trial.","title":"get_user_id(self)"},{"location":"cogment/cogment-api-reference/python/#validateself","text":"Method to validate that the data is valid. This is a superficial check; even if the data validates successfully, there can still be problems with the data. This method should be called if changes have been made to the data members of the class. Exceptions are raised on error. Parameters: None Return: None","title":"validate(self)"},{"location":"cogment/cogment-api-reference/python/#class-datalogsession","text":"Abstract class containing session data and methods necessary to manage the logging of trial run data. An instance of this class is passed as an argument to the datalog callback function registered with cogment.Context.register_datalog . trial_id : str - UUID of the trial managed by this instance. user_id : str - Identifier of the user that started the trial. trial_params : cogment.LogParam instance - Parameters of the trial.","title":"class DatalogSession"},{"location":"cogment/cogment-api-reference/python/#startself","text":"Method to start receiving samples. Parameters: None Return: None","title":"start(self)"},{"location":"cogment/cogment-api-reference/python/#get_all_samplesself","text":"Generator method to iterate over all samples as they are received (waiting for each in turn). Parameters: None Return: generator(cogment.LogSample instance) - A generator for the samples received.","title":"get_all_samples(self)"},{"location":"cogment/cogment-api-reference/python/#class-cogmentendpoint","text":"Class enclosing the details for connecting to an Orchestrator. url : str - The URL where to connect to the Orchestrator. private_key : str - To use TLS for the connection, this must be set to the PEM-encoded private key. root_certificates : str - If using TLS for the connection (i.e. the private_key is not None ), this can be set to the PEM-encoded root certificates. If not set and using TLS for the connection, the root certificates will be fetched from the system default location. certificate_chain : str - If using TLS for the connection, this can be set to the PEM-encoded certificate chain.","title":"class cogment.Endpoint"},{"location":"cogment/cogment-api-reference/python/#__init__self-url","text":"Parameters: url : str - The URL where to connect to the Orchestrator.","title":"__init__(self, url)"},{"location":"cogment/cogment-api-reference/python/#class-cogmentservedendpoint","text":"Class enclosing the details for connection from an Orchestrator. port : str - The TCP/IP port where the service will be awaiting the Orchestrator connection. private_key_certificate_chain_pairs : list[tupple(str, str)] - To use TLS for incoming connections, this must be set to a list of tuples of the form (PEM-encoded private key, PEM-encoded certificate chain). root_certificates : str - If using TLS for the connection (i.e. private_key_certificate_chain_pairs is not None ), this should be set to PEM-encoded Orchestrator root certificates that the server will use to verify Orchestrator authentication.","title":"class cogment.ServedEndpoint"},{"location":"cogment/cogment-api-reference/python/#__init__self-port","text":"Parameters: port : int - The TCP/IP port where the service will be awaiting the Orchestrator connection.","title":"__init__(self, port)"},{"location":"cogment/cogment-api-reference/python/#class-cogmenttrialstateenumenum","text":"Enum representing the various states of trials. UNKNOWN: Should not be used. INITIALIZING: The trial is in the process of starting. PENDING: The trial is waiting for its final parameters, before running. RUNNING: The trial is running. TERMINATING: The trial is in the process of terminating (either a request to terminate has been received or the last observation has been received). ENDED: The trial has ended. Only a set number of ended trials will be kept (configured in the Orchestrator).","title":"class cogment.TrialState(enum.Enum)"},{"location":"cogment/cogment-api-reference/python/#class-trialinfo","text":"Class enclosing the details of a trial. trial_id : str - The trial ID to which the details pertain. state : cogment.TrialState - The current state of the trial. env_name : str - The name of the environment running the trial. tick_id : int - The time step that the information relates to. Only provided from a call to get_trial_info . duration : int - The time (in nanoseconds) that the trial has run. Only provided from a call to get_trial_info .","title":"class TrialInfo"},{"location":"cogment/cogment-api-reference/python/#class-actorinfo","text":"Class enclosing the details of an actor. actor_name : str - The name of the actor. actor_class_name : str - The name of the actor's class (as defined in the spec file).","title":"class ActorInfo"},{"location":"cogment/cogment-api-reference/python/#class-recvevent","text":"Class representing a received event (for environments and actors). It can contain any combination of data according to the receiver needs, or even be empty, but it will always have a type. type : Enum EventType - Type of event the enclosed data represents. observation : RecvObservation instance - Observation data. This can only be received by actors. None if not present. actions : list[RecvAction instance] - Action data from actors. This can only be received by the environment. The list is empty if not present. rewards : list[RecvReward instance] - Reward values and data. This can only be received by actors. The list is empty if not present. messages : *list[RecvMessage instance] - Message data. The list is empty if not present.","title":"class RecvEvent"},{"location":"cogment/cogment-api-reference/python/#class-cogmenteventtypeenumenum","text":"Enum representing the type of an event. EventType.NONE : Empty event. This kind of event should never be received. EventType.ACTIVE : Normal event from an active trial. Most events will be of this type. EventType.ENDING : Events from a trial in the process of ending. For the environment, this means that these events contain the last actions from the actors, and the trial is awaiting a final observation. For the actors, this means that the trial is ending and no action can/need to be sent in response. Note that because of network timing, there may be ACTIVE events (e.g. rewards or messages) arriving after some ENDING events, but the trial is ending regardless. EventType.FINAL : Final event for the trial. This does not contain data. The event loop will exit after this event is delivered. This event can be ignored if nothing needs to be done before exiting the loop.","title":"class cogment.EventType(enum.Enum)"},{"location":"cogment/cogment-api-reference/python/#class-recvobservation","text":"Class containing the details of an observation for an actor. tick_id : int - The time step that the observation relates to. timestamp : int - Unix style Epoch timestamp in nanoseconds (time since 00:00:00 UTC Jan 1, 1970). observation : protobuf class instance - Observation received from the environment. The class of the observation is defined as observation space for the actor class. This is specified in section actor_classes:observation:space in the spec file for the appropriate/receiving actor class.","title":"class RecvObservation"},{"location":"cogment/cogment-api-reference/python/#class-recvaction","text":"Class containing the details of an action from an actor. tick_id : int - The time step that the action relates to. timestamp : int - Unix style Epoch timestamp in nanoseconds (time since 00:00:00 UTC Jan 1, 1970). actor_index : int - Index of the actor in the list of all trial actors (returned by Session.get_active_actors ). action : protobuf class instance - Action from the actor which has index actor_index in the trial. The class of the action is defined as action space for the specific actor in the section actor_classes:action:space in the spec file.","title":"class RecvAction"},{"location":"cogment/cogment-api-reference/python/#class-recvmessage","text":"Class containing a message. tick_id : int - The time step that the message relates to. receiver_name : str - Name of the receiver for the message (the name of an actor, or wildcard string). sender_name : str - Name of the sender of the message (the name of an actor, or the environment). payload : google.protobuf.Any instance - Data for a received message. The class enclosed in google.protobuf.Any is of the type set by the sender; It is the responsibility of the receiver to manage the data received (i.e. determine the type and unpack the data).","title":"class RecvMessage"},{"location":"cogment/cogment-api-reference/python/#class-recvreward","text":"Class containing the details of a received reward. tick_id : int - The tick id (time step) for which the reward should be applied. receiver_name : str - Name of the receiver for the reward (the name of an actor, or wildcard string). value : float - Value of the reward (aggregated from the sources)","title":"class RecvReward"},{"location":"cogment/cogment-api-reference/python/#get_nb_sourcesself","text":"Return the number of source rewards this reward is based upon. Parameters: None Return: int - Number of sources.","title":"get_nb_sources(self)"},{"location":"cogment/cogment-api-reference/python/#all_sourcesself","text":"Generator method to iterate over all sources making up this reward. Parameters: None Return: generator(RecvRewardSource instance) - A generator for the sources in the reward (simple rewards that make up this final/aggregate reward).","title":"all_sources(self)"},{"location":"cogment/cogment-api-reference/python/#class-recvrewardsource","text":"Class containing the details of a received single source reward. value : float - Value of the reward from the sender. confidence : float - Confidence level of this reward value. sender_name : str - Name of the sender of this reward (the name of an actor, or the environment). user_data : google.protobuf.Any instance - Data for a user-specific reward format. Can be None if no specific data was provided. The class enclosed in google.protobuf.Any is of the type set by the sender; it is the responsibility of the receiver to manage the data received (i.e. determine the type and unpack the data).","title":"class RecvRewardSource"},{"location":"cogment/cogment-api-reference/python/#class-cogmentlogparams","text":"Class containing the paramaters of the trial. max_steps : int - The maximum number of steps/ticks that the trial should run. After this number of steps/ticks, an end request will be sent to the environment. max_inactivity : int - The maximum amount of time (in seconds) that the trial should be without activity before it is forcefully terminated. \"Activity\" is defined as a message received by the Orchestrator from a user component. nb_actors : int - The number of actors participating in the trial. datalog : dict - The datalog related parameters. The dictionary contains these key-value pairs: \"endpoint\" : str - The URL to connect to the datalog service. \"exclude\" : list(str) - Fields to exclude from the samples sent to the datalog service. environment : dict - The environment related parameters. The dictionary contains these key-value pairs: \"name\" : str - Name of the environment \"endpoint\" : str - The URL to connect to the environment. \"implementation\" : str - The name of the implementation to run the environment","title":"class cogment.LogParams"},{"location":"cogment/cogment-api-reference/python/#__init__self-cog_settings","text":"Parameter: cog_settings : module - Settings module associated with trials that will be run ( cog_settings namespace).","title":"__init__(self, cog_settings)"},{"location":"cogment/cogment-api-reference/python/#get_serialization_typeself","text":"Return the type of serial data produced by serialize and accepted by deserialize . The type represents an ID dependent on TrialParams defined in the low level gRPC API. Parameters: None Return: int - The type of the serialization string data. This is the type of string that is returned by serialize , and the only type accepted by deserialize ; it is undefined behavior to try to deserialize the wrong type of data. This value is strictly larger than 1.","title":"get_serialization_type(self)"},{"location":"cogment/cogment-api-reference/python/#serializeself","text":"Return a binary string equivalent of the parameters. Parameters: None Return: str - Serialized parameters.","title":"serialize(self)"},{"location":"cogment/cogment-api-reference/python/#deserializeself-raw_string","text":"Takes a serialized parameter string and sets the LogParams instance. Parameter: raw_string : str - Binary string representing a serialized LogParam of the same type.","title":"deserialize(self, raw_string)"},{"location":"cogment/cogment-api-reference/python/#get_trial_configself","text":"Returns the trial config. Parameters: None Return: protobuf class instance - Configuration for the trial. The type is specified in the spec file under the section trial:config_type .","title":"get_trial_config(self)"},{"location":"cogment/cogment-api-reference/python/#get_environment_configself","text":"Returns the environment config. Parameters: None Return: protobuf class instance - Configuration for the environment. The type is specified in the spec file under the section environment:config_type .","title":"get_environment_config(self)"},{"location":"cogment/cogment-api-reference/python/#get_actor_indexself-actor_name","text":"Returns the index of the given actor, or None if the actor is not in the trial. Parameters: actor_name : str - Name of the actor to look for in the trial parameters. Return: int - Index of actor if found. None if not found. This index is constant in the trial and relates to the complete list of actors provided by cogment (e.g. Controller.get_actors() ).","title":"get_actor_index(self, actor_name)"},{"location":"cogment/cogment-api-reference/python/#get_actor_nameself-actor_index","text":"Returns the name of an actor in the trial. Parameters: actor_index : int - Index of the actor to retrieve. This number is constant in the trial and relates to the complete list of actors provided by cogment (e.g. Controller.get_actors() ). The value must be between 0 and self.nb_actors (exclusively). Return: str - Name of the actor in the trial parameters.","title":"get_actor_name(self, actor_index)"},{"location":"cogment/cogment-api-reference/python/#get_actorself-actor_index","text":"Returns information about a particular actor in the trial. Parameters: actor_index : int - Index of the actor to retrieve. This number is constant in the trial and relates to the complete list of actors provided by cogment (e.g. Controller.get_actors() ). The value must be between 0 and self.nb_actors (exclusively). Return: dict - Dictionary containing the details of the actor parameters. The dictionary contains these key-value pairs: \"name\" : str - Name of the actor. \"actor_class\" : str - The actor class for the actor. This is specific to a type of trial and must match values in the spec file under section actor_classes:name . \"endpoint\" : str - The URL to connect to the service actor, or \"cogment://client\" for client actors that will connect in. \"implementation\" : str - The name of the implementation to run the actor. \"config\" : protobuf class instance - The configuration data for the actor. The type is specified in the spec file under the section actor_classes:config_type for the specific actor class of the actor.","title":"get_actor(self, actor_index)"},{"location":"cogment/cogment-api-reference/python/#class-cogmentlogsample","text":"Class containing a datalog sample. A sample starts and ends with the arrival of new observations from the environment. The last sample will end after all components have acknowledged the end of the trial (the state of that sample will then be TrialState.ENDED ). Note that some of the data may not be available ( None ) if it was excluded from the sample (see datalog parameters LogParams.datalog[\"exclude\"] ). tick_id : int - The time step that the sample data relates to. state : cogment.TrialState - The state of the trial at the end of the sample period. timestamp : int - Unix style Epoch timestamp in nanoseconds (time since 00:00:00 UTC Jan 1, 1970) at the beginning of the sample period. events : str - Description of special events that happened during the timeframe of the sample.","title":"class cogment.LogSample"},{"location":"cogment/cogment-api-reference/python/#__init__self-params","text":"Parameter: params : LogParams instance - The parameters of the trial.","title":"__init__(self, params)"},{"location":"cogment/cogment-api-reference/python/#get_serialization_typeself_1","text":"Returns the type of serial data produced by serialize and accepted by deserialize . The type represents an ID dependent on DatalogSample defined in the low level gRPC API. Parameters: None Return: int - The type of the serialization string data. This is the type of string that is returned by serialize , and the only type accepted by deserialize ; it is undefined behavior to try to deserialize the wrong type of data. This value is strictly larger than 1.","title":"get_serialization_type(self)"},{"location":"cogment/cogment-api-reference/python/#serializeself_1","text":"Returns a binary string equivalent of the sample. Parameters: None Return: str - Serialized sample.","title":"serialize(self)"},{"location":"cogment/cogment-api-reference/python/#deserializeself-raw_string_1","text":"Takes a serialized sample string and sets the LogSample instance. Parameter: raw_string : str - Binary string representing a serialized LogSample of the same type.","title":"deserialize(self, raw_string)"},{"location":"cogment/cogment-api-reference/python/#all_actor_namesself","text":"Generator method to iterate over all actors in the trial. This information can also be retrieved from the parameters of the trial. Parameters: None Return: generator(str) - A generator for the names of the actors in the trial.","title":"all_actor_names(self)"},{"location":"cogment/cogment-api-reference/python/#get_actionself-actor","text":"Retrieves the action from the actor in the sample. Parameters: actor : str or int - The name or index of the actor for which to retrieve the action. The number, index and name of actors can be retrieved from the parameters of the trial. Return: RecvAction instance - The action of the actor in the sample.","title":"get_action(self, actor)"},{"location":"cogment/cogment-api-reference/python/#get_observationself-actor","text":"Retrieve the observation destined for the actor in the sample. Parameters: actor : str or int - The name or index of the actor for which to retrieve the observation. The number, index and name of actors can be retrieved from the parameters of the trial. Return: RecvObservation instance - The observation of the actor in the sample.","title":"get_observation(self, actor)"},{"location":"cogment/cogment-api-reference/python/#all_rewardsself","text":"Generator method to iterate over all the rewards in the sample. Parameters: None Return: generator(RecvReward instance) - A generator for the rewards in the sample.","title":"all_rewards(self)"},{"location":"cogment/cogment-api-reference/python/#all_messagesself","text":"Generator method to iterate over all the messages in the sample. Parameters: None Return: generator(RecvMessage instance) - A generator for the messages in the sample.","title":"all_messages(self)"},{"location":"cogment/cogment-low-level-api-guide/grpc/","text":"Cogment gRPC API v2 \u00b6 The low-level cogment communication API is implemented using gRPC services. These services are collections of procedures to be called remotely (RPC). gRPC abstracts the network communication with familiar looking functions (representing the defined procedures), in any number of programming languages. How services are implemented or accessed is highly dependant on the programming language being interfaced, and is beyond the scope of this document (see gRPC API documentation). This reference requires a basic understanding of gRPC, and in particular the format of the *.proto files. General \u00b6 In this API, the bytes data type is normally used to contain the serialized data of externally defined messages. These messages are well defined in the trial specifications file. On the other hand, the google.protobuf.Any data type is normally used to contain messages that are not pre-defined (thus unknown by the framework), and may be decided at runtime. It is then the responsibility of the receiver to deserialize in the correct message type. Empty messages are normally used as a placeholder for easy future, backward compatible, extension to the API. In this API, gRPC metadata is normally used only for service request (by the caller) for identifying purposes. The details of the required metadata are described with the service calls. Service replies (the callees) are not expected to provide metadata. In some places in the API, we use a list of actor data without information about which actor is where in the list. These lists have a constant length and order throughout a trial (set in the trial parameters), and thus can/must be cross referenced with other such lists within the same trial (e.g. actors_in_trial , actors_map ). The actor can be infered by the position in the list, and the index into the list can sometimes be used to identify an actor. gRPC service names in Cogment are suffixed with \"SP\" (Service Point). Limitations \u00b6 Due to normal network delays and unpredictability of the various components, there are limitations related to the communication with the Ochestrator that translate in issues that can arise. In the current version, to simplify the implementation, there is an expectation of \"good behavior\" from the various components: Actors are expected to respond with an action only after receiving an observation, and to send only one action per observation received. The environment is expected to respond with an observation set only after receiving an action set, and to send only one observation set per action set received (and one initial observation set). All components are expected to respond within a reasonable amount of time. Hooks do not assume to receive specific parameters, they reply only with well formed parameters, and they do not assume a specific order of hooks being called (when multiple hooks are defined). A TerminateTrial (from the Control API) is called only a reasonable delay after a StartTrial (e.g. after at least two ticks have executed). Note that what constitutes a \"reasonable\" amount of time is dependent on many variables. Common types \u00b6 Most of the messages are defined in the common.proto file. ObservationSet and ActionSet are defined in environment.proto . Common Values \u00b6 Some values (and their standardized names) are recurrent throughout the gRPC API. tick_id: (uint64/sint64) The monotonic time, in number of steps, since the start of the trial. As an ID, it represents a discrete step in the processing of the trial. A step starts with observations representing a specific point in time, that are followed by actions, rewards and messages in relation to these observations. The first tick ID is 0. Some of these values may accept -1, meaning the latest step (e.g. when sending an action). timestamp: (fixed64) The wall-clock time in nanoseconds since 00:00:00UTC January 1, 1970 (Unix Epoch time). trial_id: (string) The identifier (name) of the trial. VersionRequest \u00b6 Empty message to serve as the request for the Version procedure (present in all gRPC services defined in the Cogment API). message VersionRequest {} VersionInfo \u00b6 Reply message for the Version procedure (present in all gRPC services defined in the API). It contains a list of version information. The Cogment framework expects at least \"cogment-api\" and \"grpc\" versions to be present in the list. The \"cogment-api\" is for the local version of the Cogment API used by the service. The \"grpc\" is for the version of gRPC used by the service. Other reported versions are specific to the service called, possibly for use by utility and management tools. message Version { string name = 1; string version = 2; } message VersionInfo { repeated Version versions = 1; } versions: List of version information name: The name/software/module for which the version is given. E.g. \"cogment-api\" version: The version related to the name. E.g. \"1.0.0b5\" TrialParams \u00b6 Global parameters for a trial. message TrialParams { TrialConfig trial_config = 1; DatalogParams datalog = 2; EnvironmentParams environment = 3; repeated ActorParams actors = 4; uint32 max_steps = 5; uint32 max_inactivity = 6; } trial_config: (optional) The user config for the controller of the trial. Will be sent to pre-trial hooks. datalog: (optional) The parameters for the datalog of the trial. If not present, data logging is disabled. environment: The parameters for the environment of the trial. actors: The parameters for all actors involved in the trial. This list's length and order define the length and order of the lists of actors provided in different places in the API (e.g. actors_in_trial ) for the trial. max_steps: The maximum number of steps/ticks that the trial should run. After this number of steps/ticks, an end request will be sent to the environment. max_inactivity: The maximum amount of time (in seconds) that the trial should be without activity before it is forcefully terminated. \"Activity\" is defined as a message received by the Orchestrator from a user component. DatalogParams \u00b6 Parameters related to the data logger. message DatalogParams { string endpoint = 1; repeated string exclude_fields = 2; } endpoint: The URL where the data logger is being served. This is used by the Orchestrator to connect to the datalog using the LogExporterSP gRPC service. exclude_fields: A list of fields from DatalogSample to not send to the data logger. EnvironmentParams \u00b6 Parameters related to an environment. message EnvironmentParams { string endpoint = 1; EnvironmentConfig config = 2; string implementation = 3; } endpoint: The URL where the environment is being served. This is used by the Orchestrator to connect to the environment using the EnvironmentSP gRPC service. config: (optional) The user config for the environment. implementation: (optional) The name of the implementation of the environment to run. If not provided, an arbitrary implementation will be chosen. ActorParams \u00b6 Parameters related to an actor. message ActorParams { string name = 1; string actor_class = 2; string endpoint = 3; string implementation = 4; ActorConfig config = 5; } name: The name of the actor. actor_class: The name of the class of the actor. For a particular trial, the possible actor classes are defined in the spec file in the actor_classes:name sections. endpoint: The URL where the actor is being served, or \"cogment://client\". The URL is used by the Orchestrator to connect to the actor using the ServiceActorSP gRPC service. If set to \"cogment://client\", then the actor is a client and will connect to the Orchestrator instead, using the ClientActorSP gRPC service. implementation: (optional) The name of the implementation of the actor class to run. If not provided, an arbitrary implementation will be chosen. config: (optional) The user config for the actor. TrialConfig , ActorConfig , EnvironmentConfig \u00b6 These contain the config data for various user components. message TrialConfig { bytes content = 1; } message EnvironmentConfig { bytes content = 1; } message ActorConfig { bytes content = 1; } content: The serialized protobuf message representing a config. For a particular trial, the actual message type is defined in the spec file in its respective section: trial:config_type , environment:config_type , and actor_classes:config_type . The trial config is given when starting a trial, and is for use by pre-trial hooks. The environment config is set by pre-trial hooks, and is for use by the environment. The actors configs are set by the pre-trial hooks, and are for use by actors (each actor class can have a different config type). TrialActor \u00b6 Details of an actor participating in a trial. message TrialActor { string name = 1; string actor_class = 2; } name: The name of the actor. actor_class: The name of the class of actor. For a particular trial, the possible actor classes are defined in the the spec file in the actor_classes:name sections. Observation \u00b6 A singular observation. message Observation { uint64 tick_id = 1; fixed64 timestamp = 2; bytes content = 3; } tick_id: Tick of this observation. timestamp: The time of the observation. content: The serialized protobuf message representing an observation for a specific actor. In a particualr trial, the actual message type for the observation space is defined in the spec file for each actor class in section actor_classes:observation:space . Note that the specific actor represented is defined by the enclosing message. Action \u00b6 Data associated with an actor's action. message Action { uint64 tick_id = 1; fixed64 timestamp = 2; bytes content = 3; } tick_id: The tick of the observation on which the action is taken. timestamp: The time of the action. content: The serialized protobuf message representing an action from a specific actor. In a particular trial, the actual message type for the action space is defined in the spec file for each actor class in section actor_classes:action:space . Note that the specific actor represented is defined by the enclosing message. Message \u00b6 Data associated with a communication (message) destined for an actor or the environment. message Message { sint64 tick_id = 1; string sender_name = 2; string receiver_name = 3; google.protobuf.Any payload = 4; } tick_id: Tick associated with the message. sender_name: The name of the sending actor/environment. This is optional when sending messages (i.e. the sender is already known). receiver_name: The name of the target/receiving actor/environment. payload: Data for the target actor/environment. It is the responsibility of the target to understand the type received. RewardSource \u00b6 Data representing a simple reward source made by a single component/sender, usually for the purpose of training automated agents. message RewardSource { string sender_name = 1; float value = 2; float confidence = 3; google.protobuf.Any user_data = 4; } sender_name: Name of the sender that sent the reward. This is not needed when sending because it will be set by the orchestrator. It is only used by receiving actors. value: The numerical value of the provided reward. confidence: The weight of this reward in computing the final (aggregated) reward. user_data: Additional user data to be consumed by the receiving actor. It is the responsibility of the receiver to understand the type received. Reward \u00b6 Data representing a reward sent or received, usually for the purpose of training automated agents. This is an aggregate of possibly multiple RewardSource (but at least one). message Reward { sint64 tick_id = 1; string receiver_name = 2; float value = 3; repeated RewardSource sources = 4; } tick_id: The tick associated with the reward. If set to -1 when sending a reward, the orchestrator will automatically assign the latest tick. This will always be a valid tick (i.e. >= 0) when receiving a reward. receiver_name: Name of the receiving actor (the reward destination). value: The aggregated value (weighted sum) of the provided reward sources. May be ignored when sending a reward; The final value will be computed by the orchestrator. sources: The simple reward sources that form this aggregated reward. There must be at least one. ObservationSet \u00b6 A set of environment observations for all actors in the trial. message ObservationSet { uint64 tick_id = 1; fixed64 timestamp = 2; repeated bytes observations = 3; repeated int32 actors_map = 4; } tick_id: The tick to which the observations relate to. timestamp: The time when the observation set was made. observations: A list of observations. Indexed into by the actors_map . Each bytes chunk is a serialized protobuf message representing an observation for a specific actor class. For a particular trial, the actual message type for the observation space is defined in the spec file for each actor class in section actor_classes:observation:space . Note that the specific actor represented is defined by the actors_map . actors_map: A list of indexes into the observations list above. This list of indexes has the same length and order as the list of actors provided in different places in the API (e.g. actors_in_trial ), for the same trial. ActionSet \u00b6 A set of actions from all actors in the trial. message ActionSet { uint64 tick_id = 1; fixed64 timestamp = 2; repeated bytes actions = 3; } tick_id: The tick to which the actions relate to. timestamp: The time when the action set was made (usually after the last action arrived at the Orchestrator). actions: A list of actions. Each bytes chunk is a serialized protobuf message representing an action from a specific actor. For an particular trial, the actual message type for the action space is defined in the spec file for each actor class in section actor_classes:action:space . This list has the same length and order as the list of actors provided in different places in the API (e.g. actors_in_trial ), for the same trial. TrialState \u00b6 Enum representing the state of a trial. enum TrialState { UNKNOWN = 0; INITIALIZING = 1; PENDING = 2; RUNNING = 3; TERMINATING = 4; ENDED = 5; } UNKNOWN: Should not be used (it's a requirement of protobuf enums to have a 0 default value). INITIALIZING: The trial is in the process of starting. PENDING: The trial is waiting for its final parameters, before running. RUNNING: The trial is running. TERMINATING: The trial is in the process of terminating (either a request to terminate has been received or the last observation has been received). ENDED: The trial has ended. Only a set number of ended trials will be kept (configured in the Orchestrator). CommunicationState \u00b6 Enum representing the state of communication with the actors and environment. enum CommunicationState { UNKNOWN_COM_STATE = 0; NORMAL = 1; HEARTBEAT = 2; LAST = 3; LAST_ACK = 4; END = 5; } UNKNOWN_COM_STATE: Should not be used (it's a requirement of protobuf enums to have a 0 default value). NORMAL: Normal communication message. Always contains data. HEARTBEAT: Heartbeat request/reply message. Contains no data. When received, must be responded in kind. LAST: Message indicating that the trial is ending, and ending data is following (as NORMAL ). Contains no data. LAST_ACK: Message indicating that the last data has been sent (i.e. this is the last outgoing message). Contains no data. END: Message indicating that the trial has ended (i.e. this is the final message). Contains no data, except maybe for details . The normal (soft) end of a trial follows this sequence : Orchestrator or Environment sends LAST Exchange of NORMAL finalizing data Component sends LAST_ACK (component stops sending after this) Orchestrator sends NORMAL finalizing data Orchestrator terminates communication with END For a hard termination of a trial, the Orchestrator will send END to all components (with no LAST / LAST_ACK handshake). Control API \u00b6 This API is defined in orchestrator.proto . It is implemented by the cogment orchestrator, and client applications are expected to connect to it using the gRPC client API. This API is used for general control and services related to trials. Service TrialLifecycleSP \u00b6 service TrialLifecycleSP { rpc StartTrial(TrialStartRequest) returns (TrialStartReply) {} rpc TerminateTrial(TerminateTrialRequest) returns (TerminateTrialReply) {} rpc GetTrialInfo(TrialInfoRequest) returns (TrialInfoReply) {} rpc WatchTrials(TrialListRequest) returns (stream TrialListEntry) {} rpc Version(VersionRequest) returns (VersionInfo) {} } StartTrial() \u00b6 Start a new trial. Metadata: None TerminateTrial() \u00b6 Request the environment to terminate existing trial(s). Metadata: trial-id : ( one or more ) Identifier(s) of the trial(s) to terminate. GetTrialInfo() \u00b6 Get extra information about an existing trial. Metadata: trial-id : ( zero or more ) Identifier(s) of the trial(s) we are requesting information about. If no trial id is provided, the request is for information about all active trials. WatchTrials() \u00b6 Stream state changes from trials. Metadata: None Version() \u00b6 Request version data. Metadata: None TrialStartRequest \u00b6 Request message for the StartTrial procedure. message TrialStartRequest { TrialConfig config = 1; string user_id = 2; string trial_id_requested = 3; } config: The trial config data. This data can be used by the pre-trial hooks to determine the config for the rest of the componenents. user_id: The ID of the user that is starting the trial. trial_id_requested: The trial identifier requested for the new trial. It must be unique. If not empty, the Orchestrator will try to use this trial_id, otherwise, a UUID will be created. TrialStartReply \u00b6 Reply message for the StartTrial procedure. message TrialStartReply { string trial_id = 1; } trial_id: ID of the newly started trial. Empty if the requested trial ID could not be used. TerminateTrialRequest \u00b6 Request message for the TerminateTrial procedure. message TerminateTrialRequest {} TerminateTrialReply \u00b6 Reply message for the TerminateTrial procedure. message TerminateTrialReply {} TrialInfoRequest \u00b6 Request message for the GetTrialInfo procedure. message TrialInfoRequest { bool get_latest_observation = 1; } get_latest_observation: If true, request the latest environment observation available for the trial (in addition to standard information). TrialInfoReply \u00b6 Reply message for the GetTrialInfo procedure. message TrialInfoReply { repeated TrialInfo trial = 1; } trial: List of information about the trials. Contains only the requested trial info if a trial ID was provided when the call was made (as metadata to the procedure). Otherwise contains information about all active trials. TrialInfo \u00b6 Message containing information about a trial. message TrialInfo { string trial_id = 1; string env_name = 2; TrialState state = 3; uint64 tick_id = 4; fixed64 trial_duration = 5; ObservationSet latest_observation = 6; repeated TrialActor actors_in_trial = 7; } trial_id: The Identifier of the trial. env_name: The name of the environment running the trial. state: The state of the trial. tick_id: The current tick of the trial. trial_duration: The duration of the trial so far, in nanoseconds. If the trial has ended, this is the duration from start to end of the trial. This is meant as an indicator; resolution may not be a nanosecond, and precision is not guaranteed. latest_observation: The latest environment observations for all actors. This will be provided only if requested in the TrialInfoRequest . actors_in_trial: The list of active actors in the trial. TrialListRequest \u00b6 Request message for the WatchTrials procedure. message TrialListRequest { repeated TrialState filter = 1; } filter: The list of states that are requested. If a trial is not in a state found in this list, it will not be reported. If the list is empty, all states will be reported. TrialListEntry \u00b6 Stream reply message for the WatchTrials procedure. message TrialListEntry { string trial_id = 1; TrialState state = 2; } trial_id: The Identifier of the trial. state: The state of the trial. Actor API \u00b6 There are two kinds of actors: Service and Client. They each have their own separate service (respectively ServiceActorSP and ClientActorSP ). But the messages are identical and work almost the same way (except for the initial phase). Service Actor API \u00b6 This API is defined in agent.proto . It is implemented by the service actor application using the gRPC server API, and the Orchestrator connects to the service actor application using the gRPC client API. This API is used by service actors that will be participating in new trials. They are connected at the start of a trial in which they participate. Multiple simultaneous service actors can be served from a single service application instance (i.e. same endpoint). An actor endpoint, for the Orchestrator to connect to, is defined in the trial parameters . Service ServiceActorSP \u00b6 service ServiceActorSP { rpc RunTrial(stream ActorRunTrialInput) returns (stream ActorRunTrialOutput) {} rpc Version(VersionRequest) returns (VersionInfo) {} } Client Actor API \u00b6 This API is defined in orchestrator.proto . It is implemented by the Orchestrator using the gRPC server API, and client applications are expected to connect to the Orchestrator using the gRPC client API. This API is used by client actors participating in existing (initializing) trials. The trial expecting client actors will wait for all actors to be connected before starting the trial. The actors connecting this way must have an endpoint set to \"cogment://client\" in the trial parameters . Note the reversal of the input and output messages compared to the service actor RunTrial procedure. Service ClientActorSP \u00b6 service ClientActorSP { rpc RunTrial(stream ActorRunTrialOutput) returns (stream ActorRunTrialInput) {} rpc Version(VersionRequest) returns (VersionInfo) {} } RunTrial() \u00b6 Procedure call to participate in a trial. It is active for the duration of the trial. Actor actions and data are provided to the Orchestrator in the output message stream, and observations and data are provided by the Orchestrator in the input message stream. Metadata: trial-id : Identifier of the trial the actor is participating in. This is supplied to service actors, but must be supplied by client actors. Version() \u00b6 Request version data. Metadata: None ActorRunTrialInput \u00b6 Message received by actors during the streaming RunTrial procedure. data should contain a message only when state is NORMAL (or in the case of a hard termination, details can be sent with state END ). Defined in the common.proto file. message ActorRunTrialInput { CommunicationState state = 1; oneof data { ActorInitialInput init_input = 2; Observation observation = 3; Reward reward = 4; Message message = 5; string details = 6; } } state: The state of this communication message. Identifies this message as a data or a control message. init_input: The initial communication data at the start of a trial. It should always be the first NORMAL state message in the stream. Used to report the details of the trial the actor is participating in. observation: An observation from the environment. reward: Rewards from other participants in the trial. message: A message from other participants in the trial. details: Explanation for special circumstances, for example when receiving a hard termination signal (a state of END without LAST or LAST_ACK ). ActorRunTrialOutput \u00b6 Message sent by actors during the streaming RunTrial procedure. data should contain a message only when state is NORMAL . Defined in the common.proto file. message ActorRunTrialOutput { CommunicationState state = 1; oneof data { ActorInitialOutput init_output = 2; Action action = 3; Reward reward = 4; Message message = 5; string details = 6; } } state: The state of this communication message. Identifies this message as a data or a control message. init_output: The initial communication data at the start of a trial. It should always be the first NORMAL state message in the stream. Used to initiate or acknowledge connection to a trial. action: An action from the actor. reward: A reward for other participants in the trial. message: A message for other participants in the trial. details: Reserved . ActorInitialInput \u00b6 The initial communication message at the start of a trial. Used to report the details of the trial the actor is participating in. For service actors, this message initiates the connection stream for a new trial. The trial ID is provided in the metadata of the RunTrial procedure. For client actors, this message is a reply to a connection request to an existing trial. message ActorInitialInput { string actor_name = 1; string actor_class = 2; string impl_name = 3; string env_name = 4; ActorConfig config = 5; } actor_name: The name of the actor participating in the trial. actor_class: The actor class of the actor participating in the trial. impl_name: (optional) Name of the implementation that should run the actor in this trial. If not provided, an arbitrary implementation will be used. env_name: The name of the environment running the trial the actor is participating in. config: The configuration to start the actor. ActorInitialOutput \u00b6 The initial communication message at the start of a trial. Used to initiate or acknowledge connection to a trial. For service actors, this message is empty and serves to acknowledge that the actor is ready to start the trial. For client actors, this message serves as a request to connect to an existing trial. The trial ID is provided in the metadata of the RunTrial procedure. message ActorInitialOutput { oneof slot_selection { string actor_class = 1; string actor_name = 2; } } actor_name: The name in the trial that the client actor wants to participate as. actor_class: The class in the trial that the client actor wants to participate as. In this case, there may be many options, and the Orchestrator will decide precisely which name the client actor will receive. Environment API \u00b6 This API is defined in environment.proto . It is implemented by the environment application using the gRPC server API, and the Orchestrator connects to the environment application using the gRPC client API. This API is used by environments that will run trials. There is only one environment per trial. Multiple simultaneous environments (for different trials) can be served from a single environment application instance (endpoint). The environment endpoint, for the Orchestrator to connect to, is defined in the trial parameters . Service EnvironmentSP \u00b6 service EnvironmentSP { rpc RunTrial(stream EnvRunTrialInput) returns (stream EnvRunTrialOutput) {} rpc Version(VersionRequest) returns (VersionInfo) {} } RunTrial() \u00b6 Procedure call to participate in a trial. It is active for the duration of the trial. Actor actions and data are provided by the Orchestrator in the input message stream, and observations and data are provided to the Orchestrator in the output message stream. Metadata: trial-id : Identifier of the trial the environment is participating in. Version() \u00b6 Called to request version data. Metadata: None EnvrRunTrialInput \u00b6 Message received by the environment during the streaming RunTrial procedure. data should contain a message only when state is NORMAL (or in the case of a hard termination, details can be sent with state END ). message EnvRunTrialInput { CommunicationState state = 1; oneof data { EnvInitialInput init_input = 2; ActionSet action_set = 3; Message message = 4; string details = 5; } } state: The state of this communication message. Identifies this message as a data or a control message. init_input: The initial communication data at the start of a trial. It should always be the first NORMAL state message in the stream. Used to provide the details of the trial the environment will run. action_set: Actions from all actors in the trial. message: A message from other participants in the trial. details: Explanation for special circumstances, for example when receiving a hard termination signal (a state of END without LAST or LAST_ACK ). EnvRunTrialOutput \u00b6 Message sent by the environment during the streaming RunTrial procedure. data should contain a message only when state is NORMAL . message EnvRunTrialOutput { CommunicationState state = 1; oneof data { EnvInitialOutput init_output = 2; ObservationSet observation_set = 3; Reward reward = 4; Message message = 5; string details = 6; } } state: The state of this communication message. Identifies this message as a data or a control message. init_output: The initial communication data at the start of a trial. It should always be the first NORMAL state message in the stream. Used to acknowledge that the environment is ready to run the trial. Note that the trial will only really start when the environment sends the first set of observations. observation_set: Observations for all actors in the trial. reward: A reward for other participants in the trial. message: A message for other participants in the trial. details: Reserved . EnvInitialInput \u00b6 The initial communication message at the start of a trial. This message initiates the connection stream for a new trial. The trial ID is provided in the metadata of the RunTrial procedure. message EnvInitialInput { string name = 1; string impl_name = 2; uint64 tick_id = 3; repeated TrialActor actors_in_trial = 4; EnvironmentConfig config = 5; } name: The name of the environment participating in the trial. impl_name: (optional) Name of the implementation that should run the environment in this trial. If not provided, an arbitrary implementation will be used. tick_id: Initial tick id requested to start the environment. actors_in_trial: The list of all actors participating in the trial. This list has the same length and order as the list of actors provided in different places in the API, for the same trial. config: The configuration to start the environment. EnvInitialOutput \u00b6 The initial communication message at the start of a trial. This message is empty and serves to acknowledge that the environment is ready to run the trial. message EnvInitialOutput {} Data/Log API \u00b6 This API is defined in datalog.proto . It is implemented by the data logger application using the gRPC server API, including the out-of-the-box component cogment-trial-datastore . The data logger endpoint, for the orchestrator to connect to, is defined in the trial parameters. Service LogExporterSP \u00b6 service LogExporterSP { rpc RunTrialDatalog(stream LogExporterSampleRequest) returns (LogExporterSampleReply) {} rpc Version(VersionRequest) returns (VersionInfo) {} } RunTrialDatalog() \u00b6 Called for each trial, at the start of the trial. The first data received are the parameters. Data samples are provided in the request stream following the parameters. The stream is maintained for the duration of the trial. Metadata: trial-id : Identifier of the trial that is the source of the data. user-id : Identifier of the user that started the trial. Version() \u00b6 Called to request version data. Metadata: None LogExporterSampleRequest \u00b6 Stream request message for the RunTrialDatalog procedure. message SampleInfo { uint64 tick_id = 1; fixed64 timestamp = 2; TrialState state = 3; repeated string special_events = 4; } message DatalogSample { SampleInfo info = 1; ObservationSet observations = 2; repeated Action actions = 3; repeated Reward rewards = 4; repeated Message messages = 5; } message LogExporterSampleRequest { oneof msg { TrialParams trial_params = 1; DatalogSample sample = 2; } } tick_id: The current tick of the trial. timestamp: The time at the beginning of the tick. state: The state of the trial at the end of the tick. special_events: Events not visible from the rest of the data may appear in here. observations: Observations from the environment. actions: Actions from all actors. This list has the same length and order as the list of actors provided in trial_params . rewards: List of rewards sent to actors. messages: List of user data sent to actors or the environment. trial_params: Trial parameters used for a trial. This is sent on start of a trial, as the first message in the RunTrialDatalog stream. sample: A data sample to be logged. LogExporterSampleReply \u00b6 Reply message for the RunTrialDatalog procedure. message LogExporterSampleReply {} Hook API \u00b6 This API is defined in hooks.proto . It is implemented by the pre-trial hook application using the gRPC server API, and the orchestrator connects to the application. The pre-trial hook endpoint, for the orchestrator to connect to, are defined on the command line of the Orchestrator (or in environment variables). Service TrialHooksSP \u00b6 service TrialHooksSP { rpc OnPreTrial(PreTrialParams) returns (PreTrialParams) {} rpc Version(VersionRequest) returns (VersionInfo) {} } OnPreTrial() \u00b6 Called before a trial is started to set or modify the parameters for the trial. Metadata: trial-id : Identifier of the new trial that will be started. user-id : Identifier of the user that started the trial. Version() \u00b6 Called to request version data. Metadata: None PreTrialParams \u00b6 Request and reply message for the OnPreTrial procedure. message PreTrialParams { TrialParams params = 1; } params: The trial parameters so far. The first hook to be called will receive the default parameters from the Orchestrator, and subsequent hooks will receive the updated parameters from the previous hook. The last hook reply will be the final parameters to use for the new trial. Model Registry API \u00b6 This API is defined in model_registry.proto . It is implemented by cogment-model-registry . Service ModelRegistrySP \u00b6 This gRPC API defines a service able to store versioned model, e.g. neural network architecture, weights and any additional parameters. service ModelRegistrySP { rpc CreateOrUpdateModel(CreateOrUpdateModelRequest) returns (CreateOrUpdateModelReply) {} rpc DeleteModel(DeleteModelRequest) returns (DeleteModelReply) {} rpc RetrieveModels(RetrieveModelsRequest) returns (RetrieveModelsReply) {} rpc CreateVersion(stream CreateVersionRequestChunk) returns (CreateVersionReply) {} rpc RetrieveVersionInfos(RetrieveVersionInfosRequest) returns (RetrieveVersionInfosReply) {} rpc RetrieveVersionData(RetrieveVersionDataRequest) returns (stream RetrieveVersionDataReplyChunk) {} } CreateOrUpdateModel() \u00b6 Create or update a model in the registry having the given unique (within the registry) model_id . Metadata: None Request: CreateOrUpdateModelRequest Reply: CreateOrUpdateModelReply DeleteModel() \u00b6 Delete a given model and all its versions from the registry. Metadata: None Request: DeleteModelRequest Reply: DeleteModelReply RetrieveModels() \u00b6 Retrieve all or selected models. This procedure supports paginated requests. Metadata: None Request: RetrieveModelsRequest Reply: RetrieveModelsReply CreateVersion() \u00b6 Create a new version of a given model. Because of their potential large size, model version data are uploaded as a stream. Metadata: None Request: Stream of CreateVersionRequestChunk Reply: CreateVersionReply RetrieveVersionInfos() \u00b6 Retrieve the information for all or selected versions of a given model. Metadata: None Request: RetrieveVersionInfosRequest Reply: RetrieveVersionInfosReply RetrieveVersionData() \u00b6 Retrieve the data for a specific version of the model. Because of their potential large size, data are retrieved as a stream. Metadata: None Request: RetrieveVersionDataRequest Reply: Stream of RetrieveVersionDataReplyChunk CreateOrUpdateModelRequest \u00b6 Request for ModelRegistrySP.CreateOrUpdateModel() message CreateOrUpdateModelRequest { ModelInfo model_info = 1; } model_info : Defines the unique model identifier within the registry and the user_data to use to create or update the model. CreateOrUpdateModelReply \u00b6 Reply for ModelRegistrySP.CreateOrUpdateModel() message CreateOrUpdateModelReply {} DeleteModelRequest \u00b6 Request for ModelRegistrySP.DeleteModel() message DeleteModelRequest { string model_id = 1; } model_ids : Identifier of the model to be deleted. DeleteModelReply \u00b6 Reply for ModelRegistrySP.DeleteModel() message DeleteModelReply {} RetrieveModelsRequest \u00b6 Request for ModelRegistrySP.RetrieveModel() . message RetrieveModelsRequest { repeated string model_ids = 1; uint32 models_count = 3; string model_handle = 4; } model_ids : List of the identifiers of the desired models, leave emtpy to retrieve all models. models_count : (optional) The desired number of models to be retrieved, leave empty (or set to 0) to retrieve all models matching the request. model_handle : (optional) Leave empty for the initial request, use previously provided RetrieveModelsReply.next_model_handle on the next calls to retrieve the next models. RetrieveModelsReply \u00b6 Reply for ModelRegistrySP.RetrieveModel() . message RetrieveModelsReply { repeated ModelInfo model_infos = 1; string next_model_handle = 2; } model_infos : At most RetrieveModelsRequest.models_count models. next_model_handle : Opaque handle to be used to retrieve the next models matching the request. CreateVersionRequestChunk \u00b6 Part of the request stream for ModelRegistrySP.CreateVersion() . message CreateVersionRequestChunk { message Header { ModelVersionInfo version_info = 1; } message Body { bytes data_chunk = 1; } oneof msg { Header header = 1; Body body = 2; } } The first message in the stream should define header : version_info : Information regarding the model version to create, version_number will be ignored. data_hash and data_size should be computed from the total final data and will be used by the server to validate it. The following messages should define body : data_chunk : A chunk of the version data, all the chunks in the stream will be concatened. CreateVersionReply \u00b6 Reply for ModelRegistrySP.CreateVersion() . message CreateVersionReply { ModelVersionInfo version_info = 1; } version_info : The informations relative to the created model version, in particular the defined version_number . RetrieveVersionInfosRequest \u00b6 Request for ModelRegistrySP.RetrieveVersionInfos() . message RetrieveVersionInfosRequest { string model_id = 1; repeated int32 version_numbers = 2; uint32 versions_count = 3; string version_handle = 4; } model_id : Identifier of the model we want to retrieve versions from. version_numbers : List of desired version number (or -1 to denote the latest version). Leave emtpy to retrieve all versions of the given model. versions_count : (optional) The desired number of versions to be retrieved, leave empty (or set to 0) to retrieve all the versions matching the request. version_handle : (optional) Leave empty for the initial request, use previously provided RetrieveVersionInfosReply.next_version_handle on the next calls to retrieve the next versions. RetrieveVersionInfosReply \u00b6 Reply for ModelRegistrySP.RetrieveVersionInfos() . message RetrieveVersionInfosReply { repeated ModelVersionInfo version_infos = 1; string next_version_handle = 2; } version_infos : At most RetrieveVersionInfosRequest.versions_count versions. next_version_handle : Opaque handle to be used to retrieve the next versions matching the request. RetrieveVersionDataRequest \u00b6 Request for ModelRegistrySP.RetrieveVersionData() . message RetrieveVersionDataRequest { string model_id = 1; int32 version_number = 2; } model_id : Identifier of the model we want to retrieve version from. version_numbers : Number of the desired version. RetrieveVersionDataReplyChunk \u00b6 Part of the reply stream of ModelRegistrySP.RetrieveVersionData() . message RetrieveVersionDataReplyChunk { bytes data_chunk = 1; } data_chunk : A chunk of the version data. All the chunks in the stream need to be concatened. The completeness and validity of the received data can be checked using the version's data_size and data_hash respectivelly. ModelInfo \u00b6 Defines a model identifier and associated user data. message ModelInfo { string model_id = 1; map<string, string> user_data = 2; } model_id : Unique model identifier. user_data : Key/value user data associated with the model. ModelVersionInfo \u00b6 Defines a model version and associated user data. message ModelVersionInfo { string model_id = 1; uint32 version_number = 2; fixed64 creation_timestamp = 3; bool archived = 4; string data_hash = 5; fixed64 data_size = 6; map<string, string> user_data = 7; } model_id : Unique identifier, within the registry, of this version's model. version_number : Unique version number, assigned incrementally at creation by the model registry. creation_timestamp : When the model was created as nanosecond Unix epoch time. archived : If true , this version is archived and should be stored in a long-term storage. If false , this version is not archived and can be evicted after a while. Non-archived versions should be used to broadcast an update of the model during training. data_hash : SHA 256 hash (encoded in base64 with standard 64 characters with padding) of this version's data, can be used to validate the data and for caching purposes. data_size : Size (in bytes) of this version's data. user_data : Key/value user data associated with the model, in particular it can be used to provide information required for the deserialization of the data. Trial Datastore API \u00b6 This API is defined in trial_datastore.proto . It is implemented by cogment-trial-datastore . Service TrialDatastoreSP \u00b6 This gRPC API defines a service to manage and access data generated by trials. service TrialDatastoreSP { rpc RetrieveTrials(RetrieveTrialsRequest) returns (RetrieveTrialsReply) {} rpc RetrieveSamples(RetrieveSamplesRequest) returns (stream RetrieveSampleReply) {} rpc AddTrial(AddTrialRequest) returns (AddTrialReply) {} rpc AddSample(stream AddSampleRequest) returns (AddSamplesReply) {} rpc DeleteTrials(DeleteTrialsRequest) returns (DeleteTrialsReply) {} } RetrieveTrials() \u00b6 Retrieve stored trials matching the given request. Metadata: None Request: RetrieveTrialsRequest Reply: RetrieveTrialsRequest RetrieveSamples() \u00b6 Retrieve samples from matching trials, trials can be ongoing. Metadata: None Request: RetrieveSamplesRequest Reply: Stream of RetrieveSampleReply AddTrial() \u00b6 Add a trial to the activity logger, as soon as a trial is added, samples can be retrieved using RetrieveSamples() . Metadata: None Request: AddTrialRequest Reply: AddTrialReply AddSample() \u00b6 Add samples to a trial in the activity logger as a stream, as soon as a sample is added it is pushed to the matching ongoing RetrieveSamples() requests. Metadata: trial-id : UUID of the trial to add to the activity logger. Request: Stream of AddSampleRequest Reply: AddSamplesReply DeleteTrials() \u00b6 Delete the trials matching the given request, on failure no trial is deleted. Metadata: None Request: DeleteTrialsRequest Reply: DeleteTrialsReply StoredTrialInfo \u00b6 Defines a information about a stored trial message StoredTrialInfo { string trial_id = 1; TrialState last_state = 2; string user_id = 3; uint32 samples_count = 4; TrialParams params = 5; } trial_id : Unique identifier of the trial. last_state : Last known trial state . user_id : The id of the user that has started the trial. samples_count : The number samples that are stored for this trial. params : Parameters of the trial . StoredTrialSample \u00b6 Represents a sample generated by a trial at a given tick. message StoredTrialSample { string user_id = 1; string trial_id = 2; uint64 tick_id = 3; fixed64 timestamp = 4; TrialState state = 5; repeated StoredTrialActorSample actor_samples = 6; repeated bytes payloads = 7; } user_id : The identifier of the user that has started the trial. trial_id : Unique identifier of the trial. tick_id : Tick of this sample. timestamp : Time of the sample. state : Trial state of the sample. actor_samples : Sample data related to each actor . payloads : Serialized payload for the actors observations, actions, rewards and messages during this sample. StoredTrialActorSample \u00b6 Represents a sample generated by an actor in a trial at a given tick, only makes sense as a part of a StoredTrialSample . Actors are referenced by their index in the trial params TrialParams.actors field. Where it make sense, the actor index can be set to -1 to reference the trial's environment. Payloads (ie observations data, actions data, reward user data and messages payloads) are grouped in the payloads field of StoredTrialSample and referenced by their index in this field. message StoredTrialActorSample { uint32 actor = 1; optional uint32 observation = 2; optional uint32 action = 3; optional float reward = 4; repeated StoredTrialActorSampleReward received_rewards = 6; repeated StoredTrialActorSampleReward sent_rewards = 7; repeated StoredTrialActorSampleMessage received_messages = 8; repeated StoredTrialActorSampleMessage sent_messages = 9; } actor : The index of the actor. observation : Observation received by the actor at the current tick, as an index of the observation payload in the parent StoredTrialSample . action : Action performed by the actor at the current tick, as an index of the action payload in the parent StoredTrialSample reward : Aggregated value of the rewards received by the actor for the current tick. received_rewards : List of the rewards received by the actor for the current tick. sent_rewards : List of the rewards sent by the actor for the current tick. received_messages : List of the messages received by the actor between the current tick and the next. sent_messages : List of the messages sent by the actor between the current tick and the next. StoredTrialActorSampleReward \u00b6 Represents a reward sent or received by an actor, only makes sense as a part of a StoredTrialActorSample . message StoredTrialActorSampleReward { int32 sender = 1; int32 receiver = 2; float reward = 4; float confidence = 5; optional uint32 user_data = 6; } sender : Index of the actor, -1 for the environment, ignored for sent rewards. receiver : Index of the actor, -1 for the environment, received for sent rewards. reward : The numerical value of the provided reward. confidence : The weight of this reward in computing the final (aggregated) reward. user_data : User data attached to the reward, as an index of the payload in the parent StoredTrialSample . StoredTrialActorSampleMessage \u00b6 Represents a message sent or received by an actor, only makes sense as a part of a StoredTrialActorSample . message StoredTrialActorSampleMessage { int32 sender = 1; int32 receiver = 2; uint32 payload = 3; } sender : Index of the actor, -1 for the environment, ignored for sent messages. receiver : Index of the actor, -1 for the environment, received for sent messages. payload : Payload of the message, as an index of the payload in the parent StoredTrialSample . StoredTrialSampleField \u00b6 Enums representing the fields available in a StoredTrialSample . Used to filter desired fields. enum StoredTrialSampleField { STORED_TRIAL_SAMPLE_FIELD_UNKNOWN = 0; STORED_TRIAL_SAMPLE_FIELD_OBSERVATION = 1; STORED_TRIAL_SAMPLE_FIELD_ACTION = 2; STORED_TRIAL_SAMPLE_FIELD_REWARD = 3; STORED_TRIAL_SAMPLE_FIELD_RECEIVED_REWARDS = 4; STORED_TRIAL_SAMPLE_FIELD_SENT_REWARDS = 5; STORED_TRIAL_SAMPLE_FIELD_RECEIVED_MESSAGES = 6; STORED_TRIAL_SAMPLE_FIELD_SENT_MESSAGES = 7; } RetrieveTrialsRequest \u00b6 Request for TrialDatastoreSP.RetrieveTrials() . message RetrieveTrialsRequest { repeated string trial_ids = 1; uint32 timeout = 2; uint32 trials_count = 3; string trial_handle = 4; } trial_ids : List of desired trial identifiers, if empty all trials are returned. timeout : (optional - in ms) Wait for trials that might be created within this duration. trials_count : (optional) The desired number of trials to be retrieved, leave empty (or set to 0) for no limit. trial_handle : (optional) Leave empty for the initial request, use previously provided RetrieveTrialsReply.next_trial_handle on the next calls to retrieve the next versions. RetrieveTrialsReply \u00b6 Reply for TrialDatastoreSP.RetrieveTrials() . message RetrieveTrialsReply { repeated StoredTrialInfo trial_infos = 1; string next_trial_handle = 2; } version_infos : At most RetrieveVersionInfosRequest.versions_count versions. next_version_handle : Opaque handle to be used to retrieve the next versions matching the request. RetrieveSamplesRequest \u00b6 Request for TrialDatastoreSP.RetrieveSamples() . message RetrieveSamplesRequest { repeated string trial_ids = 1; repeated string actor_names = 2; repeated string actor_classes = 3; repeated string actor_implementations = 4; repeated StoredTrialSampleField selected_sample_fields = 5; } trial_ids : List of desired trial ids, if empty no data will be returned. actor_names : List of desired actor names, if empty all actor samples will be returned. actor_classes : List of desired actor names, if empty all actor samples will be returned. actor_implementations : List of desired actor classes, if empty all actor samples will be returned. selected_sample_fields : (optional) Which fields of StoredTrialSample.ActorSample should be returned, if empty all fields are returned. RetrieveSampleReply \u00b6 Part of the reply stream of TrialDatastoreSP.RetrieveSamples() . message RetrieveSampleReply { StoredTrialSample trial_sample = 1; } trial_sample : One trial sample matching the requested trial_ids and filtered according to the desired actors and fields. AddTrialRequest \u00b6 Request for TrialDatastoreSP.AddTrial() . message AddTrialRequest { string user_id = 1; TrialParams trial_params = 2; } user_id : The ID of the user that is adding the trial. trial_params : Parameters of the trial . AddTrialReply \u00b6 Reply for TrialDatastoreSP.AddTrial() . message AddTrialReply {} AddSampleRequest \u00b6 Part of the request stream of TrialDatastoreSP.AddSample() . message AddSampleRequest { StoredTrialSample trial_sample = 1; } trial_sample : One trial sample that should match the parameters of the target trial. AddSamplesReply \u00b6 Reply for TrialDatastoreSP.AddSample() . message AddSamplesReply {} DeleteTrialsRequest \u00b6 Request for TrialDatastoreSP.DeleteTrials() . message DeleteTrialsRequest { repeated string trial_ids = 1; } trial_ids : List of the trial ids to delete, if empty no trial is deleted. DeleteTrialsReply \u00b6 Reply for TrialDatastoreSP.DeleteTrials() . message DeleteTrialsReply {}","title":"gRPC API Reference"},{"location":"cogment/cogment-low-level-api-guide/grpc/#cogment-grpc-api-v2","text":"The low-level cogment communication API is implemented using gRPC services. These services are collections of procedures to be called remotely (RPC). gRPC abstracts the network communication with familiar looking functions (representing the defined procedures), in any number of programming languages. How services are implemented or accessed is highly dependant on the programming language being interfaced, and is beyond the scope of this document (see gRPC API documentation). This reference requires a basic understanding of gRPC, and in particular the format of the *.proto files.","title":"Cogment gRPC API v2"},{"location":"cogment/cogment-low-level-api-guide/grpc/#general","text":"In this API, the bytes data type is normally used to contain the serialized data of externally defined messages. These messages are well defined in the trial specifications file. On the other hand, the google.protobuf.Any data type is normally used to contain messages that are not pre-defined (thus unknown by the framework), and may be decided at runtime. It is then the responsibility of the receiver to deserialize in the correct message type. Empty messages are normally used as a placeholder for easy future, backward compatible, extension to the API. In this API, gRPC metadata is normally used only for service request (by the caller) for identifying purposes. The details of the required metadata are described with the service calls. Service replies (the callees) are not expected to provide metadata. In some places in the API, we use a list of actor data without information about which actor is where in the list. These lists have a constant length and order throughout a trial (set in the trial parameters), and thus can/must be cross referenced with other such lists within the same trial (e.g. actors_in_trial , actors_map ). The actor can be infered by the position in the list, and the index into the list can sometimes be used to identify an actor. gRPC service names in Cogment are suffixed with \"SP\" (Service Point).","title":"General"},{"location":"cogment/cogment-low-level-api-guide/grpc/#limitations","text":"Due to normal network delays and unpredictability of the various components, there are limitations related to the communication with the Ochestrator that translate in issues that can arise. In the current version, to simplify the implementation, there is an expectation of \"good behavior\" from the various components: Actors are expected to respond with an action only after receiving an observation, and to send only one action per observation received. The environment is expected to respond with an observation set only after receiving an action set, and to send only one observation set per action set received (and one initial observation set). All components are expected to respond within a reasonable amount of time. Hooks do not assume to receive specific parameters, they reply only with well formed parameters, and they do not assume a specific order of hooks being called (when multiple hooks are defined). A TerminateTrial (from the Control API) is called only a reasonable delay after a StartTrial (e.g. after at least two ticks have executed). Note that what constitutes a \"reasonable\" amount of time is dependent on many variables.","title":"Limitations"},{"location":"cogment/cogment-low-level-api-guide/grpc/#common-types","text":"Most of the messages are defined in the common.proto file. ObservationSet and ActionSet are defined in environment.proto .","title":"Common types"},{"location":"cogment/cogment-low-level-api-guide/grpc/#common-values","text":"Some values (and their standardized names) are recurrent throughout the gRPC API. tick_id: (uint64/sint64) The monotonic time, in number of steps, since the start of the trial. As an ID, it represents a discrete step in the processing of the trial. A step starts with observations representing a specific point in time, that are followed by actions, rewards and messages in relation to these observations. The first tick ID is 0. Some of these values may accept -1, meaning the latest step (e.g. when sending an action). timestamp: (fixed64) The wall-clock time in nanoseconds since 00:00:00UTC January 1, 1970 (Unix Epoch time). trial_id: (string) The identifier (name) of the trial.","title":"Common Values"},{"location":"cogment/cogment-low-level-api-guide/grpc/#versionrequest","text":"Empty message to serve as the request for the Version procedure (present in all gRPC services defined in the Cogment API). message VersionRequest {}","title":"VersionRequest"},{"location":"cogment/cogment-low-level-api-guide/grpc/#versioninfo","text":"Reply message for the Version procedure (present in all gRPC services defined in the API). It contains a list of version information. The Cogment framework expects at least \"cogment-api\" and \"grpc\" versions to be present in the list. The \"cogment-api\" is for the local version of the Cogment API used by the service. The \"grpc\" is for the version of gRPC used by the service. Other reported versions are specific to the service called, possibly for use by utility and management tools. message Version { string name = 1; string version = 2; } message VersionInfo { repeated Version versions = 1; } versions: List of version information name: The name/software/module for which the version is given. E.g. \"cogment-api\" version: The version related to the name. E.g. \"1.0.0b5\"","title":"VersionInfo"},{"location":"cogment/cogment-low-level-api-guide/grpc/#trialparams","text":"Global parameters for a trial. message TrialParams { TrialConfig trial_config = 1; DatalogParams datalog = 2; EnvironmentParams environment = 3; repeated ActorParams actors = 4; uint32 max_steps = 5; uint32 max_inactivity = 6; } trial_config: (optional) The user config for the controller of the trial. Will be sent to pre-trial hooks. datalog: (optional) The parameters for the datalog of the trial. If not present, data logging is disabled. environment: The parameters for the environment of the trial. actors: The parameters for all actors involved in the trial. This list's length and order define the length and order of the lists of actors provided in different places in the API (e.g. actors_in_trial ) for the trial. max_steps: The maximum number of steps/ticks that the trial should run. After this number of steps/ticks, an end request will be sent to the environment. max_inactivity: The maximum amount of time (in seconds) that the trial should be without activity before it is forcefully terminated. \"Activity\" is defined as a message received by the Orchestrator from a user component.","title":"TrialParams"},{"location":"cogment/cogment-low-level-api-guide/grpc/#datalogparams","text":"Parameters related to the data logger. message DatalogParams { string endpoint = 1; repeated string exclude_fields = 2; } endpoint: The URL where the data logger is being served. This is used by the Orchestrator to connect to the datalog using the LogExporterSP gRPC service. exclude_fields: A list of fields from DatalogSample to not send to the data logger.","title":"DatalogParams"},{"location":"cogment/cogment-low-level-api-guide/grpc/#environmentparams","text":"Parameters related to an environment. message EnvironmentParams { string endpoint = 1; EnvironmentConfig config = 2; string implementation = 3; } endpoint: The URL where the environment is being served. This is used by the Orchestrator to connect to the environment using the EnvironmentSP gRPC service. config: (optional) The user config for the environment. implementation: (optional) The name of the implementation of the environment to run. If not provided, an arbitrary implementation will be chosen.","title":"EnvironmentParams"},{"location":"cogment/cogment-low-level-api-guide/grpc/#actorparams","text":"Parameters related to an actor. message ActorParams { string name = 1; string actor_class = 2; string endpoint = 3; string implementation = 4; ActorConfig config = 5; } name: The name of the actor. actor_class: The name of the class of the actor. For a particular trial, the possible actor classes are defined in the spec file in the actor_classes:name sections. endpoint: The URL where the actor is being served, or \"cogment://client\". The URL is used by the Orchestrator to connect to the actor using the ServiceActorSP gRPC service. If set to \"cogment://client\", then the actor is a client and will connect to the Orchestrator instead, using the ClientActorSP gRPC service. implementation: (optional) The name of the implementation of the actor class to run. If not provided, an arbitrary implementation will be chosen. config: (optional) The user config for the actor.","title":"ActorParams"},{"location":"cogment/cogment-low-level-api-guide/grpc/#trialconfig-actorconfig-environmentconfig","text":"These contain the config data for various user components. message TrialConfig { bytes content = 1; } message EnvironmentConfig { bytes content = 1; } message ActorConfig { bytes content = 1; } content: The serialized protobuf message representing a config. For a particular trial, the actual message type is defined in the spec file in its respective section: trial:config_type , environment:config_type , and actor_classes:config_type . The trial config is given when starting a trial, and is for use by pre-trial hooks. The environment config is set by pre-trial hooks, and is for use by the environment. The actors configs are set by the pre-trial hooks, and are for use by actors (each actor class can have a different config type).","title":"TrialConfig, ActorConfig, EnvironmentConfig"},{"location":"cogment/cogment-low-level-api-guide/grpc/#trialactor","text":"Details of an actor participating in a trial. message TrialActor { string name = 1; string actor_class = 2; } name: The name of the actor. actor_class: The name of the class of actor. For a particular trial, the possible actor classes are defined in the the spec file in the actor_classes:name sections.","title":"TrialActor"},{"location":"cogment/cogment-low-level-api-guide/grpc/#observation","text":"A singular observation. message Observation { uint64 tick_id = 1; fixed64 timestamp = 2; bytes content = 3; } tick_id: Tick of this observation. timestamp: The time of the observation. content: The serialized protobuf message representing an observation for a specific actor. In a particualr trial, the actual message type for the observation space is defined in the spec file for each actor class in section actor_classes:observation:space . Note that the specific actor represented is defined by the enclosing message.","title":"Observation"},{"location":"cogment/cogment-low-level-api-guide/grpc/#action","text":"Data associated with an actor's action. message Action { uint64 tick_id = 1; fixed64 timestamp = 2; bytes content = 3; } tick_id: The tick of the observation on which the action is taken. timestamp: The time of the action. content: The serialized protobuf message representing an action from a specific actor. In a particular trial, the actual message type for the action space is defined in the spec file for each actor class in section actor_classes:action:space . Note that the specific actor represented is defined by the enclosing message.","title":"Action"},{"location":"cogment/cogment-low-level-api-guide/grpc/#message","text":"Data associated with a communication (message) destined for an actor or the environment. message Message { sint64 tick_id = 1; string sender_name = 2; string receiver_name = 3; google.protobuf.Any payload = 4; } tick_id: Tick associated with the message. sender_name: The name of the sending actor/environment. This is optional when sending messages (i.e. the sender is already known). receiver_name: The name of the target/receiving actor/environment. payload: Data for the target actor/environment. It is the responsibility of the target to understand the type received.","title":"Message"},{"location":"cogment/cogment-low-level-api-guide/grpc/#rewardsource","text":"Data representing a simple reward source made by a single component/sender, usually for the purpose of training automated agents. message RewardSource { string sender_name = 1; float value = 2; float confidence = 3; google.protobuf.Any user_data = 4; } sender_name: Name of the sender that sent the reward. This is not needed when sending because it will be set by the orchestrator. It is only used by receiving actors. value: The numerical value of the provided reward. confidence: The weight of this reward in computing the final (aggregated) reward. user_data: Additional user data to be consumed by the receiving actor. It is the responsibility of the receiver to understand the type received.","title":"RewardSource"},{"location":"cogment/cogment-low-level-api-guide/grpc/#reward","text":"Data representing a reward sent or received, usually for the purpose of training automated agents. This is an aggregate of possibly multiple RewardSource (but at least one). message Reward { sint64 tick_id = 1; string receiver_name = 2; float value = 3; repeated RewardSource sources = 4; } tick_id: The tick associated with the reward. If set to -1 when sending a reward, the orchestrator will automatically assign the latest tick. This will always be a valid tick (i.e. >= 0) when receiving a reward. receiver_name: Name of the receiving actor (the reward destination). value: The aggregated value (weighted sum) of the provided reward sources. May be ignored when sending a reward; The final value will be computed by the orchestrator. sources: The simple reward sources that form this aggregated reward. There must be at least one.","title":"Reward"},{"location":"cogment/cogment-low-level-api-guide/grpc/#observationset","text":"A set of environment observations for all actors in the trial. message ObservationSet { uint64 tick_id = 1; fixed64 timestamp = 2; repeated bytes observations = 3; repeated int32 actors_map = 4; } tick_id: The tick to which the observations relate to. timestamp: The time when the observation set was made. observations: A list of observations. Indexed into by the actors_map . Each bytes chunk is a serialized protobuf message representing an observation for a specific actor class. For a particular trial, the actual message type for the observation space is defined in the spec file for each actor class in section actor_classes:observation:space . Note that the specific actor represented is defined by the actors_map . actors_map: A list of indexes into the observations list above. This list of indexes has the same length and order as the list of actors provided in different places in the API (e.g. actors_in_trial ), for the same trial.","title":"ObservationSet"},{"location":"cogment/cogment-low-level-api-guide/grpc/#actionset","text":"A set of actions from all actors in the trial. message ActionSet { uint64 tick_id = 1; fixed64 timestamp = 2; repeated bytes actions = 3; } tick_id: The tick to which the actions relate to. timestamp: The time when the action set was made (usually after the last action arrived at the Orchestrator). actions: A list of actions. Each bytes chunk is a serialized protobuf message representing an action from a specific actor. For an particular trial, the actual message type for the action space is defined in the spec file for each actor class in section actor_classes:action:space . This list has the same length and order as the list of actors provided in different places in the API (e.g. actors_in_trial ), for the same trial.","title":"ActionSet"},{"location":"cogment/cogment-low-level-api-guide/grpc/#trialstate","text":"Enum representing the state of a trial. enum TrialState { UNKNOWN = 0; INITIALIZING = 1; PENDING = 2; RUNNING = 3; TERMINATING = 4; ENDED = 5; } UNKNOWN: Should not be used (it's a requirement of protobuf enums to have a 0 default value). INITIALIZING: The trial is in the process of starting. PENDING: The trial is waiting for its final parameters, before running. RUNNING: The trial is running. TERMINATING: The trial is in the process of terminating (either a request to terminate has been received or the last observation has been received). ENDED: The trial has ended. Only a set number of ended trials will be kept (configured in the Orchestrator).","title":"TrialState"},{"location":"cogment/cogment-low-level-api-guide/grpc/#communicationstate","text":"Enum representing the state of communication with the actors and environment. enum CommunicationState { UNKNOWN_COM_STATE = 0; NORMAL = 1; HEARTBEAT = 2; LAST = 3; LAST_ACK = 4; END = 5; } UNKNOWN_COM_STATE: Should not be used (it's a requirement of protobuf enums to have a 0 default value). NORMAL: Normal communication message. Always contains data. HEARTBEAT: Heartbeat request/reply message. Contains no data. When received, must be responded in kind. LAST: Message indicating that the trial is ending, and ending data is following (as NORMAL ). Contains no data. LAST_ACK: Message indicating that the last data has been sent (i.e. this is the last outgoing message). Contains no data. END: Message indicating that the trial has ended (i.e. this is the final message). Contains no data, except maybe for details . The normal (soft) end of a trial follows this sequence : Orchestrator or Environment sends LAST Exchange of NORMAL finalizing data Component sends LAST_ACK (component stops sending after this) Orchestrator sends NORMAL finalizing data Orchestrator terminates communication with END For a hard termination of a trial, the Orchestrator will send END to all components (with no LAST / LAST_ACK handshake).","title":"CommunicationState"},{"location":"cogment/cogment-low-level-api-guide/grpc/#control-api","text":"This API is defined in orchestrator.proto . It is implemented by the cogment orchestrator, and client applications are expected to connect to it using the gRPC client API. This API is used for general control and services related to trials.","title":"Control API"},{"location":"cogment/cogment-low-level-api-guide/grpc/#service-triallifecyclesp","text":"service TrialLifecycleSP { rpc StartTrial(TrialStartRequest) returns (TrialStartReply) {} rpc TerminateTrial(TerminateTrialRequest) returns (TerminateTrialReply) {} rpc GetTrialInfo(TrialInfoRequest) returns (TrialInfoReply) {} rpc WatchTrials(TrialListRequest) returns (stream TrialListEntry) {} rpc Version(VersionRequest) returns (VersionInfo) {} }","title":"Service TrialLifecycleSP"},{"location":"cogment/cogment-low-level-api-guide/grpc/#starttrial","text":"Start a new trial. Metadata: None","title":"StartTrial()"},{"location":"cogment/cogment-low-level-api-guide/grpc/#terminatetrial","text":"Request the environment to terminate existing trial(s). Metadata: trial-id : ( one or more ) Identifier(s) of the trial(s) to terminate.","title":"TerminateTrial()"},{"location":"cogment/cogment-low-level-api-guide/grpc/#gettrialinfo","text":"Get extra information about an existing trial. Metadata: trial-id : ( zero or more ) Identifier(s) of the trial(s) we are requesting information about. If no trial id is provided, the request is for information about all active trials.","title":"GetTrialInfo()"},{"location":"cogment/cogment-low-level-api-guide/grpc/#watchtrials","text":"Stream state changes from trials. Metadata: None","title":"WatchTrials()"},{"location":"cogment/cogment-low-level-api-guide/grpc/#version","text":"Request version data. Metadata: None","title":"Version()"},{"location":"cogment/cogment-low-level-api-guide/grpc/#trialstartrequest","text":"Request message for the StartTrial procedure. message TrialStartRequest { TrialConfig config = 1; string user_id = 2; string trial_id_requested = 3; } config: The trial config data. This data can be used by the pre-trial hooks to determine the config for the rest of the componenents. user_id: The ID of the user that is starting the trial. trial_id_requested: The trial identifier requested for the new trial. It must be unique. If not empty, the Orchestrator will try to use this trial_id, otherwise, a UUID will be created.","title":"TrialStartRequest"},{"location":"cogment/cogment-low-level-api-guide/grpc/#trialstartreply","text":"Reply message for the StartTrial procedure. message TrialStartReply { string trial_id = 1; } trial_id: ID of the newly started trial. Empty if the requested trial ID could not be used.","title":"TrialStartReply"},{"location":"cogment/cogment-low-level-api-guide/grpc/#terminatetrialrequest","text":"Request message for the TerminateTrial procedure. message TerminateTrialRequest {}","title":"TerminateTrialRequest"},{"location":"cogment/cogment-low-level-api-guide/grpc/#terminatetrialreply","text":"Reply message for the TerminateTrial procedure. message TerminateTrialReply {}","title":"TerminateTrialReply"},{"location":"cogment/cogment-low-level-api-guide/grpc/#trialinforequest","text":"Request message for the GetTrialInfo procedure. message TrialInfoRequest { bool get_latest_observation = 1; } get_latest_observation: If true, request the latest environment observation available for the trial (in addition to standard information).","title":"TrialInfoRequest"},{"location":"cogment/cogment-low-level-api-guide/grpc/#trialinforeply","text":"Reply message for the GetTrialInfo procedure. message TrialInfoReply { repeated TrialInfo trial = 1; } trial: List of information about the trials. Contains only the requested trial info if a trial ID was provided when the call was made (as metadata to the procedure). Otherwise contains information about all active trials.","title":"TrialInfoReply"},{"location":"cogment/cogment-low-level-api-guide/grpc/#trialinfo","text":"Message containing information about a trial. message TrialInfo { string trial_id = 1; string env_name = 2; TrialState state = 3; uint64 tick_id = 4; fixed64 trial_duration = 5; ObservationSet latest_observation = 6; repeated TrialActor actors_in_trial = 7; } trial_id: The Identifier of the trial. env_name: The name of the environment running the trial. state: The state of the trial. tick_id: The current tick of the trial. trial_duration: The duration of the trial so far, in nanoseconds. If the trial has ended, this is the duration from start to end of the trial. This is meant as an indicator; resolution may not be a nanosecond, and precision is not guaranteed. latest_observation: The latest environment observations for all actors. This will be provided only if requested in the TrialInfoRequest . actors_in_trial: The list of active actors in the trial.","title":"TrialInfo"},{"location":"cogment/cogment-low-level-api-guide/grpc/#triallistrequest","text":"Request message for the WatchTrials procedure. message TrialListRequest { repeated TrialState filter = 1; } filter: The list of states that are requested. If a trial is not in a state found in this list, it will not be reported. If the list is empty, all states will be reported.","title":"TrialListRequest"},{"location":"cogment/cogment-low-level-api-guide/grpc/#triallistentry","text":"Stream reply message for the WatchTrials procedure. message TrialListEntry { string trial_id = 1; TrialState state = 2; } trial_id: The Identifier of the trial. state: The state of the trial.","title":"TrialListEntry"},{"location":"cogment/cogment-low-level-api-guide/grpc/#actor-api","text":"There are two kinds of actors: Service and Client. They each have their own separate service (respectively ServiceActorSP and ClientActorSP ). But the messages are identical and work almost the same way (except for the initial phase).","title":"Actor API"},{"location":"cogment/cogment-low-level-api-guide/grpc/#service-actor-api","text":"This API is defined in agent.proto . It is implemented by the service actor application using the gRPC server API, and the Orchestrator connects to the service actor application using the gRPC client API. This API is used by service actors that will be participating in new trials. They are connected at the start of a trial in which they participate. Multiple simultaneous service actors can be served from a single service application instance (i.e. same endpoint). An actor endpoint, for the Orchestrator to connect to, is defined in the trial parameters .","title":"Service Actor API"},{"location":"cogment/cogment-low-level-api-guide/grpc/#service-serviceactorsp","text":"service ServiceActorSP { rpc RunTrial(stream ActorRunTrialInput) returns (stream ActorRunTrialOutput) {} rpc Version(VersionRequest) returns (VersionInfo) {} }","title":"Service ServiceActorSP"},{"location":"cogment/cogment-low-level-api-guide/grpc/#client-actor-api","text":"This API is defined in orchestrator.proto . It is implemented by the Orchestrator using the gRPC server API, and client applications are expected to connect to the Orchestrator using the gRPC client API. This API is used by client actors participating in existing (initializing) trials. The trial expecting client actors will wait for all actors to be connected before starting the trial. The actors connecting this way must have an endpoint set to \"cogment://client\" in the trial parameters . Note the reversal of the input and output messages compared to the service actor RunTrial procedure.","title":"Client Actor API"},{"location":"cogment/cogment-low-level-api-guide/grpc/#service-clientactorsp","text":"service ClientActorSP { rpc RunTrial(stream ActorRunTrialOutput) returns (stream ActorRunTrialInput) {} rpc Version(VersionRequest) returns (VersionInfo) {} }","title":"Service ClientActorSP"},{"location":"cogment/cogment-low-level-api-guide/grpc/#runtrial","text":"Procedure call to participate in a trial. It is active for the duration of the trial. Actor actions and data are provided to the Orchestrator in the output message stream, and observations and data are provided by the Orchestrator in the input message stream. Metadata: trial-id : Identifier of the trial the actor is participating in. This is supplied to service actors, but must be supplied by client actors.","title":"RunTrial()"},{"location":"cogment/cogment-low-level-api-guide/grpc/#version_1","text":"Request version data. Metadata: None","title":"Version()"},{"location":"cogment/cogment-low-level-api-guide/grpc/#actorruntrialinput","text":"Message received by actors during the streaming RunTrial procedure. data should contain a message only when state is NORMAL (or in the case of a hard termination, details can be sent with state END ). Defined in the common.proto file. message ActorRunTrialInput { CommunicationState state = 1; oneof data { ActorInitialInput init_input = 2; Observation observation = 3; Reward reward = 4; Message message = 5; string details = 6; } } state: The state of this communication message. Identifies this message as a data or a control message. init_input: The initial communication data at the start of a trial. It should always be the first NORMAL state message in the stream. Used to report the details of the trial the actor is participating in. observation: An observation from the environment. reward: Rewards from other participants in the trial. message: A message from other participants in the trial. details: Explanation for special circumstances, for example when receiving a hard termination signal (a state of END without LAST or LAST_ACK ).","title":"ActorRunTrialInput"},{"location":"cogment/cogment-low-level-api-guide/grpc/#actorruntrialoutput","text":"Message sent by actors during the streaming RunTrial procedure. data should contain a message only when state is NORMAL . Defined in the common.proto file. message ActorRunTrialOutput { CommunicationState state = 1; oneof data { ActorInitialOutput init_output = 2; Action action = 3; Reward reward = 4; Message message = 5; string details = 6; } } state: The state of this communication message. Identifies this message as a data or a control message. init_output: The initial communication data at the start of a trial. It should always be the first NORMAL state message in the stream. Used to initiate or acknowledge connection to a trial. action: An action from the actor. reward: A reward for other participants in the trial. message: A message for other participants in the trial. details: Reserved .","title":"ActorRunTrialOutput"},{"location":"cogment/cogment-low-level-api-guide/grpc/#actorinitialinput","text":"The initial communication message at the start of a trial. Used to report the details of the trial the actor is participating in. For service actors, this message initiates the connection stream for a new trial. The trial ID is provided in the metadata of the RunTrial procedure. For client actors, this message is a reply to a connection request to an existing trial. message ActorInitialInput { string actor_name = 1; string actor_class = 2; string impl_name = 3; string env_name = 4; ActorConfig config = 5; } actor_name: The name of the actor participating in the trial. actor_class: The actor class of the actor participating in the trial. impl_name: (optional) Name of the implementation that should run the actor in this trial. If not provided, an arbitrary implementation will be used. env_name: The name of the environment running the trial the actor is participating in. config: The configuration to start the actor.","title":"ActorInitialInput"},{"location":"cogment/cogment-low-level-api-guide/grpc/#actorinitialoutput","text":"The initial communication message at the start of a trial. Used to initiate or acknowledge connection to a trial. For service actors, this message is empty and serves to acknowledge that the actor is ready to start the trial. For client actors, this message serves as a request to connect to an existing trial. The trial ID is provided in the metadata of the RunTrial procedure. message ActorInitialOutput { oneof slot_selection { string actor_class = 1; string actor_name = 2; } } actor_name: The name in the trial that the client actor wants to participate as. actor_class: The class in the trial that the client actor wants to participate as. In this case, there may be many options, and the Orchestrator will decide precisely which name the client actor will receive.","title":"ActorInitialOutput"},{"location":"cogment/cogment-low-level-api-guide/grpc/#environment-api","text":"This API is defined in environment.proto . It is implemented by the environment application using the gRPC server API, and the Orchestrator connects to the environment application using the gRPC client API. This API is used by environments that will run trials. There is only one environment per trial. Multiple simultaneous environments (for different trials) can be served from a single environment application instance (endpoint). The environment endpoint, for the Orchestrator to connect to, is defined in the trial parameters .","title":"Environment API"},{"location":"cogment/cogment-low-level-api-guide/grpc/#service-environmentsp","text":"service EnvironmentSP { rpc RunTrial(stream EnvRunTrialInput) returns (stream EnvRunTrialOutput) {} rpc Version(VersionRequest) returns (VersionInfo) {} }","title":"Service EnvironmentSP"},{"location":"cogment/cogment-low-level-api-guide/grpc/#runtrial_1","text":"Procedure call to participate in a trial. It is active for the duration of the trial. Actor actions and data are provided by the Orchestrator in the input message stream, and observations and data are provided to the Orchestrator in the output message stream. Metadata: trial-id : Identifier of the trial the environment is participating in.","title":"RunTrial()"},{"location":"cogment/cogment-low-level-api-guide/grpc/#version_2","text":"Called to request version data. Metadata: None","title":"Version()"},{"location":"cogment/cogment-low-level-api-guide/grpc/#envrruntrialinput","text":"Message received by the environment during the streaming RunTrial procedure. data should contain a message only when state is NORMAL (or in the case of a hard termination, details can be sent with state END ). message EnvRunTrialInput { CommunicationState state = 1; oneof data { EnvInitialInput init_input = 2; ActionSet action_set = 3; Message message = 4; string details = 5; } } state: The state of this communication message. Identifies this message as a data or a control message. init_input: The initial communication data at the start of a trial. It should always be the first NORMAL state message in the stream. Used to provide the details of the trial the environment will run. action_set: Actions from all actors in the trial. message: A message from other participants in the trial. details: Explanation for special circumstances, for example when receiving a hard termination signal (a state of END without LAST or LAST_ACK ).","title":"EnvrRunTrialInput"},{"location":"cogment/cogment-low-level-api-guide/grpc/#envruntrialoutput","text":"Message sent by the environment during the streaming RunTrial procedure. data should contain a message only when state is NORMAL . message EnvRunTrialOutput { CommunicationState state = 1; oneof data { EnvInitialOutput init_output = 2; ObservationSet observation_set = 3; Reward reward = 4; Message message = 5; string details = 6; } } state: The state of this communication message. Identifies this message as a data or a control message. init_output: The initial communication data at the start of a trial. It should always be the first NORMAL state message in the stream. Used to acknowledge that the environment is ready to run the trial. Note that the trial will only really start when the environment sends the first set of observations. observation_set: Observations for all actors in the trial. reward: A reward for other participants in the trial. message: A message for other participants in the trial. details: Reserved .","title":"EnvRunTrialOutput"},{"location":"cogment/cogment-low-level-api-guide/grpc/#envinitialinput","text":"The initial communication message at the start of a trial. This message initiates the connection stream for a new trial. The trial ID is provided in the metadata of the RunTrial procedure. message EnvInitialInput { string name = 1; string impl_name = 2; uint64 tick_id = 3; repeated TrialActor actors_in_trial = 4; EnvironmentConfig config = 5; } name: The name of the environment participating in the trial. impl_name: (optional) Name of the implementation that should run the environment in this trial. If not provided, an arbitrary implementation will be used. tick_id: Initial tick id requested to start the environment. actors_in_trial: The list of all actors participating in the trial. This list has the same length and order as the list of actors provided in different places in the API, for the same trial. config: The configuration to start the environment.","title":"EnvInitialInput"},{"location":"cogment/cogment-low-level-api-guide/grpc/#envinitialoutput","text":"The initial communication message at the start of a trial. This message is empty and serves to acknowledge that the environment is ready to run the trial. message EnvInitialOutput {}","title":"EnvInitialOutput"},{"location":"cogment/cogment-low-level-api-guide/grpc/#datalog-api","text":"This API is defined in datalog.proto . It is implemented by the data logger application using the gRPC server API, including the out-of-the-box component cogment-trial-datastore . The data logger endpoint, for the orchestrator to connect to, is defined in the trial parameters.","title":"Data/Log API"},{"location":"cogment/cogment-low-level-api-guide/grpc/#service-logexportersp","text":"service LogExporterSP { rpc RunTrialDatalog(stream LogExporterSampleRequest) returns (LogExporterSampleReply) {} rpc Version(VersionRequest) returns (VersionInfo) {} }","title":"Service LogExporterSP"},{"location":"cogment/cogment-low-level-api-guide/grpc/#runtrialdatalog","text":"Called for each trial, at the start of the trial. The first data received are the parameters. Data samples are provided in the request stream following the parameters. The stream is maintained for the duration of the trial. Metadata: trial-id : Identifier of the trial that is the source of the data. user-id : Identifier of the user that started the trial.","title":"RunTrialDatalog()"},{"location":"cogment/cogment-low-level-api-guide/grpc/#version_3","text":"Called to request version data. Metadata: None","title":"Version()"},{"location":"cogment/cogment-low-level-api-guide/grpc/#logexportersamplerequest","text":"Stream request message for the RunTrialDatalog procedure. message SampleInfo { uint64 tick_id = 1; fixed64 timestamp = 2; TrialState state = 3; repeated string special_events = 4; } message DatalogSample { SampleInfo info = 1; ObservationSet observations = 2; repeated Action actions = 3; repeated Reward rewards = 4; repeated Message messages = 5; } message LogExporterSampleRequest { oneof msg { TrialParams trial_params = 1; DatalogSample sample = 2; } } tick_id: The current tick of the trial. timestamp: The time at the beginning of the tick. state: The state of the trial at the end of the tick. special_events: Events not visible from the rest of the data may appear in here. observations: Observations from the environment. actions: Actions from all actors. This list has the same length and order as the list of actors provided in trial_params . rewards: List of rewards sent to actors. messages: List of user data sent to actors or the environment. trial_params: Trial parameters used for a trial. This is sent on start of a trial, as the first message in the RunTrialDatalog stream. sample: A data sample to be logged.","title":"LogExporterSampleRequest"},{"location":"cogment/cogment-low-level-api-guide/grpc/#logexportersamplereply","text":"Reply message for the RunTrialDatalog procedure. message LogExporterSampleReply {}","title":"LogExporterSampleReply"},{"location":"cogment/cogment-low-level-api-guide/grpc/#hook-api","text":"This API is defined in hooks.proto . It is implemented by the pre-trial hook application using the gRPC server API, and the orchestrator connects to the application. The pre-trial hook endpoint, for the orchestrator to connect to, are defined on the command line of the Orchestrator (or in environment variables).","title":"Hook API"},{"location":"cogment/cogment-low-level-api-guide/grpc/#service-trialhookssp","text":"service TrialHooksSP { rpc OnPreTrial(PreTrialParams) returns (PreTrialParams) {} rpc Version(VersionRequest) returns (VersionInfo) {} }","title":"Service TrialHooksSP"},{"location":"cogment/cogment-low-level-api-guide/grpc/#onpretrial","text":"Called before a trial is started to set or modify the parameters for the trial. Metadata: trial-id : Identifier of the new trial that will be started. user-id : Identifier of the user that started the trial.","title":"OnPreTrial()"},{"location":"cogment/cogment-low-level-api-guide/grpc/#version_4","text":"Called to request version data. Metadata: None","title":"Version()"},{"location":"cogment/cogment-low-level-api-guide/grpc/#pretrialparams","text":"Request and reply message for the OnPreTrial procedure. message PreTrialParams { TrialParams params = 1; } params: The trial parameters so far. The first hook to be called will receive the default parameters from the Orchestrator, and subsequent hooks will receive the updated parameters from the previous hook. The last hook reply will be the final parameters to use for the new trial.","title":"PreTrialParams"},{"location":"cogment/cogment-low-level-api-guide/grpc/#model-registry-api","text":"This API is defined in model_registry.proto . It is implemented by cogment-model-registry .","title":"Model Registry API"},{"location":"cogment/cogment-low-level-api-guide/grpc/#service-modelregistrysp","text":"This gRPC API defines a service able to store versioned model, e.g. neural network architecture, weights and any additional parameters. service ModelRegistrySP { rpc CreateOrUpdateModel(CreateOrUpdateModelRequest) returns (CreateOrUpdateModelReply) {} rpc DeleteModel(DeleteModelRequest) returns (DeleteModelReply) {} rpc RetrieveModels(RetrieveModelsRequest) returns (RetrieveModelsReply) {} rpc CreateVersion(stream CreateVersionRequestChunk) returns (CreateVersionReply) {} rpc RetrieveVersionInfos(RetrieveVersionInfosRequest) returns (RetrieveVersionInfosReply) {} rpc RetrieveVersionData(RetrieveVersionDataRequest) returns (stream RetrieveVersionDataReplyChunk) {} }","title":"Service ModelRegistrySP"},{"location":"cogment/cogment-low-level-api-guide/grpc/#createorupdatemodel","text":"Create or update a model in the registry having the given unique (within the registry) model_id . Metadata: None Request: CreateOrUpdateModelRequest Reply: CreateOrUpdateModelReply","title":"CreateOrUpdateModel()"},{"location":"cogment/cogment-low-level-api-guide/grpc/#deletemodel","text":"Delete a given model and all its versions from the registry. Metadata: None Request: DeleteModelRequest Reply: DeleteModelReply","title":"DeleteModel()"},{"location":"cogment/cogment-low-level-api-guide/grpc/#retrievemodels","text":"Retrieve all or selected models. This procedure supports paginated requests. Metadata: None Request: RetrieveModelsRequest Reply: RetrieveModelsReply","title":"RetrieveModels()"},{"location":"cogment/cogment-low-level-api-guide/grpc/#createversion","text":"Create a new version of a given model. Because of their potential large size, model version data are uploaded as a stream. Metadata: None Request: Stream of CreateVersionRequestChunk Reply: CreateVersionReply","title":"CreateVersion()"},{"location":"cogment/cogment-low-level-api-guide/grpc/#retrieveversioninfos","text":"Retrieve the information for all or selected versions of a given model. Metadata: None Request: RetrieveVersionInfosRequest Reply: RetrieveVersionInfosReply","title":"RetrieveVersionInfos()"},{"location":"cogment/cogment-low-level-api-guide/grpc/#retrieveversiondata","text":"Retrieve the data for a specific version of the model. Because of their potential large size, data are retrieved as a stream. Metadata: None Request: RetrieveVersionDataRequest Reply: Stream of RetrieveVersionDataReplyChunk","title":"RetrieveVersionData()"},{"location":"cogment/cogment-low-level-api-guide/grpc/#createorupdatemodelrequest","text":"Request for ModelRegistrySP.CreateOrUpdateModel() message CreateOrUpdateModelRequest { ModelInfo model_info = 1; } model_info : Defines the unique model identifier within the registry and the user_data to use to create or update the model.","title":"CreateOrUpdateModelRequest"},{"location":"cogment/cogment-low-level-api-guide/grpc/#createorupdatemodelreply","text":"Reply for ModelRegistrySP.CreateOrUpdateModel() message CreateOrUpdateModelReply {}","title":"CreateOrUpdateModelReply"},{"location":"cogment/cogment-low-level-api-guide/grpc/#deletemodelrequest","text":"Request for ModelRegistrySP.DeleteModel() message DeleteModelRequest { string model_id = 1; } model_ids : Identifier of the model to be deleted.","title":"DeleteModelRequest"},{"location":"cogment/cogment-low-level-api-guide/grpc/#deletemodelreply","text":"Reply for ModelRegistrySP.DeleteModel() message DeleteModelReply {}","title":"DeleteModelReply"},{"location":"cogment/cogment-low-level-api-guide/grpc/#retrievemodelsrequest","text":"Request for ModelRegistrySP.RetrieveModel() . message RetrieveModelsRequest { repeated string model_ids = 1; uint32 models_count = 3; string model_handle = 4; } model_ids : List of the identifiers of the desired models, leave emtpy to retrieve all models. models_count : (optional) The desired number of models to be retrieved, leave empty (or set to 0) to retrieve all models matching the request. model_handle : (optional) Leave empty for the initial request, use previously provided RetrieveModelsReply.next_model_handle on the next calls to retrieve the next models.","title":"RetrieveModelsRequest"},{"location":"cogment/cogment-low-level-api-guide/grpc/#retrievemodelsreply","text":"Reply for ModelRegistrySP.RetrieveModel() . message RetrieveModelsReply { repeated ModelInfo model_infos = 1; string next_model_handle = 2; } model_infos : At most RetrieveModelsRequest.models_count models. next_model_handle : Opaque handle to be used to retrieve the next models matching the request.","title":"RetrieveModelsReply"},{"location":"cogment/cogment-low-level-api-guide/grpc/#createversionrequestchunk","text":"Part of the request stream for ModelRegistrySP.CreateVersion() . message CreateVersionRequestChunk { message Header { ModelVersionInfo version_info = 1; } message Body { bytes data_chunk = 1; } oneof msg { Header header = 1; Body body = 2; } } The first message in the stream should define header : version_info : Information regarding the model version to create, version_number will be ignored. data_hash and data_size should be computed from the total final data and will be used by the server to validate it. The following messages should define body : data_chunk : A chunk of the version data, all the chunks in the stream will be concatened.","title":"CreateVersionRequestChunk"},{"location":"cogment/cogment-low-level-api-guide/grpc/#createversionreply","text":"Reply for ModelRegistrySP.CreateVersion() . message CreateVersionReply { ModelVersionInfo version_info = 1; } version_info : The informations relative to the created model version, in particular the defined version_number .","title":"CreateVersionReply"},{"location":"cogment/cogment-low-level-api-guide/grpc/#retrieveversioninfosrequest","text":"Request for ModelRegistrySP.RetrieveVersionInfos() . message RetrieveVersionInfosRequest { string model_id = 1; repeated int32 version_numbers = 2; uint32 versions_count = 3; string version_handle = 4; } model_id : Identifier of the model we want to retrieve versions from. version_numbers : List of desired version number (or -1 to denote the latest version). Leave emtpy to retrieve all versions of the given model. versions_count : (optional) The desired number of versions to be retrieved, leave empty (or set to 0) to retrieve all the versions matching the request. version_handle : (optional) Leave empty for the initial request, use previously provided RetrieveVersionInfosReply.next_version_handle on the next calls to retrieve the next versions.","title":"RetrieveVersionInfosRequest"},{"location":"cogment/cogment-low-level-api-guide/grpc/#retrieveversioninfosreply","text":"Reply for ModelRegistrySP.RetrieveVersionInfos() . message RetrieveVersionInfosReply { repeated ModelVersionInfo version_infos = 1; string next_version_handle = 2; } version_infos : At most RetrieveVersionInfosRequest.versions_count versions. next_version_handle : Opaque handle to be used to retrieve the next versions matching the request.","title":"RetrieveVersionInfosReply"},{"location":"cogment/cogment-low-level-api-guide/grpc/#retrieveversiondatarequest","text":"Request for ModelRegistrySP.RetrieveVersionData() . message RetrieveVersionDataRequest { string model_id = 1; int32 version_number = 2; } model_id : Identifier of the model we want to retrieve version from. version_numbers : Number of the desired version.","title":"RetrieveVersionDataRequest"},{"location":"cogment/cogment-low-level-api-guide/grpc/#retrieveversiondatareplychunk","text":"Part of the reply stream of ModelRegistrySP.RetrieveVersionData() . message RetrieveVersionDataReplyChunk { bytes data_chunk = 1; } data_chunk : A chunk of the version data. All the chunks in the stream need to be concatened. The completeness and validity of the received data can be checked using the version's data_size and data_hash respectivelly.","title":"RetrieveVersionDataReplyChunk"},{"location":"cogment/cogment-low-level-api-guide/grpc/#modelinfo","text":"Defines a model identifier and associated user data. message ModelInfo { string model_id = 1; map<string, string> user_data = 2; } model_id : Unique model identifier. user_data : Key/value user data associated with the model.","title":"ModelInfo"},{"location":"cogment/cogment-low-level-api-guide/grpc/#modelversioninfo","text":"Defines a model version and associated user data. message ModelVersionInfo { string model_id = 1; uint32 version_number = 2; fixed64 creation_timestamp = 3; bool archived = 4; string data_hash = 5; fixed64 data_size = 6; map<string, string> user_data = 7; } model_id : Unique identifier, within the registry, of this version's model. version_number : Unique version number, assigned incrementally at creation by the model registry. creation_timestamp : When the model was created as nanosecond Unix epoch time. archived : If true , this version is archived and should be stored in a long-term storage. If false , this version is not archived and can be evicted after a while. Non-archived versions should be used to broadcast an update of the model during training. data_hash : SHA 256 hash (encoded in base64 with standard 64 characters with padding) of this version's data, can be used to validate the data and for caching purposes. data_size : Size (in bytes) of this version's data. user_data : Key/value user data associated with the model, in particular it can be used to provide information required for the deserialization of the data.","title":"ModelVersionInfo"},{"location":"cogment/cogment-low-level-api-guide/grpc/#trial-datastore-api","text":"This API is defined in trial_datastore.proto . It is implemented by cogment-trial-datastore .","title":"Trial Datastore API"},{"location":"cogment/cogment-low-level-api-guide/grpc/#service-trialdatastoresp","text":"This gRPC API defines a service to manage and access data generated by trials. service TrialDatastoreSP { rpc RetrieveTrials(RetrieveTrialsRequest) returns (RetrieveTrialsReply) {} rpc RetrieveSamples(RetrieveSamplesRequest) returns (stream RetrieveSampleReply) {} rpc AddTrial(AddTrialRequest) returns (AddTrialReply) {} rpc AddSample(stream AddSampleRequest) returns (AddSamplesReply) {} rpc DeleteTrials(DeleteTrialsRequest) returns (DeleteTrialsReply) {} }","title":"Service TrialDatastoreSP"},{"location":"cogment/cogment-low-level-api-guide/grpc/#retrievetrials","text":"Retrieve stored trials matching the given request. Metadata: None Request: RetrieveTrialsRequest Reply: RetrieveTrialsRequest","title":"RetrieveTrials()"},{"location":"cogment/cogment-low-level-api-guide/grpc/#retrievesamples","text":"Retrieve samples from matching trials, trials can be ongoing. Metadata: None Request: RetrieveSamplesRequest Reply: Stream of RetrieveSampleReply","title":"RetrieveSamples()"},{"location":"cogment/cogment-low-level-api-guide/grpc/#addtrial","text":"Add a trial to the activity logger, as soon as a trial is added, samples can be retrieved using RetrieveSamples() . Metadata: None Request: AddTrialRequest Reply: AddTrialReply","title":"AddTrial()"},{"location":"cogment/cogment-low-level-api-guide/grpc/#addsample","text":"Add samples to a trial in the activity logger as a stream, as soon as a sample is added it is pushed to the matching ongoing RetrieveSamples() requests. Metadata: trial-id : UUID of the trial to add to the activity logger. Request: Stream of AddSampleRequest Reply: AddSamplesReply","title":"AddSample()"},{"location":"cogment/cogment-low-level-api-guide/grpc/#deletetrials","text":"Delete the trials matching the given request, on failure no trial is deleted. Metadata: None Request: DeleteTrialsRequest Reply: DeleteTrialsReply","title":"DeleteTrials()"},{"location":"cogment/cogment-low-level-api-guide/grpc/#storedtrialinfo","text":"Defines a information about a stored trial message StoredTrialInfo { string trial_id = 1; TrialState last_state = 2; string user_id = 3; uint32 samples_count = 4; TrialParams params = 5; } trial_id : Unique identifier of the trial. last_state : Last known trial state . user_id : The id of the user that has started the trial. samples_count : The number samples that are stored for this trial. params : Parameters of the trial .","title":"StoredTrialInfo"},{"location":"cogment/cogment-low-level-api-guide/grpc/#storedtrialsample","text":"Represents a sample generated by a trial at a given tick. message StoredTrialSample { string user_id = 1; string trial_id = 2; uint64 tick_id = 3; fixed64 timestamp = 4; TrialState state = 5; repeated StoredTrialActorSample actor_samples = 6; repeated bytes payloads = 7; } user_id : The identifier of the user that has started the trial. trial_id : Unique identifier of the trial. tick_id : Tick of this sample. timestamp : Time of the sample. state : Trial state of the sample. actor_samples : Sample data related to each actor . payloads : Serialized payload for the actors observations, actions, rewards and messages during this sample.","title":"StoredTrialSample"},{"location":"cogment/cogment-low-level-api-guide/grpc/#storedtrialactorsample","text":"Represents a sample generated by an actor in a trial at a given tick, only makes sense as a part of a StoredTrialSample . Actors are referenced by their index in the trial params TrialParams.actors field. Where it make sense, the actor index can be set to -1 to reference the trial's environment. Payloads (ie observations data, actions data, reward user data and messages payloads) are grouped in the payloads field of StoredTrialSample and referenced by their index in this field. message StoredTrialActorSample { uint32 actor = 1; optional uint32 observation = 2; optional uint32 action = 3; optional float reward = 4; repeated StoredTrialActorSampleReward received_rewards = 6; repeated StoredTrialActorSampleReward sent_rewards = 7; repeated StoredTrialActorSampleMessage received_messages = 8; repeated StoredTrialActorSampleMessage sent_messages = 9; } actor : The index of the actor. observation : Observation received by the actor at the current tick, as an index of the observation payload in the parent StoredTrialSample . action : Action performed by the actor at the current tick, as an index of the action payload in the parent StoredTrialSample reward : Aggregated value of the rewards received by the actor for the current tick. received_rewards : List of the rewards received by the actor for the current tick. sent_rewards : List of the rewards sent by the actor for the current tick. received_messages : List of the messages received by the actor between the current tick and the next. sent_messages : List of the messages sent by the actor between the current tick and the next.","title":"StoredTrialActorSample"},{"location":"cogment/cogment-low-level-api-guide/grpc/#storedtrialactorsamplereward","text":"Represents a reward sent or received by an actor, only makes sense as a part of a StoredTrialActorSample . message StoredTrialActorSampleReward { int32 sender = 1; int32 receiver = 2; float reward = 4; float confidence = 5; optional uint32 user_data = 6; } sender : Index of the actor, -1 for the environment, ignored for sent rewards. receiver : Index of the actor, -1 for the environment, received for sent rewards. reward : The numerical value of the provided reward. confidence : The weight of this reward in computing the final (aggregated) reward. user_data : User data attached to the reward, as an index of the payload in the parent StoredTrialSample .","title":"StoredTrialActorSampleReward"},{"location":"cogment/cogment-low-level-api-guide/grpc/#storedtrialactorsamplemessage","text":"Represents a message sent or received by an actor, only makes sense as a part of a StoredTrialActorSample . message StoredTrialActorSampleMessage { int32 sender = 1; int32 receiver = 2; uint32 payload = 3; } sender : Index of the actor, -1 for the environment, ignored for sent messages. receiver : Index of the actor, -1 for the environment, received for sent messages. payload : Payload of the message, as an index of the payload in the parent StoredTrialSample .","title":"StoredTrialActorSampleMessage"},{"location":"cogment/cogment-low-level-api-guide/grpc/#storedtrialsamplefield","text":"Enums representing the fields available in a StoredTrialSample . Used to filter desired fields. enum StoredTrialSampleField { STORED_TRIAL_SAMPLE_FIELD_UNKNOWN = 0; STORED_TRIAL_SAMPLE_FIELD_OBSERVATION = 1; STORED_TRIAL_SAMPLE_FIELD_ACTION = 2; STORED_TRIAL_SAMPLE_FIELD_REWARD = 3; STORED_TRIAL_SAMPLE_FIELD_RECEIVED_REWARDS = 4; STORED_TRIAL_SAMPLE_FIELD_SENT_REWARDS = 5; STORED_TRIAL_SAMPLE_FIELD_RECEIVED_MESSAGES = 6; STORED_TRIAL_SAMPLE_FIELD_SENT_MESSAGES = 7; }","title":"StoredTrialSampleField"},{"location":"cogment/cogment-low-level-api-guide/grpc/#retrievetrialsrequest","text":"Request for TrialDatastoreSP.RetrieveTrials() . message RetrieveTrialsRequest { repeated string trial_ids = 1; uint32 timeout = 2; uint32 trials_count = 3; string trial_handle = 4; } trial_ids : List of desired trial identifiers, if empty all trials are returned. timeout : (optional - in ms) Wait for trials that might be created within this duration. trials_count : (optional) The desired number of trials to be retrieved, leave empty (or set to 0) for no limit. trial_handle : (optional) Leave empty for the initial request, use previously provided RetrieveTrialsReply.next_trial_handle on the next calls to retrieve the next versions.","title":"RetrieveTrialsRequest"},{"location":"cogment/cogment-low-level-api-guide/grpc/#retrievetrialsreply","text":"Reply for TrialDatastoreSP.RetrieveTrials() . message RetrieveTrialsReply { repeated StoredTrialInfo trial_infos = 1; string next_trial_handle = 2; } version_infos : At most RetrieveVersionInfosRequest.versions_count versions. next_version_handle : Opaque handle to be used to retrieve the next versions matching the request.","title":"RetrieveTrialsReply"},{"location":"cogment/cogment-low-level-api-guide/grpc/#retrievesamplesrequest","text":"Request for TrialDatastoreSP.RetrieveSamples() . message RetrieveSamplesRequest { repeated string trial_ids = 1; repeated string actor_names = 2; repeated string actor_classes = 3; repeated string actor_implementations = 4; repeated StoredTrialSampleField selected_sample_fields = 5; } trial_ids : List of desired trial ids, if empty no data will be returned. actor_names : List of desired actor names, if empty all actor samples will be returned. actor_classes : List of desired actor names, if empty all actor samples will be returned. actor_implementations : List of desired actor classes, if empty all actor samples will be returned. selected_sample_fields : (optional) Which fields of StoredTrialSample.ActorSample should be returned, if empty all fields are returned.","title":"RetrieveSamplesRequest"},{"location":"cogment/cogment-low-level-api-guide/grpc/#retrievesamplereply","text":"Part of the reply stream of TrialDatastoreSP.RetrieveSamples() . message RetrieveSampleReply { StoredTrialSample trial_sample = 1; } trial_sample : One trial sample matching the requested trial_ids and filtered according to the desired actors and fields.","title":"RetrieveSampleReply"},{"location":"cogment/cogment-low-level-api-guide/grpc/#addtrialrequest","text":"Request for TrialDatastoreSP.AddTrial() . message AddTrialRequest { string user_id = 1; TrialParams trial_params = 2; } user_id : The ID of the user that is adding the trial. trial_params : Parameters of the trial .","title":"AddTrialRequest"},{"location":"cogment/cogment-low-level-api-guide/grpc/#addtrialreply","text":"Reply for TrialDatastoreSP.AddTrial() . message AddTrialReply {}","title":"AddTrialReply"},{"location":"cogment/cogment-low-level-api-guide/grpc/#addsamplerequest","text":"Part of the request stream of TrialDatastoreSP.AddSample() . message AddSampleRequest { StoredTrialSample trial_sample = 1; } trial_sample : One trial sample that should match the parameters of the target trial.","title":"AddSampleRequest"},{"location":"cogment/cogment-low-level-api-guide/grpc/#addsamplesreply","text":"Reply for TrialDatastoreSP.AddSample() . message AddSamplesReply {}","title":"AddSamplesReply"},{"location":"cogment/cogment-low-level-api-guide/grpc/#deletetrialsrequest","text":"Request for TrialDatastoreSP.DeleteTrials() . message DeleteTrialsRequest { repeated string trial_ids = 1; } trial_ids : List of the trial ids to delete, if empty no trial is deleted.","title":"DeleteTrialsRequest"},{"location":"cogment/cogment-low-level-api-guide/grpc/#deletetrialsreply","text":"Reply for TrialDatastoreSP.DeleteTrials() . message DeleteTrialsReply {}","title":"DeleteTrialsReply"},{"location":"cogment/cogment-low-level-api-guide/overview/","text":"Cogment Low-Level API guide \u00b6 Who is this for \u00b6 Projects that involve tech stacks for which there is no high-level support yet. Developers of the framework itself. Curious people. Prerequisites \u00b6 The actual implementation of the Low-Level API uses gRPC. As this document is not meant to teach how to use the gRPC protocol and/or libraries, it will be assumed that the reader understands these concepts already. Differences from the High-Level API \u00b6 The high-level API takes a very object-oriented approach to trial management. Starting a trial creates an instance of an environment, as well as instances of agents. gRPC services \u00b6 The low-level API is fully described within the gRPC service definitions found in the api/cogment directory of the cogment framework source. Actor Services \u00b6 api/cogment/agent.proto describes the service that service actor applications have to implement. And api/cogment/orchestrator.proto describes the service that client actor applications have to implement. RunTrial() is called to run a trial with the actor. Environment Service \u00b6 api/cogment/environment.proto describes the service that environment applications have to implement. RunTrial() is called to run a trial. Controller API \u00b6 api/cogment/orchestrator.proto describes the service the orchestrator exposes that frontend applications use to create and manipulate trials. It is usually refered to as the Controller functionality because in the SDK you get a controller object that exposes these functionalities. StartTrial() to request the start of a new trial. TerminateTrial() to request the end of the trial. GetTrialInfo() to get inforamtion from one or more trials. WatchTrials() to get streaming information about the state of all trials. Data Log Exporter API \u00b6 api/cogment/data.proto describes the services provided to save all trial data (for archival, replay or offline analysis). OnLogSample() to log all data samples and parameters from a trial. A sample is normally all the data from a single time step. Hooks API \u00b6 api/cogment/hooks.proto describes the hook services provided to allow per trial configuration changes at runtime. OnPreTrial() is called before a trial starts. Common Data \u00b6 Most of the common data is found in api/cogment/common.proto , but other \"common\" data could be found in other proto files. Observation \u00b6 The observation class contains the observation data for an actor. The type is generic ( bytes ) to accomodate the different observation classes defined for each actor (after serialization). ObservationSet \u00b6 The observationSet class is used by the environment to send multiple observations (i.e. one per actors) to the orchestrator. The list of observations matches one-for-one with the list of actors.","title":"Overview"},{"location":"cogment/cogment-low-level-api-guide/overview/#cogment-low-level-api-guide","text":"","title":"Cogment Low-Level API guide"},{"location":"cogment/cogment-low-level-api-guide/overview/#who-is-this-for","text":"Projects that involve tech stacks for which there is no high-level support yet. Developers of the framework itself. Curious people.","title":"Who is this for"},{"location":"cogment/cogment-low-level-api-guide/overview/#prerequisites","text":"The actual implementation of the Low-Level API uses gRPC. As this document is not meant to teach how to use the gRPC protocol and/or libraries, it will be assumed that the reader understands these concepts already.","title":"Prerequisites"},{"location":"cogment/cogment-low-level-api-guide/overview/#differences-from-the-high-level-api","text":"The high-level API takes a very object-oriented approach to trial management. Starting a trial creates an instance of an environment, as well as instances of agents.","title":"Differences from the High-Level API"},{"location":"cogment/cogment-low-level-api-guide/overview/#grpc-services","text":"The low-level API is fully described within the gRPC service definitions found in the api/cogment directory of the cogment framework source.","title":"gRPC services"},{"location":"cogment/cogment-low-level-api-guide/overview/#actor-services","text":"api/cogment/agent.proto describes the service that service actor applications have to implement. And api/cogment/orchestrator.proto describes the service that client actor applications have to implement. RunTrial() is called to run a trial with the actor.","title":"Actor Services"},{"location":"cogment/cogment-low-level-api-guide/overview/#environment-service","text":"api/cogment/environment.proto describes the service that environment applications have to implement. RunTrial() is called to run a trial.","title":"Environment Service"},{"location":"cogment/cogment-low-level-api-guide/overview/#controller-api","text":"api/cogment/orchestrator.proto describes the service the orchestrator exposes that frontend applications use to create and manipulate trials. It is usually refered to as the Controller functionality because in the SDK you get a controller object that exposes these functionalities. StartTrial() to request the start of a new trial. TerminateTrial() to request the end of the trial. GetTrialInfo() to get inforamtion from one or more trials. WatchTrials() to get streaming information about the state of all trials.","title":"Controller API"},{"location":"cogment/cogment-low-level-api-guide/overview/#data-log-exporter-api","text":"api/cogment/data.proto describes the services provided to save all trial data (for archival, replay or offline analysis). OnLogSample() to log all data samples and parameters from a trial. A sample is normally all the data from a single time step.","title":"Data Log Exporter API"},{"location":"cogment/cogment-low-level-api-guide/overview/#hooks-api","text":"api/cogment/hooks.proto describes the hook services provided to allow per trial configuration changes at runtime. OnPreTrial() is called before a trial starts.","title":"Hooks API"},{"location":"cogment/cogment-low-level-api-guide/overview/#common-data","text":"Most of the common data is found in api/cogment/common.proto , but other \"common\" data could be found in other proto files.","title":"Common Data"},{"location":"cogment/cogment-low-level-api-guide/overview/#observation","text":"The observation class contains the observation data for an actor. The type is generic ( bytes ) to accomodate the different observation classes defined for each actor (after serialization).","title":"Observation"},{"location":"cogment/cogment-low-level-api-guide/overview/#observationset","text":"The observationSet class is used by the environment to send multiple observations (i.e. one per actors) to the orchestrator. The list of observations matches one-for-one with the list of actors.","title":"ObservationSet"},{"location":"cogment/implementation-recipes/configure-trial-from-controller/","text":"Fully configure a trial from a Controller \u00b6 When starting a trial, the controller can only provide an instance of the trial configuration message and from this instance the pre trial hook can fill the trial parameters , including a full configuring of the environment and actors involved in the trial. More details can be found here . In some cases, you might want to fully configure a trial from the controller. This recipe is dedicated to this use case. Warning Implementing this recipe enables any client having access to the orchestrator to specify URLs - the actor and environment endpoints - that will be accessed (and trusted) by the orchestrator. The general idea is to define TrialConfig so that it includes everything that's needed to parametrize the trial. It should look something like the following. message EnvironmentParams { string endpoint = 1; EnvConfig config = 2; string implementation = 3; } message ActorParams { string name = 1; string actor_class = 2; string endpoint = 3; string implementation = 4; ActorConfig config = 5; } message TrialConfig { EnvironmentParams environment = 1; repeated ActorParams actors = 2; uint32 max_steps = 3; uint32 max_inactivity = 4; } When starting a trial from the controller you'll need to define the full config. trial_id = await controller.start_trial(trial_config=TrialConfig( environment=EnvironmentParams( endpoint=\"grpc://my-environment:9000\", config=# [...], implementation=\"my-implementation\" ) )) Finally a pass-through pre-trial hook needs to be implemented, registered and served. Its endpoint must be specified in to the Orchestrator on startup. async def passthrough_pre_trial_hook(pre_trial_hook_session): trial_config = pre_trial_hook_session.trial_config pre_trial_hook_session.environment_config = trial_config.environment.config pre_trial_hook_session.environment_endpoint = trial_config.environment.endpoint pre_trial_hook_session.environment_implementation = trial_config.environment.implementation pre_trial_hook_session.actors = [ { \"name\": actor_params.name, \"actor_class\": actor_params.actor_class, \"endpoint\": actor_params.endpoint, \"implementation\": actor_params.implementation, \"config\": actor_params.config, } for actor_params in trial_config.actors ] pre_trial_hook_session.trial_max_steps = trial_config.max_steps pre_trial_hook_session.trial_max_inactivity = trial_config.max_inactivity pre_trial_hook_session.validate() context.register_pre_trial_hook(pre_trial_hook)","title":"Configure trial from controller"},{"location":"cogment/implementation-recipes/configure-trial-from-controller/#fully-configure-a-trial-from-a-controller","text":"When starting a trial, the controller can only provide an instance of the trial configuration message and from this instance the pre trial hook can fill the trial parameters , including a full configuring of the environment and actors involved in the trial. More details can be found here . In some cases, you might want to fully configure a trial from the controller. This recipe is dedicated to this use case. Warning Implementing this recipe enables any client having access to the orchestrator to specify URLs - the actor and environment endpoints - that will be accessed (and trusted) by the orchestrator. The general idea is to define TrialConfig so that it includes everything that's needed to parametrize the trial. It should look something like the following. message EnvironmentParams { string endpoint = 1; EnvConfig config = 2; string implementation = 3; } message ActorParams { string name = 1; string actor_class = 2; string endpoint = 3; string implementation = 4; ActorConfig config = 5; } message TrialConfig { EnvironmentParams environment = 1; repeated ActorParams actors = 2; uint32 max_steps = 3; uint32 max_inactivity = 4; } When starting a trial from the controller you'll need to define the full config. trial_id = await controller.start_trial(trial_config=TrialConfig( environment=EnvironmentParams( endpoint=\"grpc://my-environment:9000\", config=# [...], implementation=\"my-implementation\" ) )) Finally a pass-through pre-trial hook needs to be implemented, registered and served. Its endpoint must be specified in to the Orchestrator on startup. async def passthrough_pre_trial_hook(pre_trial_hook_session): trial_config = pre_trial_hook_session.trial_config pre_trial_hook_session.environment_config = trial_config.environment.config pre_trial_hook_session.environment_endpoint = trial_config.environment.endpoint pre_trial_hook_session.environment_implementation = trial_config.environment.implementation pre_trial_hook_session.actors = [ { \"name\": actor_params.name, \"actor_class\": actor_params.actor_class, \"endpoint\": actor_params.endpoint, \"implementation\": actor_params.implementation, \"config\": actor_params.config, } for actor_params in trial_config.actors ] pre_trial_hook_session.trial_max_steps = trial_config.max_steps pre_trial_hook_session.trial_max_inactivity = trial_config.max_inactivity pre_trial_hook_session.validate() context.register_pre_trial_hook(pre_trial_hook)","title":"Fully configure a trial from a Controller"},{"location":"cogment/implementation-recipes/implementation-recipes/","text":"Implementation recipes \u00b6 This section gathers implementation guides, or recipes, concerning specific topics not covered elsewhere. Beginners should start learning about using Cogment through the tutorial and general information are located in the api guide . Recipes \u00b6 Migrate from Cogment v1 to Cogment v2 Fully configure a trial from a controller If you feel a specific topic is not adressed, please fill an issue or get in touch .","title":"Implementation recipes"},{"location":"cogment/implementation-recipes/implementation-recipes/#implementation-recipes","text":"This section gathers implementation guides, or recipes, concerning specific topics not covered elsewhere. Beginners should start learning about using Cogment through the tutorial and general information are located in the api guide .","title":"Implementation recipes"},{"location":"cogment/implementation-recipes/implementation-recipes/#recipes","text":"Migrate from Cogment v1 to Cogment v2 Fully configure a trial from a controller If you feel a specific topic is not adressed, please fill an issue or get in touch .","title":"Recipes"},{"location":"cogment/implementation-recipes/v2-migration-guide/","text":"Migrate from Cogment v1 to v2 \u00b6 Note This document is written as a guide to migrate from Cogment v1 to v2, a full list of the changes is also available there . Updating components \u00b6 The following components needs to be updated to work with Cogment v2: Update the CLI to the latest version and check that the version is correct curl --silent -L https://raw.githubusercontent.com/cogment/cogment-cli/main/install.sh | sudo bash cogment version Update the docker images to the versions compatible with the 2.0 API. These should be updated in Dockerfile , *.dockerfile or docker-compose.yml files in your project. The minimal version to use API 2.0 are: cogment/orchestrator:v2.0.0 cogment/trial-datastore:v0.2.0 (prereleased component) cogment/model-registry:v0.4.0 (prereleased component) Update the version of the python SDK to cogment[generate]>=2.0.2 (learn more about generate here ) in your requirements.txt files or equivalent. Update the version of the javascript SDK to @cogment/cogment-js-sdk^2 in your package.json files or equivalent. cogment.yaml split in a spec file and a parameters file \u00b6 The cogment.yaml file has seen a lot of changes, the most important one is that we now differ between the spec file which specifies the types of trial for a cogment project, including actor classes and their action/observation spaces, and the parameters file which specifies default parameters for trials. The spec file is used in the code generation process of each SDKs and is no longer used by the orchestrator. The parameters file is used by the orchestrator, if you use pre-trial hooks to configure the started trials it might not be necessary. We now recommand that two different files, respectively named cogment.yaml and params.yaml be used, however you can still use one file containing both content. Recommended update Move the trial_params section of the existing cogment.yaml file to a dedicated params.yaml file. Further changes are required to both sections, as described below. Required update If the --config=cogment.yaml was provided to the orchestrator, remove it. To provide a parameters file to the orchestrator use the --params=params.yaml command line option. Further details can be found in the spec file documentation . pre-trial hooks definition moved to an orchestrator configuration \u00b6 pre-trial hooks are no longer defined in the cogment.yaml file, but instead are now given to the orchestrator as a command line option or through an environment variable. Required update Remove the trial:pre-hooks section from the spec file. Instead specify the hook addresses as gRPC URLs, e.g. grpc://1.1.1.1:9000 , using the orchestrator cli option --pre_trial_hooks , separating potential multiple hooks with comas. Further details can be found in the orchestrator documentation . Datalog definition now part of each trial's parameters \u00b6 The datalog definition is no longer a project-wide configuration but can be specified for each trial in its parameters. Required update Remove the datalog section from the spec file. Datalog can be defined in the parameters file with the following format: trial_params: datalog: - endpoint: grpc://logger:9000 It can also be defined when configuring the trial in the pre-trial hook. Datalog API has changed, and now has a python wrapper \u00b6 Instead of returning raw protobuf messages, Python wrapper objects are returned, so access to the raw messages is not available anymore The DatalogSession attribute raw_trial_params is not available anymore. The DatalogSession attribute trial_params returns a cogment.LogParams object instead of a protobuf message. The DatalogSession.get_all_samples() now generates cogment.LogSample objects instead of a protobuf message. If there is a need to deserialize v1 data (e.g. from an old database), v1 versions of the sample protobuf messages ( cogment.api.datalog_pb2.TrialParams_v1 and cogment.api.datalog_pb2.DatalogSample_v1 ) are provided in the API for convenience. For more information, please see the following sections of the Python SDK Documentation LogSample DatalogSession Default trial parameters no longer support definition user configuration for trials, environments and actors \u00b6 The config sections that were used to define default user configuration of trials, environments and actors are no longer supported. If necessary, these must be provided when starting the trial, for the trial config, and in pre-trial hooks, for the environment and actors config. Defaults can also be defined in the implementation code itself. Required update Remove the config sections (for trial, environment and actor) from the params file. For simple projects, provide a default configuration in the implementation code directly, for more complex one use a pre-trial hook. Prefer using full URL for endpoints \u00b6 Recommended update Use full gRPC URLs, starting with grpc:// , when defining endpoints in the params file on in the SDKs. Additionaly, to prepare for further features, we are introducing a cogment URL scheme. At the moment only the special client endpoint is concerned. Recommended update If actors are clients, replace the endpoint value from client to cogment://client Support for \"delta\" observations discontinued \u00b6 Framework support for \"delta\" observations has been discontinued. The same result can be obtained user-side in the environment and actor implementations. Required update Remove the following section from the spec file: import::python import::javascript actor_classes::observation::delta actor_classes::observation::delta_apply_fn In the python SDK, RecvObservation delta attribute no longer exists. You can support delta observations in your code, for example you could change the definition of your observation message to support both full observation or delta observation. message Observation { oneof observation_or_delta { ObservationMessage obs = 1; DeltaObservation delta = 2; } } As before the environment side can decide to send full or delta observations. On the consumer side, actor or datalog, you'll need to keep the previous observation around to apply the delta to it. Recommended update Instead of using RecvObservation snapshot attribute, use observation instead. New code generation workflow \u00b6 The code generation step is no longer perfomed by the CLI but by dedicated tools provided with the SDKs. cogment copy is provided by the CLI as a cross platform way to copy the required files, i.e. the spec, protobuf and params files, from the root of the project to services source directories. As a result of these cogment sync and cogment generate are no longer available. Required update Replace any usage of cogment sync with cogment copy . This new commands needs to know explicitly what files to copy cogment copy data.proto cogment.yaml params.yaml environment_dir actor_dir Required update For services using the python SDK: Make sure you install the SDK and the generate tool using pip install cogment[generate] . Generate the necessary files with python3 -m cogment.generate --spec cogment.yaml . Required update For services using the javascript SDK Generate the necessary files with npx cogment-js-sdk-generate cogment.yaml . Orchestrator environment variables namespaced \u00b6 Required update Change the name of environment variables: From TRIAL_LIFECYCLE_PORT to COGMENT_LIFECYCLE_PORT From TRIAL_ACTOR_PORT to COGMENT_ACTOR_PORT From PROMETHEUS_PORT to COGMENT_ORCHESTRATOR_PROMETHEUS_PORT Trials' environments can be named \u00b6 Just like the actors, the environment in a trial can now be named, this name defaults to \"env\". The environment name is used to address it, in particular to send messages. Environments and actors names belong to the same \"namespace\" and must be unique. Recommended update Instead of using the to_environment arguments of ActorSession.send_message() , use to and specify the environment's name. Python SDK \u00b6 Required update Controller.terminate_trial() and Controller.get_trial_info() no longer supports providing a single trial identifier as a string. Their usage need to change from # Using named argument my_controller.terminate_trial(trial_id=\"my_trial_id\") # Using positional argument my_controller.get_trial_info(\"my_trial_id\") to my_controller.terminate_trial(trial_ids=[\"my_trial_id\"]) my_controller.get_trial_info([\"my_trial_id\"]) Required update In actor implementaion, remove all usage of get_active_actors() . This method has been restricted to the environment only. If actors need the full list of actors, there are a few possibilities: - Create a controller in the actor implementation and use the Controller.get_actors() method. - Receive the actor list in the config from the pre-trial hooks; the pre-trial hooks have implicit knowledge of all actors (at least the last hook). - Add the information in the actors observation space. - Send the information in a message. Required update Remove all usage of EnvironmentSession.send_message() using the to_environment argument. Required update Rename the parameter observations in EnvironmentSession.end(observations=observations) to final_observations . Further details can be found in the python SDK documentation . Javascript SDK \u00b6 There has been a complete rework of the JS SDK we therefore recommend you to take a look at the dedicated javascript SDK documentation . In more details: You can keep your actor function, as well as any logic dealing with the observation object, as its shape has remained the same, If you are using the useActions React hook, there is a new version of that hook, which can be retrieved by running cogment init with an updated version of the Cogment CLI , and choosing yes when prompted if you want a web client. Troubleshooting \u00b6 Here we list a few error you are likely to see if something was not upgraded properly to Cogment 2.0: AttributeError: module \"cogment\" has no attribute \"delta_encoding\" This would be logged while trying to run a Python script and may happen if you use cogment generate instead of the new generation workflow . This is caused by the discontinuation of delta encoding for observations. Failure: [Problem rebuilding trial params [INVALID_ARGUMENT:(environment.config) some_message: Cannot find field.]] When starting the Orchestrator with --config or --params. This may happen when using an older version of the default parameters in a params or spec file. It will happen when the default parameters contain an unknown field; In this particular case, the field config (i.e.from environment.config) is \"unknown\" because it is not accepted anymore in the Cogment 2.0 default parameters.","title":"Migrate from Cogment v1 to v2"},{"location":"cogment/implementation-recipes/v2-migration-guide/#migrate-from-cogment-v1-to-v2","text":"Note This document is written as a guide to migrate from Cogment v1 to v2, a full list of the changes is also available there .","title":"Migrate from Cogment v1 to v2"},{"location":"cogment/implementation-recipes/v2-migration-guide/#updating-components","text":"The following components needs to be updated to work with Cogment v2: Update the CLI to the latest version and check that the version is correct curl --silent -L https://raw.githubusercontent.com/cogment/cogment-cli/main/install.sh | sudo bash cogment version Update the docker images to the versions compatible with the 2.0 API. These should be updated in Dockerfile , *.dockerfile or docker-compose.yml files in your project. The minimal version to use API 2.0 are: cogment/orchestrator:v2.0.0 cogment/trial-datastore:v0.2.0 (prereleased component) cogment/model-registry:v0.4.0 (prereleased component) Update the version of the python SDK to cogment[generate]>=2.0.2 (learn more about generate here ) in your requirements.txt files or equivalent. Update the version of the javascript SDK to @cogment/cogment-js-sdk^2 in your package.json files or equivalent.","title":"Updating components"},{"location":"cogment/implementation-recipes/v2-migration-guide/#cogmentyaml-split-in-a-spec-file-and-a-parameters-file","text":"The cogment.yaml file has seen a lot of changes, the most important one is that we now differ between the spec file which specifies the types of trial for a cogment project, including actor classes and their action/observation spaces, and the parameters file which specifies default parameters for trials. The spec file is used in the code generation process of each SDKs and is no longer used by the orchestrator. The parameters file is used by the orchestrator, if you use pre-trial hooks to configure the started trials it might not be necessary. We now recommand that two different files, respectively named cogment.yaml and params.yaml be used, however you can still use one file containing both content. Recommended update Move the trial_params section of the existing cogment.yaml file to a dedicated params.yaml file. Further changes are required to both sections, as described below. Required update If the --config=cogment.yaml was provided to the orchestrator, remove it. To provide a parameters file to the orchestrator use the --params=params.yaml command line option. Further details can be found in the spec file documentation .","title":"cogment.yaml split in a spec file and a parameters file"},{"location":"cogment/implementation-recipes/v2-migration-guide/#pre-trial-hooks-definition-moved-to-an-orchestrator-configuration","text":"pre-trial hooks are no longer defined in the cogment.yaml file, but instead are now given to the orchestrator as a command line option or through an environment variable. Required update Remove the trial:pre-hooks section from the spec file. Instead specify the hook addresses as gRPC URLs, e.g. grpc://1.1.1.1:9000 , using the orchestrator cli option --pre_trial_hooks , separating potential multiple hooks with comas. Further details can be found in the orchestrator documentation .","title":"pre-trial hooks definition moved to an orchestrator configuration"},{"location":"cogment/implementation-recipes/v2-migration-guide/#datalog-definition-now-part-of-each-trials-parameters","text":"The datalog definition is no longer a project-wide configuration but can be specified for each trial in its parameters. Required update Remove the datalog section from the spec file. Datalog can be defined in the parameters file with the following format: trial_params: datalog: - endpoint: grpc://logger:9000 It can also be defined when configuring the trial in the pre-trial hook.","title":"Datalog definition now part of each trial's parameters"},{"location":"cogment/implementation-recipes/v2-migration-guide/#datalog-api-has-changed-and-now-has-a-python-wrapper","text":"Instead of returning raw protobuf messages, Python wrapper objects are returned, so access to the raw messages is not available anymore The DatalogSession attribute raw_trial_params is not available anymore. The DatalogSession attribute trial_params returns a cogment.LogParams object instead of a protobuf message. The DatalogSession.get_all_samples() now generates cogment.LogSample objects instead of a protobuf message. If there is a need to deserialize v1 data (e.g. from an old database), v1 versions of the sample protobuf messages ( cogment.api.datalog_pb2.TrialParams_v1 and cogment.api.datalog_pb2.DatalogSample_v1 ) are provided in the API for convenience. For more information, please see the following sections of the Python SDK Documentation LogSample DatalogSession","title":"Datalog API has changed, and now has a python wrapper"},{"location":"cogment/implementation-recipes/v2-migration-guide/#default-trial-parameters-no-longer-support-definition-user-configuration-for-trials-environments-and-actors","text":"The config sections that were used to define default user configuration of trials, environments and actors are no longer supported. If necessary, these must be provided when starting the trial, for the trial config, and in pre-trial hooks, for the environment and actors config. Defaults can also be defined in the implementation code itself. Required update Remove the config sections (for trial, environment and actor) from the params file. For simple projects, provide a default configuration in the implementation code directly, for more complex one use a pre-trial hook.","title":"Default trial parameters no longer support definition user configuration for trials, environments and actors"},{"location":"cogment/implementation-recipes/v2-migration-guide/#prefer-using-full-url-for-endpoints","text":"Recommended update Use full gRPC URLs, starting with grpc:// , when defining endpoints in the params file on in the SDKs. Additionaly, to prepare for further features, we are introducing a cogment URL scheme. At the moment only the special client endpoint is concerned. Recommended update If actors are clients, replace the endpoint value from client to cogment://client","title":"Prefer using full URL for endpoints"},{"location":"cogment/implementation-recipes/v2-migration-guide/#support-for-delta-observations-discontinued","text":"Framework support for \"delta\" observations has been discontinued. The same result can be obtained user-side in the environment and actor implementations. Required update Remove the following section from the spec file: import::python import::javascript actor_classes::observation::delta actor_classes::observation::delta_apply_fn In the python SDK, RecvObservation delta attribute no longer exists. You can support delta observations in your code, for example you could change the definition of your observation message to support both full observation or delta observation. message Observation { oneof observation_or_delta { ObservationMessage obs = 1; DeltaObservation delta = 2; } } As before the environment side can decide to send full or delta observations. On the consumer side, actor or datalog, you'll need to keep the previous observation around to apply the delta to it. Recommended update Instead of using RecvObservation snapshot attribute, use observation instead.","title":"Support for \"delta\" observations discontinued"},{"location":"cogment/implementation-recipes/v2-migration-guide/#new-code-generation-workflow","text":"The code generation step is no longer perfomed by the CLI but by dedicated tools provided with the SDKs. cogment copy is provided by the CLI as a cross platform way to copy the required files, i.e. the spec, protobuf and params files, from the root of the project to services source directories. As a result of these cogment sync and cogment generate are no longer available. Required update Replace any usage of cogment sync with cogment copy . This new commands needs to know explicitly what files to copy cogment copy data.proto cogment.yaml params.yaml environment_dir actor_dir Required update For services using the python SDK: Make sure you install the SDK and the generate tool using pip install cogment[generate] . Generate the necessary files with python3 -m cogment.generate --spec cogment.yaml . Required update For services using the javascript SDK Generate the necessary files with npx cogment-js-sdk-generate cogment.yaml .","title":"New code generation workflow"},{"location":"cogment/implementation-recipes/v2-migration-guide/#orchestrator-environment-variables-namespaced","text":"Required update Change the name of environment variables: From TRIAL_LIFECYCLE_PORT to COGMENT_LIFECYCLE_PORT From TRIAL_ACTOR_PORT to COGMENT_ACTOR_PORT From PROMETHEUS_PORT to COGMENT_ORCHESTRATOR_PROMETHEUS_PORT","title":"Orchestrator environment variables namespaced"},{"location":"cogment/implementation-recipes/v2-migration-guide/#trials-environments-can-be-named","text":"Just like the actors, the environment in a trial can now be named, this name defaults to \"env\". The environment name is used to address it, in particular to send messages. Environments and actors names belong to the same \"namespace\" and must be unique. Recommended update Instead of using the to_environment arguments of ActorSession.send_message() , use to and specify the environment's name.","title":"Trials' environments can be named"},{"location":"cogment/implementation-recipes/v2-migration-guide/#python-sdk","text":"Required update Controller.terminate_trial() and Controller.get_trial_info() no longer supports providing a single trial identifier as a string. Their usage need to change from # Using named argument my_controller.terminate_trial(trial_id=\"my_trial_id\") # Using positional argument my_controller.get_trial_info(\"my_trial_id\") to my_controller.terminate_trial(trial_ids=[\"my_trial_id\"]) my_controller.get_trial_info([\"my_trial_id\"]) Required update In actor implementaion, remove all usage of get_active_actors() . This method has been restricted to the environment only. If actors need the full list of actors, there are a few possibilities: - Create a controller in the actor implementation and use the Controller.get_actors() method. - Receive the actor list in the config from the pre-trial hooks; the pre-trial hooks have implicit knowledge of all actors (at least the last hook). - Add the information in the actors observation space. - Send the information in a message. Required update Remove all usage of EnvironmentSession.send_message() using the to_environment argument. Required update Rename the parameter observations in EnvironmentSession.end(observations=observations) to final_observations . Further details can be found in the python SDK documentation .","title":"Python SDK"},{"location":"cogment/implementation-recipes/v2-migration-guide/#javascript-sdk","text":"There has been a complete rework of the JS SDK we therefore recommend you to take a look at the dedicated javascript SDK documentation . In more details: You can keep your actor function, as well as any logic dealing with the observation object, as its shape has remained the same, If you are using the useActions React hook, there is a new version of that hook, which can be retrieved by running cogment init with an updated version of the Cogment CLI , and choosing yes when prompted if you want a web client.","title":"Javascript SDK"},{"location":"cogment/implementation-recipes/v2-migration-guide/#troubleshooting","text":"Here we list a few error you are likely to see if something was not upgraded properly to Cogment 2.0: AttributeError: module \"cogment\" has no attribute \"delta_encoding\" This would be logged while trying to run a Python script and may happen if you use cogment generate instead of the new generation workflow . This is caused by the discontinuation of delta encoding for observations. Failure: [Problem rebuilding trial params [INVALID_ARGUMENT:(environment.config) some_message: Cannot find field.]] When starting the Orchestrator with --config or --params. This may happen when using an older version of the default parameters in a params or spec file. It will happen when the default parameters contain an unknown field; In this particular case, the field config (i.e.from environment.config) is \"unknown\" because it is not accepted anymore in the Cogment 2.0 default parameters.","title":"Troubleshooting"},{"location":"cogment/tutorial/1-bootstrap-and-data-structures/","text":"Step 1: Create a new Trial \u00b6 Install Cogment \u00b6 To follow this tutorial you'll need a working installation of Cogment . If you haven't done so already, follow our installation instructions . Bootstrap the app \u00b6 The Cogment command line interface (CLI) includes a simple tool to generate the base files and folder structures for a Cogment app. The first thing we'll do is use it to create an app with 2 AIs able to play games of RPS. Using Cogment's terminology, we will create 2 actors sharing a single implementation picking a random move for each round. We will develop a service actor implementation which is well suited for AIs rather than a client actor implementation, which would be required for an interactive actor; for exemple, an actor controlled by a Human player. In the step 5 we will create such implementation. Run the following to bootstrap the app in a rps directory: $ cogment init rps Enter how many actor classes should be created: 1 [class 1] Enter the name of the class: player [class #1 'player'] Enter the number of service implementations that should be created (empty for 1): 1 [class #1 'player' > service impl. #1] Enter the name of the implementation: random_agent [class #1 'player' > service impl. #1 'random_agent'] Enter the number of actor instances using this implementation (empty for 1): 2 [class #1 'player'] Should a client implementation be created (Y or N, empty for Y): N Should a web-client be created (Y or N, empty for Y): N $ cd rps To summarize, for this 2 players game, we created: 1 actor class, player , because RPS is a symmetric game, both players have the same role within the game, 1 actor implementation for this class, random_agent , because at the moment we only want to implement one way of playing, 2 actor instances, because the game has 2 players. \u2139\ufe0f For the remainder of this tutorial, unless otherwise mentioned, it is assumed that all operations are run in the rps directory. Building and running the app \u00b6 We can now check that everything works as expected. First, we will need to run the build phase. The docker files rely on cogment.yaml, and data.proto to be in the respective build directories, the shortcut for copying these files to the build directories is cogment run copy $ cogment run copy $ cogment run build Run the following to start all the services of the Cogment app as docker containers: the orchestrator , the environment and our random_agent . $ cogment run start In another terminal, run the following to start a client for this Cogment app, this will connect to the running services to start a trial, let it run for a few seconds and then terminate it. $ cogment run client Executing docker-compose run --rm client in . Creating rps_client_run ... done Client up and running. Trial 'b8251a1a-fad0-43b9-a1cc-00dcbebbfaa7' starts Trial 'b8251a1a-fad0-43b9-a1cc-00dcbebbfaa7' terminating This should also generate some logs in the first terminal where the app services are running. You can now terminate the services using ctrl+C . At this point we have generated a working but empty Cogment app and we checked that it could build and run. We are now ready to start the actual implementation! Define our data structures \u00b6 Cogment uses Protocol Buffers to define data structures. The initial definitions are located in the data.proto and look like that. syntax = \"proto3\"; package rps; message EnvConfig { } message TrialConfig { EnvConfig env_config = 1; } message Observation {} message PlayerAction {} Note that a file named cogment.yaml was also created in the rps directory by the boostrap process. This file is the main configuration for your Cogment app. In it, you will see a reference to: import: proto: - data.proto EnvConfig and TrialConfig will be discussed in the coming steps. For now we'll focus on defining the Action Space and Observation Space for our RPS app. Action Space \u00b6 Let's start by filling up PlayerAction which defines what each player can do at each step of the game. In the case of RPS, players chose one move among the three alternatives giving their name to the game: \"Rock\" , \"Paper\" or \"Scissors\" . To do that we will use an enum called Move , enum Move { ROCK = 0; PAPER = 1; SCISSORS = 2; } and use that type in PlayerAction . message PlayerAction { Move move = 1; } Modify the data.proto file to include the above additions. Observation Space \u00b6 The Observation structure defines what the actors perceive from the environment. It is an input they use to choose which action to take. In the context of RPS, the environment is limited to the two players and what they played. We represent this information in a data structure called PlayerState using two properties. message PlayerState { Move last_move = 1; // Last move played bool won_last = 2; // Did the player win the last round } The Observation structure itself defines the observed players from the point of view of each player. message Observation { PlayerState me = 1; PlayerState them = 2; } Edit the data.proto file to include the above additions. This file is used during the code generation phase to make the defined data structures available to the different services. To check that everything is working build and run the application. Nothing should be different at this stage. This concludes the step 1 of the tutorial: you have bootstrapped a Cogment project, implemented the data structures defining the action and observation spaces, started your app and ran a trial. Let\u2019s move on to actually implementing our services in step 2 .","title":"Step 1: Bootstrap a Cogment app"},{"location":"cogment/tutorial/1-bootstrap-and-data-structures/#step-1-create-a-new-trial","text":"","title":"Step 1: Create a new Trial"},{"location":"cogment/tutorial/1-bootstrap-and-data-structures/#install-cogment","text":"To follow this tutorial you'll need a working installation of Cogment . If you haven't done so already, follow our installation instructions .","title":"Install Cogment"},{"location":"cogment/tutorial/1-bootstrap-and-data-structures/#bootstrap-the-app","text":"The Cogment command line interface (CLI) includes a simple tool to generate the base files and folder structures for a Cogment app. The first thing we'll do is use it to create an app with 2 AIs able to play games of RPS. Using Cogment's terminology, we will create 2 actors sharing a single implementation picking a random move for each round. We will develop a service actor implementation which is well suited for AIs rather than a client actor implementation, which would be required for an interactive actor; for exemple, an actor controlled by a Human player. In the step 5 we will create such implementation. Run the following to bootstrap the app in a rps directory: $ cogment init rps Enter how many actor classes should be created: 1 [class 1] Enter the name of the class: player [class #1 'player'] Enter the number of service implementations that should be created (empty for 1): 1 [class #1 'player' > service impl. #1] Enter the name of the implementation: random_agent [class #1 'player' > service impl. #1 'random_agent'] Enter the number of actor instances using this implementation (empty for 1): 2 [class #1 'player'] Should a client implementation be created (Y or N, empty for Y): N Should a web-client be created (Y or N, empty for Y): N $ cd rps To summarize, for this 2 players game, we created: 1 actor class, player , because RPS is a symmetric game, both players have the same role within the game, 1 actor implementation for this class, random_agent , because at the moment we only want to implement one way of playing, 2 actor instances, because the game has 2 players. \u2139\ufe0f For the remainder of this tutorial, unless otherwise mentioned, it is assumed that all operations are run in the rps directory.","title":"Bootstrap the app"},{"location":"cogment/tutorial/1-bootstrap-and-data-structures/#building-and-running-the-app","text":"We can now check that everything works as expected. First, we will need to run the build phase. The docker files rely on cogment.yaml, and data.proto to be in the respective build directories, the shortcut for copying these files to the build directories is cogment run copy $ cogment run copy $ cogment run build Run the following to start all the services of the Cogment app as docker containers: the orchestrator , the environment and our random_agent . $ cogment run start In another terminal, run the following to start a client for this Cogment app, this will connect to the running services to start a trial, let it run for a few seconds and then terminate it. $ cogment run client Executing docker-compose run --rm client in . Creating rps_client_run ... done Client up and running. Trial 'b8251a1a-fad0-43b9-a1cc-00dcbebbfaa7' starts Trial 'b8251a1a-fad0-43b9-a1cc-00dcbebbfaa7' terminating This should also generate some logs in the first terminal where the app services are running. You can now terminate the services using ctrl+C . At this point we have generated a working but empty Cogment app and we checked that it could build and run. We are now ready to start the actual implementation!","title":"Building and running the app"},{"location":"cogment/tutorial/1-bootstrap-and-data-structures/#define-our-data-structures","text":"Cogment uses Protocol Buffers to define data structures. The initial definitions are located in the data.proto and look like that. syntax = \"proto3\"; package rps; message EnvConfig { } message TrialConfig { EnvConfig env_config = 1; } message Observation {} message PlayerAction {} Note that a file named cogment.yaml was also created in the rps directory by the boostrap process. This file is the main configuration for your Cogment app. In it, you will see a reference to: import: proto: - data.proto EnvConfig and TrialConfig will be discussed in the coming steps. For now we'll focus on defining the Action Space and Observation Space for our RPS app.","title":"Define our data structures"},{"location":"cogment/tutorial/1-bootstrap-and-data-structures/#action-space","text":"Let's start by filling up PlayerAction which defines what each player can do at each step of the game. In the case of RPS, players chose one move among the three alternatives giving their name to the game: \"Rock\" , \"Paper\" or \"Scissors\" . To do that we will use an enum called Move , enum Move { ROCK = 0; PAPER = 1; SCISSORS = 2; } and use that type in PlayerAction . message PlayerAction { Move move = 1; } Modify the data.proto file to include the above additions.","title":"Action Space"},{"location":"cogment/tutorial/1-bootstrap-and-data-structures/#observation-space","text":"The Observation structure defines what the actors perceive from the environment. It is an input they use to choose which action to take. In the context of RPS, the environment is limited to the two players and what they played. We represent this information in a data structure called PlayerState using two properties. message PlayerState { Move last_move = 1; // Last move played bool won_last = 2; // Did the player win the last round } The Observation structure itself defines the observed players from the point of view of each player. message Observation { PlayerState me = 1; PlayerState them = 2; } Edit the data.proto file to include the above additions. This file is used during the code generation phase to make the defined data structures available to the different services. To check that everything is working build and run the application. Nothing should be different at this stage. This concludes the step 1 of the tutorial: you have bootstrapped a Cogment project, implemented the data structures defining the action and observation spaces, started your app and ran a trial. Let\u2019s move on to actually implementing our services in step 2 .","title":"Observation Space"},{"location":"cogment/tutorial/2-random-player/","text":"Step 2: Implement a first actor and environment \u00b6 This part of the tutorial follows step 1 , make sure you've gone through it before starting this one. Alternatively, the completed step 1 can be retrieved from the tutorial's repository . In this step of the tutorial, we will implement the (very simple) decison logic for the random player as well as the base mechanics for RPS, i.e. the rules of the game, in the environment services. Random player agent \u00b6 In the rps directory, the random_agent directory contains the python implementation for the eponymous service. You'll find two files here: requirements.txt is a pip requirement file defining the dependencies of the service. For the moment it only lists cogment , Cogment's python SDK. main.py contains the implementation of the service. Open main.py and take a look at the generated content. At the bottom you'll find the main function, it initializes Cogment's context, registers the random_agent actor's implementation, then starts the service itsef on tcp port 9000 and awaits its termination. Cogment's python sdk leverages Python's asynchronous features , you'll need a basic understanding of them. async def main(): print(\"Random-Agent actor service up and running.\") context = cogment.Context(cog_settings=cog_settings, user_id=\"rps\") context.register_actor( impl=random_agent, impl_name=\"random_agent\", actor_classes=[\"player\",]) await context.serve_all_registered(cogment.ServedEndpoint(port=9000)) At the beginning of the file, the function random_agent is the actor's implementation. This function is called once per actor and per trial and handles the full lifetime of the actor. The actor's initialization , before the async for . This is where, for example, actor's internal data can be defined before calling actor_session.start() to notify that it is ready, Its event loop , the content of the async for . This is where resides the implementation of the actor's response to various events, Its termination , after the async for . The generated implementation is very simple: it handles the three main kind of events: observations , rewards and messages , it does a default action whenever required, i.e. in response to an observation. We will further learn about how to use rewards in step 3 and observations in step 4 . Messages are out of the scope for this basics tutorial. Please note the import and usage of PlayerAction which is the data structure from data.proto defining the actor's action space. async def random_agent(actor_session): actor_session.start() async for event in actor_session.event_loop(): if event.observation: observation = event.observation print(f\"'{actor_session.name}' received an observation: '{observation}'\") if event.type == cogment.EventType.ACTIVE: action = PlayerAction() actor_session.do_action(action) for reward in event.rewards: print(f\"'{actor_session.name}' received a reward for tick #{reward.tick_id}: {reward.value}\") for message in event.messages: print(f\"'{actor_session.name}' received a message from '{message.sender_name}': - '{message.payload}'\") Our goal is to implement an actor playing at random. We first need to import the different Move , as defined in our data structures. We also need to import random , the python package generating random numbers. from data_pb2 import ROCK, PAPER, SCISSORS import random MOVES = [ROCK, PAPER, SCISSORS] MOVES_STR = [\"\ud83d\udc4a rock\", \"\u270b paper\", \"\u270c\ufe0f scissors\"] Once this is available we can simply update the taking decision part of the actor's implementation to compute a random move whenever it is needed. if event.observation: observation = event.observation print(f\"'{actor_session.name}' received an observation: '{observation}'\") if event.type == cogment.EventType.ACTIVE: action = PlayerAction(move=random.choice(MOVES)) actor_session.do_action(action) Modify the random_agent/main.py file to include the above additions. Implementing the rules of the game \u00b6 In the rps directory, the environment directory contains the python implementation for the eponymous service. Similarly to the actor's service, you will find two files here, requirements.txt and main.py . Open main.py and take a look at the generated content. The code is very similar to the random_agent 's. In the main function, instead of using register_actor , register_environment is used. The implementation function, called environment here, is structured similarly to the actor's one but handles two kinds of events: actions (and the last actions of a trial final_actions ) and message . Environments don't perform actions, they produce observations that are sent to the actors participating in the trial. Please note the import and usage of Observation which is the datastructure defined in data.proto defining the actors observation space. async def environment(environment_session): print(\"environment starting\") # Create the initial observaton observation = Observation() # Start the trial and send that observation to all actors environment_session.start([(\"*\", observation)]) async for event in environment_session.event_loop(): if event.actions: actions = event.actions print(f\"environment received the actions\") for actor, recv_action in zip(environment_session.get_active_actors(), actions): print(f\" actor '{actor.actor_name}' did action '{recv_action.action}'\") observation = Observation() if event.type == cogment.EventType.ACTIVE: # The trial is active environment_session.produce_observations([(\"*\", observation)]) else: # The trial termination has been requested environment_session.end([(\"*\", observation)]) for message in event.messages: print(f\"environment received a message from '{message.sender_name}': - '{message.payload}'\") print(\"environment end\") Our goal, in this section, is to implement how the environment computes the observations from the actions done by the actors at a given timestep. We first import the needed datastructure and define a dictionary mapping each move to the move that defeats it. from data_pb2 import PlayerState, ROCK, PAPER, SCISSORS DEFEATS = { ROCK: PAPER, SCISSORS: ROCK, PAPER: SCISSORS } In the initialization phase of the environment implementation, i.e. before the async for , we create a simple state data structure that is keeping around the number of rounds played and won by each of the two players. We then compute the initial observation for each of the two players. One instance of PlayerState per player is created, each is used as the me and them state of each player's observation. state = { \"rounds_count\": 0, \"p1\": { \"won_rounds_count\": 0 }, \"p2\": { \"won_rounds_count\": 0 }, } print(\"environment starting\") [p1, p2] = environment_session.get_active_actors() p1_state = PlayerState(won_last=False, last_move=None) p2_state = PlayerState(won_last=False, last_move=None) environment_session.start([ (p1.actor_name, Observation(me=p1_state, them=p2_state)), (p2.actor_name, Observation(me=p2_state, them=p1_state)), ]) In the event loop we implement how the environment produces observations based on the actor's actions. We start by retrieving each player's action and computing who won the round. Then, we update the internal state . Finally, we produce up-to-date observations for the players. if event.actions: [p1_action, p2_action] = [recv_action.action for recv_action in event.actions] print(f\"{p1.actor_name} played {MOVES_STR[p1_action.move]}\") print(f\"{p2.actor_name} played {MOVES_STR[p2_action.move]}\") # Compute who wins, if the two players had the same move, nobody wins p1_state = PlayerState( won_last=p1_action.move == DEFEATS[p2_action.move], last_move=p1_action.move ) p2_state = PlayerState( won_last=p2_action.move == DEFEATS[p1_action.move], last_move=p2_action.move ) state[\"rounds_count\"] += 1 if p1_state.won_last: state[\"p1\"][\"won_rounds_count\"] += 1 print(f\"{p1.actor_name} wins!\") elif p2_state.won_last: state[\"p2\"][\"won_rounds_count\"] += 1 print(f\"{p2.actor_name} wins!\") else: print(f\"draw.\") # Generate and send observations observations = [ (p1.actor_name, Observation(me=p1_state, them=p2_state)), (p2.actor_name, Observation(me=p2_state, them=p1_state)), ] if event.type == cogment.EventType.ACTIVE: # The trial is active environment_session.produce_observations(observations) else: # The trial termination has been requested environment_session.end(observations) Finally, in the termination phase, we print some stats about the trial itself. print(\"environment end\") print(f\"\\t * {state['rounds_count']} rounds played\") print(f\"\\t * {p1.actor_name} won {state['p1']['won_rounds_count']} rounds\") print(f\"\\t * {p1.actor_name} won {state['p2']['won_rounds_count']} rounds\") print(f\"\\t * {state['rounds_count'] - state['p1']['won_rounds_count'] - state['p2']['won_rounds_count']} draws\") Modify the environment/main.py file to include the above additions. Please note that this code makes assumptions on the number of actors and their classes. Production code should handle non-standard cases in a better way. You can now build and run the application. Given the nature of the game and the fully random nature of the plays you should have around 1/3 of player 1 wins, 1/3 of player 2's and 1/3 of draws. This concludes the step 2 of the tutorial: you implemented your first actor and your first environment. Let\u2019s move on to learning more about rewards in step 3 .","title":"Step 2: Implement actor and environment"},{"location":"cogment/tutorial/2-random-player/#step-2-implement-a-first-actor-and-environment","text":"This part of the tutorial follows step 1 , make sure you've gone through it before starting this one. Alternatively, the completed step 1 can be retrieved from the tutorial's repository . In this step of the tutorial, we will implement the (very simple) decison logic for the random player as well as the base mechanics for RPS, i.e. the rules of the game, in the environment services.","title":"Step 2: Implement a first actor and environment"},{"location":"cogment/tutorial/2-random-player/#random-player-agent","text":"In the rps directory, the random_agent directory contains the python implementation for the eponymous service. You'll find two files here: requirements.txt is a pip requirement file defining the dependencies of the service. For the moment it only lists cogment , Cogment's python SDK. main.py contains the implementation of the service. Open main.py and take a look at the generated content. At the bottom you'll find the main function, it initializes Cogment's context, registers the random_agent actor's implementation, then starts the service itsef on tcp port 9000 and awaits its termination. Cogment's python sdk leverages Python's asynchronous features , you'll need a basic understanding of them. async def main(): print(\"Random-Agent actor service up and running.\") context = cogment.Context(cog_settings=cog_settings, user_id=\"rps\") context.register_actor( impl=random_agent, impl_name=\"random_agent\", actor_classes=[\"player\",]) await context.serve_all_registered(cogment.ServedEndpoint(port=9000)) At the beginning of the file, the function random_agent is the actor's implementation. This function is called once per actor and per trial and handles the full lifetime of the actor. The actor's initialization , before the async for . This is where, for example, actor's internal data can be defined before calling actor_session.start() to notify that it is ready, Its event loop , the content of the async for . This is where resides the implementation of the actor's response to various events, Its termination , after the async for . The generated implementation is very simple: it handles the three main kind of events: observations , rewards and messages , it does a default action whenever required, i.e. in response to an observation. We will further learn about how to use rewards in step 3 and observations in step 4 . Messages are out of the scope for this basics tutorial. Please note the import and usage of PlayerAction which is the data structure from data.proto defining the actor's action space. async def random_agent(actor_session): actor_session.start() async for event in actor_session.event_loop(): if event.observation: observation = event.observation print(f\"'{actor_session.name}' received an observation: '{observation}'\") if event.type == cogment.EventType.ACTIVE: action = PlayerAction() actor_session.do_action(action) for reward in event.rewards: print(f\"'{actor_session.name}' received a reward for tick #{reward.tick_id}: {reward.value}\") for message in event.messages: print(f\"'{actor_session.name}' received a message from '{message.sender_name}': - '{message.payload}'\") Our goal is to implement an actor playing at random. We first need to import the different Move , as defined in our data structures. We also need to import random , the python package generating random numbers. from data_pb2 import ROCK, PAPER, SCISSORS import random MOVES = [ROCK, PAPER, SCISSORS] MOVES_STR = [\"\ud83d\udc4a rock\", \"\u270b paper\", \"\u270c\ufe0f scissors\"] Once this is available we can simply update the taking decision part of the actor's implementation to compute a random move whenever it is needed. if event.observation: observation = event.observation print(f\"'{actor_session.name}' received an observation: '{observation}'\") if event.type == cogment.EventType.ACTIVE: action = PlayerAction(move=random.choice(MOVES)) actor_session.do_action(action) Modify the random_agent/main.py file to include the above additions.","title":"Random player agent"},{"location":"cogment/tutorial/2-random-player/#implementing-the-rules-of-the-game","text":"In the rps directory, the environment directory contains the python implementation for the eponymous service. Similarly to the actor's service, you will find two files here, requirements.txt and main.py . Open main.py and take a look at the generated content. The code is very similar to the random_agent 's. In the main function, instead of using register_actor , register_environment is used. The implementation function, called environment here, is structured similarly to the actor's one but handles two kinds of events: actions (and the last actions of a trial final_actions ) and message . Environments don't perform actions, they produce observations that are sent to the actors participating in the trial. Please note the import and usage of Observation which is the datastructure defined in data.proto defining the actors observation space. async def environment(environment_session): print(\"environment starting\") # Create the initial observaton observation = Observation() # Start the trial and send that observation to all actors environment_session.start([(\"*\", observation)]) async for event in environment_session.event_loop(): if event.actions: actions = event.actions print(f\"environment received the actions\") for actor, recv_action in zip(environment_session.get_active_actors(), actions): print(f\" actor '{actor.actor_name}' did action '{recv_action.action}'\") observation = Observation() if event.type == cogment.EventType.ACTIVE: # The trial is active environment_session.produce_observations([(\"*\", observation)]) else: # The trial termination has been requested environment_session.end([(\"*\", observation)]) for message in event.messages: print(f\"environment received a message from '{message.sender_name}': - '{message.payload}'\") print(\"environment end\") Our goal, in this section, is to implement how the environment computes the observations from the actions done by the actors at a given timestep. We first import the needed datastructure and define a dictionary mapping each move to the move that defeats it. from data_pb2 import PlayerState, ROCK, PAPER, SCISSORS DEFEATS = { ROCK: PAPER, SCISSORS: ROCK, PAPER: SCISSORS } In the initialization phase of the environment implementation, i.e. before the async for , we create a simple state data structure that is keeping around the number of rounds played and won by each of the two players. We then compute the initial observation for each of the two players. One instance of PlayerState per player is created, each is used as the me and them state of each player's observation. state = { \"rounds_count\": 0, \"p1\": { \"won_rounds_count\": 0 }, \"p2\": { \"won_rounds_count\": 0 }, } print(\"environment starting\") [p1, p2] = environment_session.get_active_actors() p1_state = PlayerState(won_last=False, last_move=None) p2_state = PlayerState(won_last=False, last_move=None) environment_session.start([ (p1.actor_name, Observation(me=p1_state, them=p2_state)), (p2.actor_name, Observation(me=p2_state, them=p1_state)), ]) In the event loop we implement how the environment produces observations based on the actor's actions. We start by retrieving each player's action and computing who won the round. Then, we update the internal state . Finally, we produce up-to-date observations for the players. if event.actions: [p1_action, p2_action] = [recv_action.action for recv_action in event.actions] print(f\"{p1.actor_name} played {MOVES_STR[p1_action.move]}\") print(f\"{p2.actor_name} played {MOVES_STR[p2_action.move]}\") # Compute who wins, if the two players had the same move, nobody wins p1_state = PlayerState( won_last=p1_action.move == DEFEATS[p2_action.move], last_move=p1_action.move ) p2_state = PlayerState( won_last=p2_action.move == DEFEATS[p1_action.move], last_move=p2_action.move ) state[\"rounds_count\"] += 1 if p1_state.won_last: state[\"p1\"][\"won_rounds_count\"] += 1 print(f\"{p1.actor_name} wins!\") elif p2_state.won_last: state[\"p2\"][\"won_rounds_count\"] += 1 print(f\"{p2.actor_name} wins!\") else: print(f\"draw.\") # Generate and send observations observations = [ (p1.actor_name, Observation(me=p1_state, them=p2_state)), (p2.actor_name, Observation(me=p2_state, them=p1_state)), ] if event.type == cogment.EventType.ACTIVE: # The trial is active environment_session.produce_observations(observations) else: # The trial termination has been requested environment_session.end(observations) Finally, in the termination phase, we print some stats about the trial itself. print(\"environment end\") print(f\"\\t * {state['rounds_count']} rounds played\") print(f\"\\t * {p1.actor_name} won {state['p1']['won_rounds_count']} rounds\") print(f\"\\t * {p1.actor_name} won {state['p2']['won_rounds_count']} rounds\") print(f\"\\t * {state['rounds_count'] - state['p1']['won_rounds_count'] - state['p2']['won_rounds_count']} draws\") Modify the environment/main.py file to include the above additions. Please note that this code makes assumptions on the number of actors and their classes. Production code should handle non-standard cases in a better way. You can now build and run the application. Given the nature of the game and the fully random nature of the plays you should have around 1/3 of player 1 wins, 1/3 of player 2's and 1/3 of draws. This concludes the step 2 of the tutorial: you implemented your first actor and your first environment. Let\u2019s move on to learning more about rewards in step 3 .","title":"Implementing the rules of the game"},{"location":"cogment/tutorial/3-rewards/","text":"Step 3 - Rewards \u00b6 This part of the tutorial follows step 2 , make sure you've gone through it before starting this one. Alternatively the completed step 2 can be retrieved from the tutorial's repository . In this step of the tutorial, we will start thinking about rewards. Rewards are a way to evaluate how an actor performs at a task. They can be used to evaluate or compare different implementations of an actor, or, especially in the context or Reinforcement Learning, train an model. In Cogment, both the environment and other actors can evaluate an actor. Here, we will focus on sending rewards from the environment. The first thing we'll do for this step is to add the concept of multi-round games to our RPS implementation. We'll learn to configure the environment along the way. Then, we will adapt the environment implementation to send a reward to the actor winning a game. Finally, we will retrieve rewards and other metrics from the running Cogment app. Adding the concept of a game \u00b6 Up until now, our implementation of RPS focused on rounds. However, RPS is usually played in games won by the player reaching a target score, i.e. a number of won rounds. Before sending rewards we need to adapt our implementation to support games. We will make the target score of each game configurable. The generated data structure EnvConfig , referenced within cogment.yaml in environment.config_type , defines the configuration of the environment. Let's add a target_game_score numerical property to it. message EnvConfig { int32 target_game_score = 1; } Modify the data.proto file with this update. The environment implementation can now be updated to know about games. During the initialization phase of the environment function, we can retrieve the value from the environment's configuration. target_game_score = environment_session.config.target_game_score Instead of counting rounds we update the state variable to count games and the score of the ongoing game. state = { \"games_count\": 0, \"p1\": { \"won_games_count\": 0, \"current_game_score\": 0 }, \"p2\": { \"won_games_count\": 0, \"current_game_score\": 0 }, } In the event loop we need to make two changes. First, Instead of counting the rounds, we will update each player current_game_score . if p1_state.won_last: state[\"p1\"][\"current_game_score\"] += 1 elif p2_state.won_last: state[\"p2\"][\"current_game_score\"] += 1 Second, once the observation is sent, we detect the end of each game and update the state accordingly. # Update the game scores if state[\"p1\"][\"current_game_score\"] >= target_game_score: state[\"games_count\"] += 1 state[\"p1\"][\"current_game_score\"] = 0 state[\"p2\"][\"current_game_score\"] = 0 state[\"p1\"][\"won_games_count\"] += 1 print(f\"{p1.actor_name} won game #{state['games_count']}\") elif state[\"p2\"][\"current_game_score\"] >= target_game_score: state[\"games_count\"] += 1 state[\"p1\"][\"current_game_score\"] = 0 state[\"p2\"][\"current_game_score\"] = 0 state[\"p2\"][\"won_games_count\"] += 1 print(f\"{p2.actor_name} won game #{state['games_count']}\") Finally, during the termination , we display stats about the games. print(f\"\\t * {state['games_count']} games played\") print(f\"\\t * {p1.actor_name} won {state['p1']['won_games_count']} games\") print(f\"\\t * {p2.actor_name} won {state['p2']['won_games_count']} games\") Modify the environment/main.py file with these updates. Now that the data structure is modified and the environment implementation uses it, we can define, for the default trial, a value for the target_game_score property. Let's start with games of 2 winning rounds. trial_params: environment: endpoint: grpc://environment:9000 config: target_game_score: 2 Modify the cogment.yaml file with this update. You can now build and run the application to check that it works as expected. In this simple implementation, the concept of game is local to the environment. It has no impact on the observation and action spaces, and thus no impact on the actor implementation. This means an actor wouldn't know that the round it currently plays is the tie breaker in a game or its very first round. As a result the actor will play every round the same way. Sending rewards to the actors \u00b6 The environment is now able to: compute when an actor wins a game, communicate this information to it and to the other Cogment app services, send rewards when an actor reaches a measurable goal, in our case, when it wins a game. Please note, that not all actions need to be rewarded. When a game is won, the environment will add a positive reward to the winner (we chose a value of 1) and a negative reward to the loser (we chose a value of -1). Cogment also supports the notion of confidence , a weight between 0 and 1 that expresses the qualification of the reward sender in its appreciation. In this case we are applying objective rules, so we use a confidence of 1. In the event loop , when the first player wins a game we add the following. environment_session.add_reward(value=1, confidence=1, to=[p1.actor_name]) environment_session.add_reward(value=-1, confidence=1, to=[p2.actor_name]) When the second player wins a game we add the following. environment_session.add_reward(value=-1, confidence=1, to=[p1.actor_name]) environment_session.add_reward(value=1, confidence=1, to=[p2.actor_name]) Modify the environment/main.py file to include the above additions. You can now build and run the application to check that it works as expected. In particular you should see logs relative to the reception of rewards on the actor side. Using the metrics and dashboard services to retrieve & visualize the rewards over time \u00b6 Now that we have introduced rewards, it's a good time to take a look at Cogment's dashboard, a web app centralizing metrics from the various Cogment components. To learn more about this, refer to the dedicated page . If it's not already running, start the Cogment app: $ cogment run start In your browser of choice you can now open http://localhost:3003 and explore. If you haven't yet launched any trials, it should be mostly empty. To launch a trial, proceed as usual: in another terminal run, $ cogment run client You can now check the reward dashboard to see which of the players performs better. Keep in mind that both players play randomly so don't expect to observe any interesting trends yet. You can launch several trials to get more data. The screenshot above shows the default reward dashboard. On the top row, it shows the reward received per individual actor, on the left is the rate averaged over the last 2 minutes, on the right is the total per trial. On the middle row, you'll find the same metrics but aggregated per actor implementation, one in our case. On the bottom row is the averaged reward over the last 5 minutes for all the actors. In tutorial 7 , we will use this dashboard to monitor the training of an agent implementation. This concludes the step 3 of the tutorial: you've learned about environment configuration, implemented your reward sending and used the metrics and dashboard services. Let\u2019s move on to implementing an RPS player that actually considers what was played before deciding on its next move in step 4 .","title":"Step 3: Introduce rewards"},{"location":"cogment/tutorial/3-rewards/#step-3-rewards","text":"This part of the tutorial follows step 2 , make sure you've gone through it before starting this one. Alternatively the completed step 2 can be retrieved from the tutorial's repository . In this step of the tutorial, we will start thinking about rewards. Rewards are a way to evaluate how an actor performs at a task. They can be used to evaluate or compare different implementations of an actor, or, especially in the context or Reinforcement Learning, train an model. In Cogment, both the environment and other actors can evaluate an actor. Here, we will focus on sending rewards from the environment. The first thing we'll do for this step is to add the concept of multi-round games to our RPS implementation. We'll learn to configure the environment along the way. Then, we will adapt the environment implementation to send a reward to the actor winning a game. Finally, we will retrieve rewards and other metrics from the running Cogment app.","title":"Step 3 - Rewards"},{"location":"cogment/tutorial/3-rewards/#adding-the-concept-of-a-game","text":"Up until now, our implementation of RPS focused on rounds. However, RPS is usually played in games won by the player reaching a target score, i.e. a number of won rounds. Before sending rewards we need to adapt our implementation to support games. We will make the target score of each game configurable. The generated data structure EnvConfig , referenced within cogment.yaml in environment.config_type , defines the configuration of the environment. Let's add a target_game_score numerical property to it. message EnvConfig { int32 target_game_score = 1; } Modify the data.proto file with this update. The environment implementation can now be updated to know about games. During the initialization phase of the environment function, we can retrieve the value from the environment's configuration. target_game_score = environment_session.config.target_game_score Instead of counting rounds we update the state variable to count games and the score of the ongoing game. state = { \"games_count\": 0, \"p1\": { \"won_games_count\": 0, \"current_game_score\": 0 }, \"p2\": { \"won_games_count\": 0, \"current_game_score\": 0 }, } In the event loop we need to make two changes. First, Instead of counting the rounds, we will update each player current_game_score . if p1_state.won_last: state[\"p1\"][\"current_game_score\"] += 1 elif p2_state.won_last: state[\"p2\"][\"current_game_score\"] += 1 Second, once the observation is sent, we detect the end of each game and update the state accordingly. # Update the game scores if state[\"p1\"][\"current_game_score\"] >= target_game_score: state[\"games_count\"] += 1 state[\"p1\"][\"current_game_score\"] = 0 state[\"p2\"][\"current_game_score\"] = 0 state[\"p1\"][\"won_games_count\"] += 1 print(f\"{p1.actor_name} won game #{state['games_count']}\") elif state[\"p2\"][\"current_game_score\"] >= target_game_score: state[\"games_count\"] += 1 state[\"p1\"][\"current_game_score\"] = 0 state[\"p2\"][\"current_game_score\"] = 0 state[\"p2\"][\"won_games_count\"] += 1 print(f\"{p2.actor_name} won game #{state['games_count']}\") Finally, during the termination , we display stats about the games. print(f\"\\t * {state['games_count']} games played\") print(f\"\\t * {p1.actor_name} won {state['p1']['won_games_count']} games\") print(f\"\\t * {p2.actor_name} won {state['p2']['won_games_count']} games\") Modify the environment/main.py file with these updates. Now that the data structure is modified and the environment implementation uses it, we can define, for the default trial, a value for the target_game_score property. Let's start with games of 2 winning rounds. trial_params: environment: endpoint: grpc://environment:9000 config: target_game_score: 2 Modify the cogment.yaml file with this update. You can now build and run the application to check that it works as expected. In this simple implementation, the concept of game is local to the environment. It has no impact on the observation and action spaces, and thus no impact on the actor implementation. This means an actor wouldn't know that the round it currently plays is the tie breaker in a game or its very first round. As a result the actor will play every round the same way.","title":"Adding the concept of a game"},{"location":"cogment/tutorial/3-rewards/#sending-rewards-to-the-actors","text":"The environment is now able to: compute when an actor wins a game, communicate this information to it and to the other Cogment app services, send rewards when an actor reaches a measurable goal, in our case, when it wins a game. Please note, that not all actions need to be rewarded. When a game is won, the environment will add a positive reward to the winner (we chose a value of 1) and a negative reward to the loser (we chose a value of -1). Cogment also supports the notion of confidence , a weight between 0 and 1 that expresses the qualification of the reward sender in its appreciation. In this case we are applying objective rules, so we use a confidence of 1. In the event loop , when the first player wins a game we add the following. environment_session.add_reward(value=1, confidence=1, to=[p1.actor_name]) environment_session.add_reward(value=-1, confidence=1, to=[p2.actor_name]) When the second player wins a game we add the following. environment_session.add_reward(value=-1, confidence=1, to=[p1.actor_name]) environment_session.add_reward(value=1, confidence=1, to=[p2.actor_name]) Modify the environment/main.py file to include the above additions. You can now build and run the application to check that it works as expected. In particular you should see logs relative to the reception of rewards on the actor side.","title":"Sending rewards to the actors"},{"location":"cogment/tutorial/3-rewards/#using-the-metrics-and-dashboard-services-to-retrieve-visualize-the-rewards-over-time","text":"Now that we have introduced rewards, it's a good time to take a look at Cogment's dashboard, a web app centralizing metrics from the various Cogment components. To learn more about this, refer to the dedicated page . If it's not already running, start the Cogment app: $ cogment run start In your browser of choice you can now open http://localhost:3003 and explore. If you haven't yet launched any trials, it should be mostly empty. To launch a trial, proceed as usual: in another terminal run, $ cogment run client You can now check the reward dashboard to see which of the players performs better. Keep in mind that both players play randomly so don't expect to observe any interesting trends yet. You can launch several trials to get more data. The screenshot above shows the default reward dashboard. On the top row, it shows the reward received per individual actor, on the left is the rate averaged over the last 2 minutes, on the right is the total per trial. On the middle row, you'll find the same metrics but aggregated per actor implementation, one in our case. On the bottom row is the averaged reward over the last 5 minutes for all the actors. In tutorial 7 , we will use this dashboard to monitor the training of an agent implementation. This concludes the step 3 of the tutorial: you've learned about environment configuration, implemented your reward sending and used the metrics and dashboard services. Let\u2019s move on to implementing an RPS player that actually considers what was played before deciding on its next move in step 4 .","title":"Using the metrics and dashboard services to retrieve &amp; visualize the rewards over time"},{"location":"cogment/tutorial/4-heuristic-player/","text":"Step 4: Add a second actor implementation based on a heuristic \u00b6 This part of the tutorial follows step 3 , make sure you've gone through it before starting this one. Alternatively the completed step 3 can be retrieved from the tutorial's repository . In this step of the tutorial, we will go over another actor implementation and learn about using the received observations before doing an action. Creating a second actor implementation \u00b6 Let's start by creating another implementation of the player actor class. Because we expect it to be rather small and not use additional dependencies, this second implementation will live in the same service as the previous one. We will start by copying the random_agent implementation. In random_agent/main.py copy/paste the random_agent function and name it heuristic_agent . async def heuristic_agent(actor_session): Then, in the same file, register this \"new\" implementation in the main function. context.register_actor( impl=heuristic_agent, impl_name=\"heuristic_agent\", actor_classes=[\"player\"]) When the service starts it will now host the two implementations. We can now configure one of the player in the default trial, defined in cogment.yaml , to use the heuristic_agent implementation. actors: - name: player_1 actor_class: player implementation: random_agent endpoint: grpc://random-agent:9000 - name: player_2 actor_class: player implementation: heuristic_agent endpoint: grpc://random-agent:9000 Modify the cogment.yaml file to include the above addition. You can now build and run the application to check that it still works. Nothing should have changed except one of the player uses the code from the new implementation. Implementing a simple heuristic's agent \u00b6 While the random_player ignored the state of the game, picking its move at random, our new implementation will consider the received observations to pick its move. We will implement a subset of the strategies described in this article: If I won the last round, do the same thing, If my opponent won the last round, play the move that would have won against his, If the last round was a draw, play a random move. We will start by redefining in random_agent/main.py the same DEFEATS we used by the environment. DEFEATS = { ROCK: PAPER, SCISSORS: ROCK, PAPER: SCISSORS } Then, in the event loop, we look at the received observation before taking an action based on this simple strategy. observation = event.observation print(f\"'{actor_session.name}' received an observation: '{observation}'\") if event.type == cogment.EventType.ACTIVE: if observation.snapshot.me.won_last: # I won the last round, let's play the same thing actor_session.do_action(PlayerAction(move=observation.snapshot.me.last_move)) elif observation.snapshot.them.won_last: # I lost the last round, let's play what would have won actor_session.do_action(PlayerAction(move=DEFEATS[observation.snapshot.them.last_move])) else: # last round was a draw, let's play randomly actor_session.do_action(PlayerAction(move=random.choice(MOVES))) Modify the random_player/main.py file accordingly. You can now build and run the application to check that it works. Don't expect the heuristic player to beat the random player, the nature of the game actually rewards pure randomness in the playing. You can however implement various strategies and see how they fare against each other. This concludes the step 4 of the tutorial: you've learned about adding and using different implementations of an actor class and how to access and use the received observations. Let\u2019s move on to adding a human player in the mix with step 5 .","title":"Step 4: Create a heuristic player"},{"location":"cogment/tutorial/4-heuristic-player/#step-4-add-a-second-actor-implementation-based-on-a-heuristic","text":"This part of the tutorial follows step 3 , make sure you've gone through it before starting this one. Alternatively the completed step 3 can be retrieved from the tutorial's repository . In this step of the tutorial, we will go over another actor implementation and learn about using the received observations before doing an action.","title":"Step 4: Add a second actor implementation based on a heuristic"},{"location":"cogment/tutorial/4-heuristic-player/#creating-a-second-actor-implementation","text":"Let's start by creating another implementation of the player actor class. Because we expect it to be rather small and not use additional dependencies, this second implementation will live in the same service as the previous one. We will start by copying the random_agent implementation. In random_agent/main.py copy/paste the random_agent function and name it heuristic_agent . async def heuristic_agent(actor_session): Then, in the same file, register this \"new\" implementation in the main function. context.register_actor( impl=heuristic_agent, impl_name=\"heuristic_agent\", actor_classes=[\"player\"]) When the service starts it will now host the two implementations. We can now configure one of the player in the default trial, defined in cogment.yaml , to use the heuristic_agent implementation. actors: - name: player_1 actor_class: player implementation: random_agent endpoint: grpc://random-agent:9000 - name: player_2 actor_class: player implementation: heuristic_agent endpoint: grpc://random-agent:9000 Modify the cogment.yaml file to include the above addition. You can now build and run the application to check that it still works. Nothing should have changed except one of the player uses the code from the new implementation.","title":"Creating a second actor implementation"},{"location":"cogment/tutorial/4-heuristic-player/#implementing-a-simple-heuristics-agent","text":"While the random_player ignored the state of the game, picking its move at random, our new implementation will consider the received observations to pick its move. We will implement a subset of the strategies described in this article: If I won the last round, do the same thing, If my opponent won the last round, play the move that would have won against his, If the last round was a draw, play a random move. We will start by redefining in random_agent/main.py the same DEFEATS we used by the environment. DEFEATS = { ROCK: PAPER, SCISSORS: ROCK, PAPER: SCISSORS } Then, in the event loop, we look at the received observation before taking an action based on this simple strategy. observation = event.observation print(f\"'{actor_session.name}' received an observation: '{observation}'\") if event.type == cogment.EventType.ACTIVE: if observation.snapshot.me.won_last: # I won the last round, let's play the same thing actor_session.do_action(PlayerAction(move=observation.snapshot.me.last_move)) elif observation.snapshot.them.won_last: # I lost the last round, let's play what would have won actor_session.do_action(PlayerAction(move=DEFEATS[observation.snapshot.them.last_move])) else: # last round was a draw, let's play randomly actor_session.do_action(PlayerAction(move=random.choice(MOVES))) Modify the random_player/main.py file accordingly. You can now build and run the application to check that it works. Don't expect the heuristic player to beat the random player, the nature of the game actually rewards pure randomness in the playing. You can however implement various strategies and see how they fare against each other. This concludes the step 4 of the tutorial: you've learned about adding and using different implementations of an actor class and how to access and use the received observations. Let\u2019s move on to adding a human player in the mix with step 5 .","title":"Implementing a simple heuristic's agent"},{"location":"cogment/tutorial/5-human-player/","text":"Step 5: Add a human player in the loop \u00b6 This part of the tutorial follows step 4 , make sure you've gone through it before starting this one. Alternatively the completed step 4 can be retrieved from the tutorial's repository . In this step of the tutorial, we will go over another actor implementation, this time client-side, to enable Humans to play RPS. We will also learn how to let the environment control the termination of the trial. The client \u00b6 In the previous steps, we triggered the trials by running cogment run client . The more curious among you will have understood that this launches a client of the Cogment app, implemented in client/main.py . In this step, we will make changes to this file, this is therefore a good time to take a look at it. Open client/main.py and take a look at the generated content. The main starts similarly to the others by creating and configuring the main entry point to the SDK, Context . Then a trial_controller function is created: it enables retrieving the unique id for a trial and controls its lifetime (ending it by default after 10 seconds). Finally, a trial is started on the running orchestrator , using trial_controller and a default trial configuration. async def trial_controller(control_session): print(f\"Trial '{control_session.get_trial_id()}' starts\") await asyncio.sleep(10) print(f\"Trial '{control_session.get_trial_id()}' terminating\") await control_session.terminate_trial() await context.start_trial(endpoint=\"orchestrator:9000\", impl=trial_controller, trial_config=TrialConfig()) Environment controlled trial \u00b6 While 10 seconds was plenty of time to get a decent number of AI vs AI games played, a Human player won't be as fast: we need to change how we control the duration and number of played games. To do that, we will switch from controlling the trial lifetime from the client's trial controller, to controlling it from the environment. Instead of a duration, our trial will last for a given number of games. That way AI vs AI trials will be configurable to last hundreds of games while trials involving Humans can be much shorter. Let's introduce a new property of the environment configuration, target_games_count , in data.proto . message EnvConfig { int32 target_game_score = 1; int32 target_games_count = 2; } We can then set its value for the default trial in cogment.yaml . trial_params: environment: endpoint: grpc://environment:9000 config: target_game_score: 2 target_games_count: 5 Environment implementations can trigger the end of a trial by calling the end function on the session instance. In our existing implementation, we will first prepare the observations instead of producing them right away. observations = [ (p1.actor_name, Observation(me=p1_state, them=p2_state)), (p2.actor_name, Observation(me=p2_state, them=p1_state)), ] And then, at the end of the event loop, either end the trial if the target games count is reached or produce the observations as before. if state[\"games_count\"]>=environment_session.config.target_games_count: environment_session.end(observations=observations) else: environment_session.produce_observations(observations=observations) Edit the environment/main.py file to include the above additions. You can now build and run the application. It should be much faster than before as the AIs only play 5 games. Client actor implementation \u00b6 We are now ready to involve a human player in our trials. To do that we will add a specific actor implementation in the client. While the previous service actor implementations are exposing endpoints Cogment's orchestrator connects to in order to run a trial, this client actor implementation connects to the orchestrator to join a trial. It changes a lot under the hood and enables interesting network topology because only the client needs to know how to reach the orchestrator, not the other way around. However, as you'll see, in terms of implementation it is very similar. This actor implementation will be located in the client code in client/main.py We first need to import the data structures needed to send actions. from data_pb2 import PlayerAction, ROCK, PAPER, SCISSORS MOVES = [ROCK, PAPER, SCISSORS] MOVES_STR = [\"\ud83d\udc4a rock\", \"\u270b paper\", \"\u270c\ufe0f scissors\"] MOVES_PROMPT = ', '.join([ f\"{name} ({idx})\" for idx, name in enumerate(MOVES_STR)]) In the main function we then implement the human_player actor implementation, only playing PAPER for the moment, register the implementation and join the trial once it is initialized. context = cogment.Context(cog_settings=cog_settings, user_id=\"rps\") async def human_player(actor_session): round_index = 0 actor_session.start() async for event in actor_session.event_loop(): if event.observation: observation = event.observation if event.type == cogment.EventType.ACTIVE: print(f\"\\n-- Round #{round_index + 1} --\\n\") next_action = PlayerAction(move=PAPER) actor_session.do_action(next_action) round_index += 1 context.register_actor( impl=human_player, impl_name=\"human\", actor_classes=[\"player\"]) # Create a controller controller = context.get_controller(endpoint=cogment.Endpoint(\"orchestrator:9000\")) # Start a new trial trial_id = await controller.start_trial(trial_config=TrialConfig()) print(f\"Trial '{trial_id}' starting\") # Let the human actor join the trial await context.join_trial(trial_id=trial_id, endpoint=cogment.Endpoint(\"orchestrator:9000\"), impl_name=\"human\") print(f\"Human actor joining trial '{trial_id}'\") # Wait for the trial to end by itself async for trial_info in controller.watch_trials(trial_state_filters=[cogment.TrialState.ENDED]): if trial_info.trial_id == trial_id: break print(f\"Trial '{trial_id}' ended\") Modify the client/main.py file with these updates. We then need to modify the cogment.yaml to let the orchestrator know that player_1 now uses a client-side implementation. To do so we use a special endpoint, \"cogment://client\" , and we don't need to specify an implementation name. actors: - name: player_1 actor_class: player endpoint: cogment://client # implementation: random_agent # endpoint: grpc://random-agent:9000 You can now build and run the application. Everything should work but player 1 shouldn't fare too well as it only ever plays PAPER . Interactive prompt to let Humans play RPS \u00b6 Let's add a text user interface to our client in order to finally challenge AIs to a game of RPS. First we'll want to display what was played in the previous round. We will implement a dedicated function print_observation . def print_observation(round_index, observation): print(f\"\ud83e\uddd1 played {MOVES_STR[observation.snapshot.me.last_move]}\") print(f\"\ud83e\udd16 played {MOVES_STR[observation.snapshot.them.last_move]}\") if observation.snapshot.me.won_last: print(f\" -> \ud83e\uddd1 wins round #{round_index + 1}\") elif observation.snapshot.them.won_last: print(f\" -> \ud83e\udd16 wins the round #{round_index + 1}\") else: print(f\" -> round #{round_index + 1} is a draw\") It needs to be called whenever the actor receives an observation, except for the first time, before the first round is played. Add the following just after the observation is retrieved in the event loop. if round_index > 0: # The only time the observation is not relevant is on the first round of the first game print_observation(round_index, observation) Last but not least, instead of always picking PAPER we will read from the keyboard input what the player wishes to play. Using python's input function we can print a prompt and read whatever the user enters before pressing <ENTER> . Note that the following implementation expects a number between 1 and 3 and doesn't handle well any other input. move = MOVES[int(input(MOVES_PROMPT))] next_action = PlayerAction(move=move) Modify the client/main.py file to include the above additions. You can now build and run the application. You'll be presented with a prompt for choosing your moves and comparing your skills to the simple heuristic AI we implemented earlier. This concludes the step 5 of the tutorial: you implemented your first client actor and put your first human in the loop! This is also the final step for the basics tutorial. You can continue by implementing a web client to replace the command line interface we just developed in step 6 . You can also learn how to train an actor implementation using Reinforcement Learning in step 7 .","title":"Step 5: Add a human player in the loop"},{"location":"cogment/tutorial/5-human-player/#step-5-add-a-human-player-in-the-loop","text":"This part of the tutorial follows step 4 , make sure you've gone through it before starting this one. Alternatively the completed step 4 can be retrieved from the tutorial's repository . In this step of the tutorial, we will go over another actor implementation, this time client-side, to enable Humans to play RPS. We will also learn how to let the environment control the termination of the trial.","title":"Step 5: Add a human player in the loop"},{"location":"cogment/tutorial/5-human-player/#the-client","text":"In the previous steps, we triggered the trials by running cogment run client . The more curious among you will have understood that this launches a client of the Cogment app, implemented in client/main.py . In this step, we will make changes to this file, this is therefore a good time to take a look at it. Open client/main.py and take a look at the generated content. The main starts similarly to the others by creating and configuring the main entry point to the SDK, Context . Then a trial_controller function is created: it enables retrieving the unique id for a trial and controls its lifetime (ending it by default after 10 seconds). Finally, a trial is started on the running orchestrator , using trial_controller and a default trial configuration. async def trial_controller(control_session): print(f\"Trial '{control_session.get_trial_id()}' starts\") await asyncio.sleep(10) print(f\"Trial '{control_session.get_trial_id()}' terminating\") await control_session.terminate_trial() await context.start_trial(endpoint=\"orchestrator:9000\", impl=trial_controller, trial_config=TrialConfig())","title":"The client"},{"location":"cogment/tutorial/5-human-player/#environment-controlled-trial","text":"While 10 seconds was plenty of time to get a decent number of AI vs AI games played, a Human player won't be as fast: we need to change how we control the duration and number of played games. To do that, we will switch from controlling the trial lifetime from the client's trial controller, to controlling it from the environment. Instead of a duration, our trial will last for a given number of games. That way AI vs AI trials will be configurable to last hundreds of games while trials involving Humans can be much shorter. Let's introduce a new property of the environment configuration, target_games_count , in data.proto . message EnvConfig { int32 target_game_score = 1; int32 target_games_count = 2; } We can then set its value for the default trial in cogment.yaml . trial_params: environment: endpoint: grpc://environment:9000 config: target_game_score: 2 target_games_count: 5 Environment implementations can trigger the end of a trial by calling the end function on the session instance. In our existing implementation, we will first prepare the observations instead of producing them right away. observations = [ (p1.actor_name, Observation(me=p1_state, them=p2_state)), (p2.actor_name, Observation(me=p2_state, them=p1_state)), ] And then, at the end of the event loop, either end the trial if the target games count is reached or produce the observations as before. if state[\"games_count\"]>=environment_session.config.target_games_count: environment_session.end(observations=observations) else: environment_session.produce_observations(observations=observations) Edit the environment/main.py file to include the above additions. You can now build and run the application. It should be much faster than before as the AIs only play 5 games.","title":"Environment controlled trial"},{"location":"cogment/tutorial/5-human-player/#client-actor-implementation","text":"We are now ready to involve a human player in our trials. To do that we will add a specific actor implementation in the client. While the previous service actor implementations are exposing endpoints Cogment's orchestrator connects to in order to run a trial, this client actor implementation connects to the orchestrator to join a trial. It changes a lot under the hood and enables interesting network topology because only the client needs to know how to reach the orchestrator, not the other way around. However, as you'll see, in terms of implementation it is very similar. This actor implementation will be located in the client code in client/main.py We first need to import the data structures needed to send actions. from data_pb2 import PlayerAction, ROCK, PAPER, SCISSORS MOVES = [ROCK, PAPER, SCISSORS] MOVES_STR = [\"\ud83d\udc4a rock\", \"\u270b paper\", \"\u270c\ufe0f scissors\"] MOVES_PROMPT = ', '.join([ f\"{name} ({idx})\" for idx, name in enumerate(MOVES_STR)]) In the main function we then implement the human_player actor implementation, only playing PAPER for the moment, register the implementation and join the trial once it is initialized. context = cogment.Context(cog_settings=cog_settings, user_id=\"rps\") async def human_player(actor_session): round_index = 0 actor_session.start() async for event in actor_session.event_loop(): if event.observation: observation = event.observation if event.type == cogment.EventType.ACTIVE: print(f\"\\n-- Round #{round_index + 1} --\\n\") next_action = PlayerAction(move=PAPER) actor_session.do_action(next_action) round_index += 1 context.register_actor( impl=human_player, impl_name=\"human\", actor_classes=[\"player\"]) # Create a controller controller = context.get_controller(endpoint=cogment.Endpoint(\"orchestrator:9000\")) # Start a new trial trial_id = await controller.start_trial(trial_config=TrialConfig()) print(f\"Trial '{trial_id}' starting\") # Let the human actor join the trial await context.join_trial(trial_id=trial_id, endpoint=cogment.Endpoint(\"orchestrator:9000\"), impl_name=\"human\") print(f\"Human actor joining trial '{trial_id}'\") # Wait for the trial to end by itself async for trial_info in controller.watch_trials(trial_state_filters=[cogment.TrialState.ENDED]): if trial_info.trial_id == trial_id: break print(f\"Trial '{trial_id}' ended\") Modify the client/main.py file with these updates. We then need to modify the cogment.yaml to let the orchestrator know that player_1 now uses a client-side implementation. To do so we use a special endpoint, \"cogment://client\" , and we don't need to specify an implementation name. actors: - name: player_1 actor_class: player endpoint: cogment://client # implementation: random_agent # endpoint: grpc://random-agent:9000 You can now build and run the application. Everything should work but player 1 shouldn't fare too well as it only ever plays PAPER .","title":"Client actor implementation"},{"location":"cogment/tutorial/5-human-player/#interactive-prompt-to-let-humans-play-rps","text":"Let's add a text user interface to our client in order to finally challenge AIs to a game of RPS. First we'll want to display what was played in the previous round. We will implement a dedicated function print_observation . def print_observation(round_index, observation): print(f\"\ud83e\uddd1 played {MOVES_STR[observation.snapshot.me.last_move]}\") print(f\"\ud83e\udd16 played {MOVES_STR[observation.snapshot.them.last_move]}\") if observation.snapshot.me.won_last: print(f\" -> \ud83e\uddd1 wins round #{round_index + 1}\") elif observation.snapshot.them.won_last: print(f\" -> \ud83e\udd16 wins the round #{round_index + 1}\") else: print(f\" -> round #{round_index + 1} is a draw\") It needs to be called whenever the actor receives an observation, except for the first time, before the first round is played. Add the following just after the observation is retrieved in the event loop. if round_index > 0: # The only time the observation is not relevant is on the first round of the first game print_observation(round_index, observation) Last but not least, instead of always picking PAPER we will read from the keyboard input what the player wishes to play. Using python's input function we can print a prompt and read whatever the user enters before pressing <ENTER> . Note that the following implementation expects a number between 1 and 3 and doesn't handle well any other input. move = MOVES[int(input(MOVES_PROMPT))] next_action = PlayerAction(move=move) Modify the client/main.py file to include the above additions. You can now build and run the application. You'll be presented with a prompt for choosing your moves and comparing your skills to the simple heuristic AI we implemented earlier. This concludes the step 5 of the tutorial: you implemented your first client actor and put your first human in the loop! This is also the final step for the basics tutorial. You can continue by implementing a web client to replace the command line interface we just developed in step 6 . You can also learn how to train an actor implementation using Reinforcement Learning in step 7 .","title":"Interactive prompt to let Humans play RPS"},{"location":"cogment/tutorial/6-web-client/","text":"Step 6: Add a web client for the human player \u00b6 This part of the tutorial follows step 5 , make sure you've gone through it before starting this one. Alternatively the completed step 5 can be retrieved from the tutorial's repository . In this step of the tutorial, we will go over a web client implementation, to enable Humans to play RPS, while being able to take advantage of various web technologies. Prerequisites \u00b6 To develop a web client, we will need a working installation of Node.js. You can download and install this from: https://nodejs.org/en/download/ The web client \u00b6 In the previous steps, we triggered the trials by running cogment run client . This launched a trial using code in client/main.py . In this step we will trigger a trial using a React app. Before we start with the Cogment side of things, we'll need to get a few prerequisite files setup. Creating a React app \u00b6 First, we will initialize a React app. This can be done very simply by running: $ npx create-react-app web-client Once this is done, we will be able to open a React app in our browser by running the following commands: $ cd web-client $ npm start Adding Material UI \u00b6 We will be using Material UI for this web client. This will provide us with a nice and clean way to add styles to our application, as well as some components which we will use to reduce code size. Install Material UI by running the following commands from inside of the web-client folder: $ npm i @material-ui/core $ npm i @material-ui/icons Setting up Docker \u00b6 In addition to the docker-compose services we already have, we'll need two more for this web client. One to run it, and another for a proxy service called grpcwebproxy . NOTE: grpcwebproxy (link) is a helpful program that allows grpc endpoints to be utilized by web applications. Web applications cannot natively use the grpc protocol that all Cogment elements use to communicate with one another. Using this proxy to translate the web socket connections it accepts into grpc requests solves this issue. For these services, let's add the following to the end of our docker-compose.yaml: web-client: build: context: web-client dockerfile: ../js_service.dockerfile environment: - NODE_ENV=development - CHOKIDAR_USEPOLLING=true - REACT_APP_APP_VERSION=dev restart: on-failure ports: - \"3000:3000\" depends_on: - grpcwebproxy grpcwebproxy: build: context: ./grpcwebproxy dockerfile: ../grpcwebproxy.dockerfile restart: on-failure ports: - \"8080:8080\" depends_on: - orchestrator We will also need two additional dockerfiles to go along these entries. The first one will be grpcwebproxy.dockerfile , with the following content: FROM golang:1.15.2 as dev WORKDIR /go ARG GO111MODULE=auto ENV GO111MODULE=${GO111MODULE} ENV GOPATH=/go ENV COGMENT_URL=orchestrator:9000 RUN go get github.com/improbable-eng/grpc-web/go/grpcwebproxy EXPOSE 8080 CMD [\"grpcwebproxy\", \"--backend_addr=orchestrator:9000\", \"--run_tls_server=false\", \"--allow_all_origins\", \"--use_websockets\"] The second one will be js_service.dockerfile , with the following content: # pull official base image FROM node:14 as dev # set working directory WORKDIR /app EXPOSE 3000 # generate protos COPY package.json package-lock.json ./ COPY cogment.yaml ./ COPY *.proto ./ RUN mkdir src RUN npm i RUN npx cogment-js-sdk-generate cogment.yaml # copy generated app COPY . ./ # start app CMD [\"npm\", \"start\"] NOTE: Since the port for grpcwebproxy is exposed outside of the docker network, the docker-compose entry and corresponding dockerfile are not actually needed for the web-client; it can just as easily be run outside of docker. However, doing it like this makes the command to startup the application much simpler. Finally, we have to add web-client and grpcwebproxy to the start, build, and stop commands in our cogment.yaml . build: docker-compose build orchestrator environment random_agent web-client grpcwebproxy start: docker-compose up orchestrator environment random_agent web-client grpcwebproxy stop: docker-compose stop orchestrator environment random_agent web-client grpcwebproxy Adding Cogment to our web client \u00b6 The easiest way to add Cogment to any web client is to start with a React app, then follow the three steps below: Install the Javascript SDK using: $ npm i @cogment/cogment-js-sdk while inside of the web-client folder Copy the hooks folder from the tutorial's repository , found at 6-web-client/web-client/src/ , into your src directory. Navigate one folder up to your project directory (where you have your cogment.yaml) then run the following command to generate Javascript files from your defined protobufs: $ cogment copy cogment.yaml *.proto web-client NOTE: Had we chosen Y at the beginning of this tutorial when asked by the CLI if we wanted a web client, the React hooks used in this section would normally have been generated with the command cogment init .\" (optional) You can run the following commands outside of docker to generate your protobuf files if you need or want the typings at develop time $ cd web-client $ npm install $ npx cogment-js-sdk-generate cogment.yaml Now that all that's done, we can finally start coding our web client! CODE \u00b6 NOTE: For each of the following files, we will provide the styles in a code block. Feel free to skip these, or make your own; they are not important to the function of this application. index.js / index.css \u00b6 When we created our React app, these two files were generated automatically. Replace their content with the following: NOTE: These can also be downloaded from the tutorial's repository . index.css: body { margin: 0; background-color: #c5cce8; } index.js import React from \"react\"; import ReactDOM from \"react-dom\"; import \"./index.css\"; import { App } from \"./App\"; import { createMuiTheme, responsiveFontSizes, ThemeProvider, } from \"@material-ui/core/styles\"; let theme = createMuiTheme({ palette: { primary: { light: \"#c5cce8\", main: \"#6B80C4\", }, secondary: { main: \"#ffb400\", }, }, }); theme = responsiveFontSizes(theme); ReactDOM.render( <React.StrictMode> <ThemeProvider theme={theme}> <App /> </ThemeProvider> </React.StrictMode>, document.getElementById(\"root\") ); This is simply to provide styles to our Material UI components. We haven't started with the actual Cogment part yet, which is exactly what we'll be doing next. App.js \u00b6 We'll start with a few imports. Some of these files don't exist yet, so we'll be creating them: //First is some React imports import React, { useEffect } from \"react\"; //Then some imports for icons and Material UI functionality we'll be using import { Box, Button, makeStyles, Typography, useTheme, } from \"@material-ui/core\"; //And here's the important part: we're importing the two things that will allow us to use Cogment. //First, the 'useActions' hook which will give us our observations as a human agent, as well as allow us to send actions. import { useActions } from \"./hooks/useActions\"; //Second, our 'cogSettings'. This is a file that was generated when we ran //`npx cogment-js-sdk-generate cogment.yaml` //This file tells our web client relevant information about our trials, environments, and actor classes. import { cogSettings } from \"./CogSettings\"; //These are messages which were defined in data.proto. These imports will need to change whenever their corresponding messages in data.proto are changed and `npx cogment-js-sdk-generate cogment.yaml` is run. import { PlayerAction } from \"./data_pb\"; Then we add a function that will convert the play, encoded as the same \"move\" enum that we defined in our data.proto, to a string we can use in our application: function getMoveText(move) { switch (move) { case 0: return \"rock\"; case 1: return \"paper\"; case 2: return \"scissors\"; default: throw new Error(\"Not a rock, paper, or scissors\"); } } Finally, the React component. At the start of this component is the most important part of our application: the useAction hook. This hook returns an array with 3 elements: event: this contains all the information about any observation, reward, or message we've received this tick. We will use this to see what plays we and the computer made. startTrial: this is a function which takes no arguments, and is a very simple way to start a new trial with our player actor. sendAction: this is a function which takes an argument of type 'Action'. This class can be imported from data_pb.js, but we'll see that later in this tutorial. This hook takes in 3 arguments: cogSettings: this is what's imported from CogSettings.js. It provides all the relevant information about data.proto to this hook so that it can function. actorName: the name of the human actor which this web client will be representing. This is defined in cogment.yaml. actorClass: the class of the human actor which this web client will be representing. This is defined in cogment.yaml. export const App = () => { const [event, startTrial, sendAction] = useActions( cogSettings, \"player_1\", \"player\" ); //Function to construct the Action which the player will send when they click either rock, paper, or scissors const choose = (move) => { const action = new PlayerAction(); action.setMove(move); sendAction(action); }; //This will start a trial as soon as we're connected to the orchestrator useEffect(() => { if (startTrial) startTrial(); }, [startTrial]); //Get any observation from the current event, events have observations, messages, and rewards, and all three can be unpacked from the event object //We will also unpack a helpful variable called 'last', this will allow us to know when the trial has ended const { observation, last } = event; const [gameState, setGameState] = useState({ gameStage: \"start\", roundIndex: 0, lastMoveComputer: 0, lastMoveHuman: 0, }); const [firstObservation, setFirstObservation] = useState(true); useEffect(() => { //Parse game state out of the observation //Some events don't contain an observation, so we need to store the observation contents in a state if (!observation) return; //The first observation is not useful, as it just contains the default game state, before players have made moves if (firstObservation) { setFirstObservation(false); return; } //Get all relevant information from the observation const roundIndex = gameState.roundIndex + 1; const gameStage = \"playing\"; const lastMoveComputer = observation.them.lastMove; const lastMoveHuman = observation.me.lastMove; const lastWonComputer = observation.them.wonLast; const lastWonHuman = observation.me.wonLast; setGameState({ gameStage, roundIndex, lastMoveComputer, lastMoveHuman, lastWonComputer, lastWonHuman, }); // eslint-disable-next-line react-hooks/exhaustive-deps }, [observation]); //The layout of the page return ( <Box> {/* Tell the player everything we know about the trial state, such as, plays, who won, etc... */} <Typography>Game stage: {gameState.gameStage}</Typography> <Typography> Human's move:{\" \"} {gameState.gameStage !== \"start\" && getMoveText(gameState.lastMoveHuman)} </Typography> <Typography> Computer's move:{\" \"} {gameState.gameStage !== \"start\" && getMoveText(gameState.lastMoveComputer)} </Typography> <Typography> Did Human win last round?{\" \"} {observation && gameState.lastWonHuman ? \"Yes\" : \"No\"} </Typography> <Typography> Did Computer win last round?{\" \"} {observation && gameState.lastWonComputer ? \"Yes\" : \"No\"} </Typography> <Button onClick={() => choose(0)}>Rock</Button> <Button onClick={() => choose(1)}>Paper</Button> <Button onClick={() => choose(2)}>Scissors</Button> </Box> ); }; hooks/useActions.js \u00b6 NOTE: This section needs to be updated for Cogment 2.0, and will only work with Cogment versions 1.x This hook does multiple things. It starts a trial, joins a trial, sends actions, and receives information from the orchestrator. The following is its annotated code: import { Context } from \"@cogment/cogment-js-sdk\"; import { useEffect, useState } from \"react\"; export const useActions = (cogSettings, actorName, actorClass) => { const [event, setEvent] = useState({ observation: null, actions: null, messages: null, rewards: null, type: null, last: false }); const [startTrial, setStartTrial] = useState(null); const [sendAction, setSendAction] = useState(null); //Set up the connection and register the actor only once, regardless of re-rendering useEffect(() => { const context = new Context( cogSettings, actorName, ); context.registerActor(async (actorSession) => { actorSession.start(); //Double arrow function here beause react will turn a single one into a lazy loaded function setSendAction(() => (action) => { actorSession.doAction(action); }); for await (const event of actorSession.eventLoop()) { const eventUseActions = event; eventUseActions.last = event.type === 3; setEvent(eventUseActions); } }, actorName, actorClass) const endpoint = window.location.protocol + \"//\" + window.location.hostname + \":8080\" const controller = context.getController(endpoint); //Need to output a function so that the user can start the trial when all actors are connected //Again, double arrow function cause react will turn a single one into a lazy loaded function setStartTrial(() => async () => { const trialId = await controller.startTrial(); await context.joinTrial(trialId, endpoint, actorName); }); }, [cogSettings, actorName, actorClass]); return [event, startTrial, sendAction]; }; Please note that the useActions hook is generated by cogment init . We've still gone through it in this tutorial, because that is where most of the Cogment related code is contained, and it must be understood if we want to use Cogment without React.JS. We also need to add the following to web-client/.eslintignore : src/*_pb* src/cog_settings* Normally this file will be created by cogment init , but if you have been following the tutorial step-by-step, you need to create it manually. You can now see our app fully functional by going to the folder where our cogment.yaml sits, and running the commands: $ cogment run build $ cogment run start And opening up localhost:3000 in our browser. And with that we're done! Making it look good \u00b6 If we want a fancier interface, there is a completed UI in the tutorials repository that we can copy into our project. Then, along with some style code that can be found in the repository version of App.js, just replace the return statement from App.js with the following: <Box> <Header observation={observation} gameState={gameState} /> <Container className={classes.container}> <Player score={humanScore} color={theme.palette.primary.main} IconClass={PersonIcon} choose={choose} isHuman /> <Player score={computerScore} color={theme.palette.secondary.main} IconClass={ComputerIcon} selected={ gameState !== \"start\" && getMoveText(observation.them.lastRoundMove) } /> </Container> </Box>","title":"Step 6: Implement a web client for the human player"},{"location":"cogment/tutorial/6-web-client/#step-6-add-a-web-client-for-the-human-player","text":"This part of the tutorial follows step 5 , make sure you've gone through it before starting this one. Alternatively the completed step 5 can be retrieved from the tutorial's repository . In this step of the tutorial, we will go over a web client implementation, to enable Humans to play RPS, while being able to take advantage of various web technologies.","title":"Step 6: Add a web client for the human player"},{"location":"cogment/tutorial/6-web-client/#prerequisites","text":"To develop a web client, we will need a working installation of Node.js. You can download and install this from: https://nodejs.org/en/download/","title":"Prerequisites"},{"location":"cogment/tutorial/6-web-client/#the-web-client","text":"In the previous steps, we triggered the trials by running cogment run client . This launched a trial using code in client/main.py . In this step we will trigger a trial using a React app. Before we start with the Cogment side of things, we'll need to get a few prerequisite files setup.","title":"The web client"},{"location":"cogment/tutorial/6-web-client/#creating-a-react-app","text":"First, we will initialize a React app. This can be done very simply by running: $ npx create-react-app web-client Once this is done, we will be able to open a React app in our browser by running the following commands: $ cd web-client $ npm start","title":"Creating a React app"},{"location":"cogment/tutorial/6-web-client/#adding-material-ui","text":"We will be using Material UI for this web client. This will provide us with a nice and clean way to add styles to our application, as well as some components which we will use to reduce code size. Install Material UI by running the following commands from inside of the web-client folder: $ npm i @material-ui/core $ npm i @material-ui/icons","title":"Adding Material UI"},{"location":"cogment/tutorial/6-web-client/#setting-up-docker","text":"In addition to the docker-compose services we already have, we'll need two more for this web client. One to run it, and another for a proxy service called grpcwebproxy . NOTE: grpcwebproxy (link) is a helpful program that allows grpc endpoints to be utilized by web applications. Web applications cannot natively use the grpc protocol that all Cogment elements use to communicate with one another. Using this proxy to translate the web socket connections it accepts into grpc requests solves this issue. For these services, let's add the following to the end of our docker-compose.yaml: web-client: build: context: web-client dockerfile: ../js_service.dockerfile environment: - NODE_ENV=development - CHOKIDAR_USEPOLLING=true - REACT_APP_APP_VERSION=dev restart: on-failure ports: - \"3000:3000\" depends_on: - grpcwebproxy grpcwebproxy: build: context: ./grpcwebproxy dockerfile: ../grpcwebproxy.dockerfile restart: on-failure ports: - \"8080:8080\" depends_on: - orchestrator We will also need two additional dockerfiles to go along these entries. The first one will be grpcwebproxy.dockerfile , with the following content: FROM golang:1.15.2 as dev WORKDIR /go ARG GO111MODULE=auto ENV GO111MODULE=${GO111MODULE} ENV GOPATH=/go ENV COGMENT_URL=orchestrator:9000 RUN go get github.com/improbable-eng/grpc-web/go/grpcwebproxy EXPOSE 8080 CMD [\"grpcwebproxy\", \"--backend_addr=orchestrator:9000\", \"--run_tls_server=false\", \"--allow_all_origins\", \"--use_websockets\"] The second one will be js_service.dockerfile , with the following content: # pull official base image FROM node:14 as dev # set working directory WORKDIR /app EXPOSE 3000 # generate protos COPY package.json package-lock.json ./ COPY cogment.yaml ./ COPY *.proto ./ RUN mkdir src RUN npm i RUN npx cogment-js-sdk-generate cogment.yaml # copy generated app COPY . ./ # start app CMD [\"npm\", \"start\"] NOTE: Since the port for grpcwebproxy is exposed outside of the docker network, the docker-compose entry and corresponding dockerfile are not actually needed for the web-client; it can just as easily be run outside of docker. However, doing it like this makes the command to startup the application much simpler. Finally, we have to add web-client and grpcwebproxy to the start, build, and stop commands in our cogment.yaml . build: docker-compose build orchestrator environment random_agent web-client grpcwebproxy start: docker-compose up orchestrator environment random_agent web-client grpcwebproxy stop: docker-compose stop orchestrator environment random_agent web-client grpcwebproxy","title":"Setting up Docker"},{"location":"cogment/tutorial/6-web-client/#adding-cogment-to-our-web-client","text":"The easiest way to add Cogment to any web client is to start with a React app, then follow the three steps below: Install the Javascript SDK using: $ npm i @cogment/cogment-js-sdk while inside of the web-client folder Copy the hooks folder from the tutorial's repository , found at 6-web-client/web-client/src/ , into your src directory. Navigate one folder up to your project directory (where you have your cogment.yaml) then run the following command to generate Javascript files from your defined protobufs: $ cogment copy cogment.yaml *.proto web-client NOTE: Had we chosen Y at the beginning of this tutorial when asked by the CLI if we wanted a web client, the React hooks used in this section would normally have been generated with the command cogment init .\" (optional) You can run the following commands outside of docker to generate your protobuf files if you need or want the typings at develop time $ cd web-client $ npm install $ npx cogment-js-sdk-generate cogment.yaml Now that all that's done, we can finally start coding our web client!","title":"Adding Cogment to our web client"},{"location":"cogment/tutorial/6-web-client/#code","text":"NOTE: For each of the following files, we will provide the styles in a code block. Feel free to skip these, or make your own; they are not important to the function of this application.","title":"CODE"},{"location":"cogment/tutorial/6-web-client/#indexjs-indexcss","text":"When we created our React app, these two files were generated automatically. Replace their content with the following: NOTE: These can also be downloaded from the tutorial's repository . index.css: body { margin: 0; background-color: #c5cce8; } index.js import React from \"react\"; import ReactDOM from \"react-dom\"; import \"./index.css\"; import { App } from \"./App\"; import { createMuiTheme, responsiveFontSizes, ThemeProvider, } from \"@material-ui/core/styles\"; let theme = createMuiTheme({ palette: { primary: { light: \"#c5cce8\", main: \"#6B80C4\", }, secondary: { main: \"#ffb400\", }, }, }); theme = responsiveFontSizes(theme); ReactDOM.render( <React.StrictMode> <ThemeProvider theme={theme}> <App /> </ThemeProvider> </React.StrictMode>, document.getElementById(\"root\") ); This is simply to provide styles to our Material UI components. We haven't started with the actual Cogment part yet, which is exactly what we'll be doing next.","title":"index.js / index.css"},{"location":"cogment/tutorial/6-web-client/#appjs","text":"We'll start with a few imports. Some of these files don't exist yet, so we'll be creating them: //First is some React imports import React, { useEffect } from \"react\"; //Then some imports for icons and Material UI functionality we'll be using import { Box, Button, makeStyles, Typography, useTheme, } from \"@material-ui/core\"; //And here's the important part: we're importing the two things that will allow us to use Cogment. //First, the 'useActions' hook which will give us our observations as a human agent, as well as allow us to send actions. import { useActions } from \"./hooks/useActions\"; //Second, our 'cogSettings'. This is a file that was generated when we ran //`npx cogment-js-sdk-generate cogment.yaml` //This file tells our web client relevant information about our trials, environments, and actor classes. import { cogSettings } from \"./CogSettings\"; //These are messages which were defined in data.proto. These imports will need to change whenever their corresponding messages in data.proto are changed and `npx cogment-js-sdk-generate cogment.yaml` is run. import { PlayerAction } from \"./data_pb\"; Then we add a function that will convert the play, encoded as the same \"move\" enum that we defined in our data.proto, to a string we can use in our application: function getMoveText(move) { switch (move) { case 0: return \"rock\"; case 1: return \"paper\"; case 2: return \"scissors\"; default: throw new Error(\"Not a rock, paper, or scissors\"); } } Finally, the React component. At the start of this component is the most important part of our application: the useAction hook. This hook returns an array with 3 elements: event: this contains all the information about any observation, reward, or message we've received this tick. We will use this to see what plays we and the computer made. startTrial: this is a function which takes no arguments, and is a very simple way to start a new trial with our player actor. sendAction: this is a function which takes an argument of type 'Action'. This class can be imported from data_pb.js, but we'll see that later in this tutorial. This hook takes in 3 arguments: cogSettings: this is what's imported from CogSettings.js. It provides all the relevant information about data.proto to this hook so that it can function. actorName: the name of the human actor which this web client will be representing. This is defined in cogment.yaml. actorClass: the class of the human actor which this web client will be representing. This is defined in cogment.yaml. export const App = () => { const [event, startTrial, sendAction] = useActions( cogSettings, \"player_1\", \"player\" ); //Function to construct the Action which the player will send when they click either rock, paper, or scissors const choose = (move) => { const action = new PlayerAction(); action.setMove(move); sendAction(action); }; //This will start a trial as soon as we're connected to the orchestrator useEffect(() => { if (startTrial) startTrial(); }, [startTrial]); //Get any observation from the current event, events have observations, messages, and rewards, and all three can be unpacked from the event object //We will also unpack a helpful variable called 'last', this will allow us to know when the trial has ended const { observation, last } = event; const [gameState, setGameState] = useState({ gameStage: \"start\", roundIndex: 0, lastMoveComputer: 0, lastMoveHuman: 0, }); const [firstObservation, setFirstObservation] = useState(true); useEffect(() => { //Parse game state out of the observation //Some events don't contain an observation, so we need to store the observation contents in a state if (!observation) return; //The first observation is not useful, as it just contains the default game state, before players have made moves if (firstObservation) { setFirstObservation(false); return; } //Get all relevant information from the observation const roundIndex = gameState.roundIndex + 1; const gameStage = \"playing\"; const lastMoveComputer = observation.them.lastMove; const lastMoveHuman = observation.me.lastMove; const lastWonComputer = observation.them.wonLast; const lastWonHuman = observation.me.wonLast; setGameState({ gameStage, roundIndex, lastMoveComputer, lastMoveHuman, lastWonComputer, lastWonHuman, }); // eslint-disable-next-line react-hooks/exhaustive-deps }, [observation]); //The layout of the page return ( <Box> {/* Tell the player everything we know about the trial state, such as, plays, who won, etc... */} <Typography>Game stage: {gameState.gameStage}</Typography> <Typography> Human's move:{\" \"} {gameState.gameStage !== \"start\" && getMoveText(gameState.lastMoveHuman)} </Typography> <Typography> Computer's move:{\" \"} {gameState.gameStage !== \"start\" && getMoveText(gameState.lastMoveComputer)} </Typography> <Typography> Did Human win last round?{\" \"} {observation && gameState.lastWonHuman ? \"Yes\" : \"No\"} </Typography> <Typography> Did Computer win last round?{\" \"} {observation && gameState.lastWonComputer ? \"Yes\" : \"No\"} </Typography> <Button onClick={() => choose(0)}>Rock</Button> <Button onClick={() => choose(1)}>Paper</Button> <Button onClick={() => choose(2)}>Scissors</Button> </Box> ); };","title":"App.js"},{"location":"cogment/tutorial/6-web-client/#hooksuseactionsjs","text":"NOTE: This section needs to be updated for Cogment 2.0, and will only work with Cogment versions 1.x This hook does multiple things. It starts a trial, joins a trial, sends actions, and receives information from the orchestrator. The following is its annotated code: import { Context } from \"@cogment/cogment-js-sdk\"; import { useEffect, useState } from \"react\"; export const useActions = (cogSettings, actorName, actorClass) => { const [event, setEvent] = useState({ observation: null, actions: null, messages: null, rewards: null, type: null, last: false }); const [startTrial, setStartTrial] = useState(null); const [sendAction, setSendAction] = useState(null); //Set up the connection and register the actor only once, regardless of re-rendering useEffect(() => { const context = new Context( cogSettings, actorName, ); context.registerActor(async (actorSession) => { actorSession.start(); //Double arrow function here beause react will turn a single one into a lazy loaded function setSendAction(() => (action) => { actorSession.doAction(action); }); for await (const event of actorSession.eventLoop()) { const eventUseActions = event; eventUseActions.last = event.type === 3; setEvent(eventUseActions); } }, actorName, actorClass) const endpoint = window.location.protocol + \"//\" + window.location.hostname + \":8080\" const controller = context.getController(endpoint); //Need to output a function so that the user can start the trial when all actors are connected //Again, double arrow function cause react will turn a single one into a lazy loaded function setStartTrial(() => async () => { const trialId = await controller.startTrial(); await context.joinTrial(trialId, endpoint, actorName); }); }, [cogSettings, actorName, actorClass]); return [event, startTrial, sendAction]; }; Please note that the useActions hook is generated by cogment init . We've still gone through it in this tutorial, because that is where most of the Cogment related code is contained, and it must be understood if we want to use Cogment without React.JS. We also need to add the following to web-client/.eslintignore : src/*_pb* src/cog_settings* Normally this file will be created by cogment init , but if you have been following the tutorial step-by-step, you need to create it manually. You can now see our app fully functional by going to the folder where our cogment.yaml sits, and running the commands: $ cogment run build $ cogment run start And opening up localhost:3000 in our browser. And with that we're done!","title":"hooks/useActions.js"},{"location":"cogment/tutorial/6-web-client/#making-it-look-good","text":"If we want a fancier interface, there is a completed UI in the tutorials repository that we can copy into our project. Then, along with some style code that can be found in the repository version of App.js, just replace the return statement from App.js with the following: <Box> <Header observation={observation} gameState={gameState} /> <Container className={classes.container}> <Player score={humanScore} color={theme.palette.primary.main} IconClass={PersonIcon} choose={choose} isHuman /> <Player score={computerScore} color={theme.palette.secondary.main} IconClass={ComputerIcon} selected={ gameState !== \"start\" && getMoveText(observation.them.lastRoundMove) } /> </Container> </Box>","title":"Making it look good"},{"location":"cogment/tutorial/7-dqn-player/","text":"Step 7: Add a player trained with Reinforcement Learning using DQN \u00b6 This part of the tutorial follows step 5 and step 6 , make sure you've gone through either one of those before starting this one. Alternatively the completed step 5 can be retrieved from the tutorial's repository . In this step of the tutorial, we will go over yet another actor implementation and this implementation will be learning from its experience. We will implement an RPS player using Reinforcement Learning (RL) and more precisely a Deep Q Network , one of the foundational algorithms of modern RL. While we will explain some aspects of RL and DQN along the way, we won't go into all the details. Interested readers can refer to \"Reinforcement Learning: An Introduction\" by Richard S. Sutton and Andrew G. Barto or to the original Deep Q Network article linked above. Creating an actor service \u00b6 Back in step 4 , we created a new implementation of the player actor class in the same service as the previous one. It was a sound choice for this implementation because it was small and didn't require additional dependencies. In some cases it makes more sense to create a fully separated service for a new actor implementation. This is what we will do here. Start by copy/pasting the random_agent folder and name the copy dqn_agent . Let's then clean up dqn_agent/main.py to keep only a single actor implentation and name it dqn_agent . You should end up with something like the following. import cog_settings from data_pb2 import PlayerAction import cogment import asyncio import random async def dqn_agent(actor_session): # ... async def main(): print(\"Deep Q Network agents service up and running.\") context = cogment.Context(cog_settings=cog_settings, user_id=\"rps\") context.register_actor( impl=dqn_agent, impl_name=\"dqn_agent\", actor_classes=[ \"player\", ], ) await context.serve_all_registered(cogment.ServedEndpoint(port=9000)) if __name__ == \"__main__\": asyncio.run(main()) Since we have created a new service we need to reference it at several places for everything to work properly. First, let's edit docker-compose.yaml to add the new service. To do that, simply add the following under the services key: it tells docker-compose about the new service. dqn-agent: build: context: dqn_agent dockerfile: ../py_service.dockerfile Then we will need to edit cogment.yaml to make cogment run copy copy files to the new service's directory and have cogment run build and cogment run start respectively trigger its build and its start. We will change the build and start keys under commands . Note: the generate command is only needed if you are running things outside of docker, otherwise the code generation is done in the build step commands: copy: cogment copy cogment.yaml *.proto client environment random_agent dqn_agent # ... build: docker-compose build client dashboard metrics orchestrator environment random-agent dqn-agent # ... start: docker-compose up dashboard metrics orchestrator environment random-agent dqn-agent Finally, the metrics server needs to know about this new data source. In metrics/prometheus.yml , add a new item under the scrape_configs key. - job_name: \"dqn-agent\" dns_sd_configs: - names: - \"dqn-agent\" type: \"A\" port: 8000 refresh_interval: 5s Playing against the heuristic player \u00b6 We will train our new player against the heuristic player we previously developed. We first need to update the trial config in cogment.yaml : player_1 will be our new actor implementation while player_2 will be the heuristic implementation. Trials will be 20 games long to generate enough meaningful data between each training step. trial_params: environment: endpoint: grpc://environment:9000 config: target_game_score: 2 target_games_count: 20 actors: - name: player_1 actor_class: player implementation: dqn_agent endpoint: grpc://dqn-agent:9000 - name: player_2 actor_class: player implementation: heuristic_agent endpoint: grpc://random-agent:9000 We can also update client/main.py to run a bunch of trials sequentially. async def main(): print(\"Client starting...\") context = cogment.Context(cog_settings=cog_settings, user_id=\"rps\") # Create a controller controller = context.get_controller(endpoint=cogment.Endpoint(\"orchestrator:9000\")) # Start a trial campaign for i in range(1000): trial_id = await controller.start_trial(trial_config=TrialConfig()) print(f\"Running trial #{i+1} with id '{trial_id}'\") # Wait for the trial to end by itself async for trial_info in controller.watch_trials( trial_state_filters=[cogment.TrialState.ENDED] ): if trial_info.trial_id == trial_id: break You can now build and run the application. It should take a few minutes to run as it goes through the trial campaign. Implementing the Deep Q Network \u00b6 We have set everything up, we can now focus on implementing our DQN agent. A Deep Q Network is a neural network taking an observation as input, and outputing the Q value for each of the actions in the action space. The Q Value is an estimation of the expected value of all the rewards if a given action is taken. The DQN agent action policy is therefore to take the action having the largest predicted Q Value. Let's start by implementing this part and we will then deal with training this model. In the rest of this tutorial we will use Tensorflow and its Keras API for the model itself, as well as numpy for datastructures. Let's add these to dqn_agent/requirements.txt and import them at the top of dqn_agent/main.py . import numpy as np import tensorflow as tf Let's get into the meat of the matter by implementing a function to create our model. We are using Keras functional API to create the following layers: Two scalar inputs, the last moves of the player and the opponent. Each input is one-hot encoded to avoid assuming an unwanted ordering and quantitative relationship between the moves. The two encoded inputs are concatenated to a single vector. A dense non-linear hidden layer is added. The output layer estimates the Q value for each move. Everything then gets wrapped up and returned. This function is then used to create a global _model that we will use in the actor implementation. MOVES = [ROCK, PAPER, SCISSORS] actions_count = len(MOVES) def create_model(): # 1. Input layers in_me_last_move = tf.keras.Input(name=\"obs_me_last_move\", shape=(1)) in_them_last_move = tf.keras.Input(name=\"obs_them_last_move\", shape=(1)) # 2. One hot encoding of the layers one_hot_move = tf.keras.layers.experimental.preprocessing.CategoryEncoding( name=\"one_hot_move\", max_tokens=len(MOVES), output_mode=\"binary\" ) one_hot_me_last_move = one_hot_move(in_me_last_move) one_hot_them_last_move = one_hot_move(in_them_last_move) # 3. Concatenating the two inputs concat_ins = tf.keras.layers.concatenate( [one_hot_me_last_move, one_hot_them_last_move] ) # 4. Dense hidden layer hidden_layer = tf.keras.layers.Dense(24, activation=\"relu\")(concat_ins) # 5. Output outs = tf.keras.layers.Dense(actions_count, activation=\"linear\")(hidden_layer) return tf.keras.Model( inputs=[in_me_last_move, in_them_last_move], outputs=outs, name=\"rps_dqn_policy\" ) _model = create_model() The other piece of the puzzle is implementing a small function that will convert our observations into inputs for the model we just created. As most of the encoding is handled by the model itself it's fairly straightforward. def model_ins_from_observations(observations): return { \"obs_me_last_move\": np.array([[o.snapshot.me.last_move] for o in observations]), \"obs_them_last_move\": np.array( [[o.snapshot.them.last_move] for o in observations] ), } Finally we can make it work together by replacing the random choice of action by the use of the model. At the moment the model will just use the random initialization weights so don't expect much! Here is how the event loop in the dqn_agent function will need to be updated: Use model_ins_from_observations to compute the model inputs, Use the model in inference mode to compute the q value of each of the possible actions, Finally, do the action having the largest q value. if event.observation: model_ins = model_ins_from_observations([event.observation]) if event.type == cogment.EventType.ACTIVE: model_outs = _model(model_ins, training=False) action = tf.math.argmax(model_outs[0]).numpy() actor_session.do_action(PlayerAction(move=action)) You can now build and run the application. It should take a few minutes to run as it goes through the trial campaign. In this example we define _model (and other variables in the following sections) as global mutable variables. It works in our case because the dqn agents are neither distributed nor multithreaded. Random exploration \u00b6 With the previous code, you might have noticed that the agent will play exactly the same action given the same set of observations, this is because the weights of the model are fixed. However, especially at the beginning of the training process we want the agent to experience a variety of situations. We address this issue by introducing a decaying exploration rate epsilon . First we will define the parameters for this epsilon value as global variables: its minimum value, its maximum and initial value and its decay per tick. We also define as a global variable the current value of epsilon. You can add the following after the imports in dqn_agent/main.py . epsilon_min = 0.05 epsilon_max = 1.0 epsilon_decay_per_tick = ( epsilon_max - epsilon_min ) / 1000.0 # Linearly reach the lowest exploration rate after 1000 ticks _epsilon = epsilon_max We then create a simple function we can use everytime an action needs to be taken to retrieve and update _epsilon . def get_and_update_epsilon(): global _epsilon current_epsilon = _epsilon _epsilon -= epsilon_decay_per_tick _epsilon = max(_epsilon, epsilon_min) return current_epsilon This function can then be used to occasionally do random actions, to facilitate the exploration. To do that, we need to slightly modify how the actions are computed and submitted. if event.type == cogment.EventType.ACTIVE: if np.random.rand(1)[0] < get_and_update_epsilon(): # Take random action action = np.random.choice(actions_count) else: model_outs = _model(model_ins, training=False) action = tf.math.argmax(model_outs[0]).numpy() actor_session.do_action(PlayerAction(move=action)) You can now build and run the application. Nothing should appear different at this stage. Replay buffer \u00b6 In our journey to train a model, the next stage is to build an experience replay buffer to collect actions/observations/rewards triples over the course of the trials. Once done, it'll be usable to train the model using this data. We will start by creating the datastructure. We are using a column-oriented structure relying on numpy arrays as they interoperate easily with tensorflow and support the needed manipulation primitives. Each row is a sample corresponding to one tick: the received observation and reward, the selected action as well as the next tick's received observation. def create_replay_buffer(): return { \"obs_me_last_move\": np.array([]), \"obs_them_last_move\": np.array([]), \"action\": np.array([]), \"reward\": np.array([]), \"next_obs_me_last_move\": np.array([]), \"next_obs_them_last_move\": np.array([]), } _rb = create_replay_buffer() During each trial the agent will collect its data points in a trial replay buffer then append it to the global one. To achieve that we will first create the function in charge of the appending then collect data during the trial and call the \"append\" function. The following function will take a trial replay buffer and append it to the global _rb . To avoid memory overflow the replay buffer size is capped. _collected_samples_count = 0 max_replay_buffer_size = 100000 def append_trial_replay_buffer(trial_rb): global _rb global _collected_samples_count trial_rb_size = len(trial_rb[\"obs_me_last_move\"]) for key in _rb.keys(): # Append the trial data to the current vector _rb[key] = np.append(_rb[key], trial_rb[key]) # Enforce the size limit by discarding older data if len(_rb[key]) > max_replay_buffer_size: _rb[key] = _rb[key][-max_replay_buffer_size:] _collected_samples_count += trial_rb_size rb_size = len(_rb[\"obs_me_last_move\"]) # Sanity check, all vectors in the replay buffer should have the same size for key in _rb.keys(): assert rb_size == len(_rb[key]) print( f\"{trial_rb_size} new samples stored after a trial, now having {rb_size} samples over a total of {_collected_samples_count} collected samples.\" ) The dqn_agent function can then be updated to collect received observations, rewards and sent actions. By default every action gets a zero reward. When a reward for a specific tick is received, its value gets updated. async def dqn_agent(actor_session): actor_session.start() trial_rb = create_replay_buffer() async for event in actor_session.event_loop(): if event.observation: model_ins = model_ins_from_observations([event.observation]) if event.type == cogment.EventType.ACTIVE: # [...] trial_rb[\"obs_me_last_move\"] = np.append( trial_rb[\"obs_me_last_move\"], model_ins[\"obs_me_last_move\"] ) trial_rb[\"obs_them_last_move\"] = np.append( trial_rb[\"obs_them_last_move\"], model_ins[\"obs_them_last_move\"] ) trial_rb[\"action\"] = np.append(trial_rb[\"action\"], [action]) trial_rb[\"reward\"] = np.append(trial_rb[\"reward\"], [0.0]) else: trial_rb[\"obs_me_last_move\"] = np.append( trial_rb[\"obs_me_last_move\"], model_ins[\"obs_me_last_move\"] ) trial_rb[\"obs_them_last_move\"] = np.append( trial_rb[\"obs_them_last_move\"], model_ins[\"obs_them_last_move\"] ) for reward in event.rewards: trial_rb[\"reward\"][reward.tick_id] = reward.value # Shifting the observations to get the next observations trial_rb[\"next_obs_me_last_move\"] = trial_rb[\"obs_me_last_move\"][1:] trial_rb[\"next_obs_them_last_move\"] = trial_rb[\"obs_them_last_move\"][1:] # Dropping the last row, as it only contains the last observations trial_rb[\"obs_me_last_move\"] = trial_rb[\"obs_me_last_move\"][:-1] trial_rb[\"obs_them_last_move\"] = trial_rb[\"obs_them_last_move\"][:-1] append_trial_replay_buffer(trial_rb) You can now build and run the application. The behavior should be the same but the log should confirm that data gets accumulated. Training! \u00b6 Here we are, all the pieces are in place, we can implement the training proper. The function is a standard implementation of DQN and is decomposed in 4 steps: Select a random batch of samples from the replay buffer Compute the target Q value for each sample from the received reward and the next observation using a previous version of the model. (Re)compute the estimated Q value of each sample from the selected action and observation using the current version of the model. Perform an optimization step of the model parameters trying to reduce the loss between the samples estimated and target q values. batch_size = 50 # Size of batch taken from replay buffer gamma = 0.99 # Discount factor for future rewards optimizer = tf.keras.optimizers.Adam(learning_rate=0.00025, clipnorm=1.0) loss_function = tf.keras.losses.Huber() target_model_update_interval = 1000 _target_model = create_model() def train(): global _model global _target_model rb_size = len(_rb[\"obs_me_last_move\"]) if rb_size >= batch_size: # Step 1 - Randomly select a batch batch_indices = np.random.choice(range(rb_size), size=batch_size) batch_rb = create_replay_buffer() for key in batch_rb.keys(): batch_rb[key] = np.take(_rb[key], batch_indices) # Step 2 - Compute target q values ## Predict the expected reward for the next observation of each sample ## Use the target model for stability target_actions_q_values = _target_model( { \"obs_me_last_move\": batch_rb[\"next_obs_me_last_move\"], \"obs_them_last_move\": batch_rb[\"next_obs_them_last_move\"], } ) ## target Q value = reward + discount factor * expected future reward target_q_values = batch_rb[\"reward\"] + gamma * tf.reduce_max( target_actions_q_values, axis=1 ) # Step 3 - Compute estimated q values ## Create masks of the taken actions to later select relevant q values selected_actions_masks = tf.one_hot(batch_rb[\"action\"], actions_count) with tf.GradientTape() as tape: ## Recompute q values for all the actions at each sample estimated_actions_q_values = _model( { \"obs_me_last_move\": batch_rb[\"obs_me_last_move\"], \"obs_them_last_move\": batch_rb[\"obs_them_last_move\"], } ) ## Apply the masks to get the Q value for taken actions estimated_q_values = tf.reduce_sum( tf.multiply(estimated_actions_q_values, selected_actions_masks), axis=1 ) ## Compute loss between the target Q values and the estimated Q values loss = loss_function(target_q_values, estimated_q_values) print(f\"loss={loss.numpy()}\") ## Backpropagation! grads = tape.gradient(loss, _model.trainable_variables) optimizer.apply_gradients(zip(grads, _model.trainable_variables)) # Update the target model if _collected_samples_count % target_model_update_interval == 0: _target_model.set_weights(_model.get_weights()) This function then needs to be called at the end of each trial after the call to append_trial_replay_buffer . You can now build and run the application. The dqn agent will start to learn and quickly prevail against the heuristic implementation. This can be observed by opening the dashboard at http://localhost:3003 and opening the reward page. You should be able to track the progression of the dqn implementation. This concludes the step 7 of the tutorial: you implemented your first trained actor implementation!","title":"Step 7: Add a player trained with Reinforcement Learning using DQN"},{"location":"cogment/tutorial/7-dqn-player/#step-7-add-a-player-trained-with-reinforcement-learning-using-dqn","text":"This part of the tutorial follows step 5 and step 6 , make sure you've gone through either one of those before starting this one. Alternatively the completed step 5 can be retrieved from the tutorial's repository . In this step of the tutorial, we will go over yet another actor implementation and this implementation will be learning from its experience. We will implement an RPS player using Reinforcement Learning (RL) and more precisely a Deep Q Network , one of the foundational algorithms of modern RL. While we will explain some aspects of RL and DQN along the way, we won't go into all the details. Interested readers can refer to \"Reinforcement Learning: An Introduction\" by Richard S. Sutton and Andrew G. Barto or to the original Deep Q Network article linked above.","title":"Step 7: Add a player trained with Reinforcement Learning using DQN"},{"location":"cogment/tutorial/7-dqn-player/#creating-an-actor-service","text":"Back in step 4 , we created a new implementation of the player actor class in the same service as the previous one. It was a sound choice for this implementation because it was small and didn't require additional dependencies. In some cases it makes more sense to create a fully separated service for a new actor implementation. This is what we will do here. Start by copy/pasting the random_agent folder and name the copy dqn_agent . Let's then clean up dqn_agent/main.py to keep only a single actor implentation and name it dqn_agent . You should end up with something like the following. import cog_settings from data_pb2 import PlayerAction import cogment import asyncio import random async def dqn_agent(actor_session): # ... async def main(): print(\"Deep Q Network agents service up and running.\") context = cogment.Context(cog_settings=cog_settings, user_id=\"rps\") context.register_actor( impl=dqn_agent, impl_name=\"dqn_agent\", actor_classes=[ \"player\", ], ) await context.serve_all_registered(cogment.ServedEndpoint(port=9000)) if __name__ == \"__main__\": asyncio.run(main()) Since we have created a new service we need to reference it at several places for everything to work properly. First, let's edit docker-compose.yaml to add the new service. To do that, simply add the following under the services key: it tells docker-compose about the new service. dqn-agent: build: context: dqn_agent dockerfile: ../py_service.dockerfile Then we will need to edit cogment.yaml to make cogment run copy copy files to the new service's directory and have cogment run build and cogment run start respectively trigger its build and its start. We will change the build and start keys under commands . Note: the generate command is only needed if you are running things outside of docker, otherwise the code generation is done in the build step commands: copy: cogment copy cogment.yaml *.proto client environment random_agent dqn_agent # ... build: docker-compose build client dashboard metrics orchestrator environment random-agent dqn-agent # ... start: docker-compose up dashboard metrics orchestrator environment random-agent dqn-agent Finally, the metrics server needs to know about this new data source. In metrics/prometheus.yml , add a new item under the scrape_configs key. - job_name: \"dqn-agent\" dns_sd_configs: - names: - \"dqn-agent\" type: \"A\" port: 8000 refresh_interval: 5s","title":"Creating an actor service"},{"location":"cogment/tutorial/7-dqn-player/#playing-against-the-heuristic-player","text":"We will train our new player against the heuristic player we previously developed. We first need to update the trial config in cogment.yaml : player_1 will be our new actor implementation while player_2 will be the heuristic implementation. Trials will be 20 games long to generate enough meaningful data between each training step. trial_params: environment: endpoint: grpc://environment:9000 config: target_game_score: 2 target_games_count: 20 actors: - name: player_1 actor_class: player implementation: dqn_agent endpoint: grpc://dqn-agent:9000 - name: player_2 actor_class: player implementation: heuristic_agent endpoint: grpc://random-agent:9000 We can also update client/main.py to run a bunch of trials sequentially. async def main(): print(\"Client starting...\") context = cogment.Context(cog_settings=cog_settings, user_id=\"rps\") # Create a controller controller = context.get_controller(endpoint=cogment.Endpoint(\"orchestrator:9000\")) # Start a trial campaign for i in range(1000): trial_id = await controller.start_trial(trial_config=TrialConfig()) print(f\"Running trial #{i+1} with id '{trial_id}'\") # Wait for the trial to end by itself async for trial_info in controller.watch_trials( trial_state_filters=[cogment.TrialState.ENDED] ): if trial_info.trial_id == trial_id: break You can now build and run the application. It should take a few minutes to run as it goes through the trial campaign.","title":"Playing against the heuristic player"},{"location":"cogment/tutorial/7-dqn-player/#implementing-the-deep-q-network","text":"We have set everything up, we can now focus on implementing our DQN agent. A Deep Q Network is a neural network taking an observation as input, and outputing the Q value for each of the actions in the action space. The Q Value is an estimation of the expected value of all the rewards if a given action is taken. The DQN agent action policy is therefore to take the action having the largest predicted Q Value. Let's start by implementing this part and we will then deal with training this model. In the rest of this tutorial we will use Tensorflow and its Keras API for the model itself, as well as numpy for datastructures. Let's add these to dqn_agent/requirements.txt and import them at the top of dqn_agent/main.py . import numpy as np import tensorflow as tf Let's get into the meat of the matter by implementing a function to create our model. We are using Keras functional API to create the following layers: Two scalar inputs, the last moves of the player and the opponent. Each input is one-hot encoded to avoid assuming an unwanted ordering and quantitative relationship between the moves. The two encoded inputs are concatenated to a single vector. A dense non-linear hidden layer is added. The output layer estimates the Q value for each move. Everything then gets wrapped up and returned. This function is then used to create a global _model that we will use in the actor implementation. MOVES = [ROCK, PAPER, SCISSORS] actions_count = len(MOVES) def create_model(): # 1. Input layers in_me_last_move = tf.keras.Input(name=\"obs_me_last_move\", shape=(1)) in_them_last_move = tf.keras.Input(name=\"obs_them_last_move\", shape=(1)) # 2. One hot encoding of the layers one_hot_move = tf.keras.layers.experimental.preprocessing.CategoryEncoding( name=\"one_hot_move\", max_tokens=len(MOVES), output_mode=\"binary\" ) one_hot_me_last_move = one_hot_move(in_me_last_move) one_hot_them_last_move = one_hot_move(in_them_last_move) # 3. Concatenating the two inputs concat_ins = tf.keras.layers.concatenate( [one_hot_me_last_move, one_hot_them_last_move] ) # 4. Dense hidden layer hidden_layer = tf.keras.layers.Dense(24, activation=\"relu\")(concat_ins) # 5. Output outs = tf.keras.layers.Dense(actions_count, activation=\"linear\")(hidden_layer) return tf.keras.Model( inputs=[in_me_last_move, in_them_last_move], outputs=outs, name=\"rps_dqn_policy\" ) _model = create_model() The other piece of the puzzle is implementing a small function that will convert our observations into inputs for the model we just created. As most of the encoding is handled by the model itself it's fairly straightforward. def model_ins_from_observations(observations): return { \"obs_me_last_move\": np.array([[o.snapshot.me.last_move] for o in observations]), \"obs_them_last_move\": np.array( [[o.snapshot.them.last_move] for o in observations] ), } Finally we can make it work together by replacing the random choice of action by the use of the model. At the moment the model will just use the random initialization weights so don't expect much! Here is how the event loop in the dqn_agent function will need to be updated: Use model_ins_from_observations to compute the model inputs, Use the model in inference mode to compute the q value of each of the possible actions, Finally, do the action having the largest q value. if event.observation: model_ins = model_ins_from_observations([event.observation]) if event.type == cogment.EventType.ACTIVE: model_outs = _model(model_ins, training=False) action = tf.math.argmax(model_outs[0]).numpy() actor_session.do_action(PlayerAction(move=action)) You can now build and run the application. It should take a few minutes to run as it goes through the trial campaign. In this example we define _model (and other variables in the following sections) as global mutable variables. It works in our case because the dqn agents are neither distributed nor multithreaded.","title":"Implementing the Deep Q Network"},{"location":"cogment/tutorial/7-dqn-player/#random-exploration","text":"With the previous code, you might have noticed that the agent will play exactly the same action given the same set of observations, this is because the weights of the model are fixed. However, especially at the beginning of the training process we want the agent to experience a variety of situations. We address this issue by introducing a decaying exploration rate epsilon . First we will define the parameters for this epsilon value as global variables: its minimum value, its maximum and initial value and its decay per tick. We also define as a global variable the current value of epsilon. You can add the following after the imports in dqn_agent/main.py . epsilon_min = 0.05 epsilon_max = 1.0 epsilon_decay_per_tick = ( epsilon_max - epsilon_min ) / 1000.0 # Linearly reach the lowest exploration rate after 1000 ticks _epsilon = epsilon_max We then create a simple function we can use everytime an action needs to be taken to retrieve and update _epsilon . def get_and_update_epsilon(): global _epsilon current_epsilon = _epsilon _epsilon -= epsilon_decay_per_tick _epsilon = max(_epsilon, epsilon_min) return current_epsilon This function can then be used to occasionally do random actions, to facilitate the exploration. To do that, we need to slightly modify how the actions are computed and submitted. if event.type == cogment.EventType.ACTIVE: if np.random.rand(1)[0] < get_and_update_epsilon(): # Take random action action = np.random.choice(actions_count) else: model_outs = _model(model_ins, training=False) action = tf.math.argmax(model_outs[0]).numpy() actor_session.do_action(PlayerAction(move=action)) You can now build and run the application. Nothing should appear different at this stage.","title":"Random exploration"},{"location":"cogment/tutorial/7-dqn-player/#replay-buffer","text":"In our journey to train a model, the next stage is to build an experience replay buffer to collect actions/observations/rewards triples over the course of the trials. Once done, it'll be usable to train the model using this data. We will start by creating the datastructure. We are using a column-oriented structure relying on numpy arrays as they interoperate easily with tensorflow and support the needed manipulation primitives. Each row is a sample corresponding to one tick: the received observation and reward, the selected action as well as the next tick's received observation. def create_replay_buffer(): return { \"obs_me_last_move\": np.array([]), \"obs_them_last_move\": np.array([]), \"action\": np.array([]), \"reward\": np.array([]), \"next_obs_me_last_move\": np.array([]), \"next_obs_them_last_move\": np.array([]), } _rb = create_replay_buffer() During each trial the agent will collect its data points in a trial replay buffer then append it to the global one. To achieve that we will first create the function in charge of the appending then collect data during the trial and call the \"append\" function. The following function will take a trial replay buffer and append it to the global _rb . To avoid memory overflow the replay buffer size is capped. _collected_samples_count = 0 max_replay_buffer_size = 100000 def append_trial_replay_buffer(trial_rb): global _rb global _collected_samples_count trial_rb_size = len(trial_rb[\"obs_me_last_move\"]) for key in _rb.keys(): # Append the trial data to the current vector _rb[key] = np.append(_rb[key], trial_rb[key]) # Enforce the size limit by discarding older data if len(_rb[key]) > max_replay_buffer_size: _rb[key] = _rb[key][-max_replay_buffer_size:] _collected_samples_count += trial_rb_size rb_size = len(_rb[\"obs_me_last_move\"]) # Sanity check, all vectors in the replay buffer should have the same size for key in _rb.keys(): assert rb_size == len(_rb[key]) print( f\"{trial_rb_size} new samples stored after a trial, now having {rb_size} samples over a total of {_collected_samples_count} collected samples.\" ) The dqn_agent function can then be updated to collect received observations, rewards and sent actions. By default every action gets a zero reward. When a reward for a specific tick is received, its value gets updated. async def dqn_agent(actor_session): actor_session.start() trial_rb = create_replay_buffer() async for event in actor_session.event_loop(): if event.observation: model_ins = model_ins_from_observations([event.observation]) if event.type == cogment.EventType.ACTIVE: # [...] trial_rb[\"obs_me_last_move\"] = np.append( trial_rb[\"obs_me_last_move\"], model_ins[\"obs_me_last_move\"] ) trial_rb[\"obs_them_last_move\"] = np.append( trial_rb[\"obs_them_last_move\"], model_ins[\"obs_them_last_move\"] ) trial_rb[\"action\"] = np.append(trial_rb[\"action\"], [action]) trial_rb[\"reward\"] = np.append(trial_rb[\"reward\"], [0.0]) else: trial_rb[\"obs_me_last_move\"] = np.append( trial_rb[\"obs_me_last_move\"], model_ins[\"obs_me_last_move\"] ) trial_rb[\"obs_them_last_move\"] = np.append( trial_rb[\"obs_them_last_move\"], model_ins[\"obs_them_last_move\"] ) for reward in event.rewards: trial_rb[\"reward\"][reward.tick_id] = reward.value # Shifting the observations to get the next observations trial_rb[\"next_obs_me_last_move\"] = trial_rb[\"obs_me_last_move\"][1:] trial_rb[\"next_obs_them_last_move\"] = trial_rb[\"obs_them_last_move\"][1:] # Dropping the last row, as it only contains the last observations trial_rb[\"obs_me_last_move\"] = trial_rb[\"obs_me_last_move\"][:-1] trial_rb[\"obs_them_last_move\"] = trial_rb[\"obs_them_last_move\"][:-1] append_trial_replay_buffer(trial_rb) You can now build and run the application. The behavior should be the same but the log should confirm that data gets accumulated.","title":"Replay buffer"},{"location":"cogment/tutorial/7-dqn-player/#training","text":"Here we are, all the pieces are in place, we can implement the training proper. The function is a standard implementation of DQN and is decomposed in 4 steps: Select a random batch of samples from the replay buffer Compute the target Q value for each sample from the received reward and the next observation using a previous version of the model. (Re)compute the estimated Q value of each sample from the selected action and observation using the current version of the model. Perform an optimization step of the model parameters trying to reduce the loss between the samples estimated and target q values. batch_size = 50 # Size of batch taken from replay buffer gamma = 0.99 # Discount factor for future rewards optimizer = tf.keras.optimizers.Adam(learning_rate=0.00025, clipnorm=1.0) loss_function = tf.keras.losses.Huber() target_model_update_interval = 1000 _target_model = create_model() def train(): global _model global _target_model rb_size = len(_rb[\"obs_me_last_move\"]) if rb_size >= batch_size: # Step 1 - Randomly select a batch batch_indices = np.random.choice(range(rb_size), size=batch_size) batch_rb = create_replay_buffer() for key in batch_rb.keys(): batch_rb[key] = np.take(_rb[key], batch_indices) # Step 2 - Compute target q values ## Predict the expected reward for the next observation of each sample ## Use the target model for stability target_actions_q_values = _target_model( { \"obs_me_last_move\": batch_rb[\"next_obs_me_last_move\"], \"obs_them_last_move\": batch_rb[\"next_obs_them_last_move\"], } ) ## target Q value = reward + discount factor * expected future reward target_q_values = batch_rb[\"reward\"] + gamma * tf.reduce_max( target_actions_q_values, axis=1 ) # Step 3 - Compute estimated q values ## Create masks of the taken actions to later select relevant q values selected_actions_masks = tf.one_hot(batch_rb[\"action\"], actions_count) with tf.GradientTape() as tape: ## Recompute q values for all the actions at each sample estimated_actions_q_values = _model( { \"obs_me_last_move\": batch_rb[\"obs_me_last_move\"], \"obs_them_last_move\": batch_rb[\"obs_them_last_move\"], } ) ## Apply the masks to get the Q value for taken actions estimated_q_values = tf.reduce_sum( tf.multiply(estimated_actions_q_values, selected_actions_masks), axis=1 ) ## Compute loss between the target Q values and the estimated Q values loss = loss_function(target_q_values, estimated_q_values) print(f\"loss={loss.numpy()}\") ## Backpropagation! grads = tape.gradient(loss, _model.trainable_variables) optimizer.apply_gradients(zip(grads, _model.trainable_variables)) # Update the target model if _collected_samples_count % target_model_update_interval == 0: _target_model.set_weights(_model.get_weights()) This function then needs to be called at the end of each trial after the call to append_trial_replay_buffer . You can now build and run the application. The dqn agent will start to learn and quickly prevail against the heuristic implementation. This can be observed by opening the dashboard at http://localhost:3003 and opening the reward page. You should be able to track the progression of the dqn implementation. This concludes the step 7 of the tutorial: you implemented your first trained actor implementation!","title":"Training!"},{"location":"cogment/tutorial/introduction/","text":"Tutorial \u00b6 You've reached the Cogment tutorial, the best way to learn about the concepts and the usage details of Cogment by using it to create a Rock-Paper-Scissors simulation and build AIs to play the game. Full sources for the tutorials are available at https://github.com/cogment/cogment-tutorial-rps . Rock-Paper-Scissors (RPS) \u00b6 Let's quote wikipedia : Rock paper scissors [...] is a hand game usually played between two people, in which each player simultaneously forms one of three shapes with an outstretched hand. These shapes are \"rock\" (a closed fist), \"paper\" (a flat hand), and \"scissors\" (a fist with the index finger and middle finger extended, forming a V). \"Scissors\" is identical to the two-fingered V sign (also indicating \"victory\" or \"peace\") except that it is pointed horizontally instead of being held upright in the air. A simultaneous, zero-sum game, it has only two possible outcomes: a draw, or a win for one player and a loss for the other. A player who decides to play rock will beat another player who has chosen scissors (\"rock crushes scissors\"[...]), but will lose to one who has played paper (\"paper covers rock\"); a play of paper will lose to a play of scissors (\"scissors cuts paper\"). If both players choose the same shape, the game is tied and is usually immediately replayed to break the tie. The type of game originated in China and spread with increased contact with East Asia, while developing different variants in signs over time. Its rules can be expressed with the following statements: 2 players are competing to win the most rounds in a game; During each round, players play one move each, simultaneously; 3 moves are available, rock, paper and scissors; rock beats scissors, scissors beats paper and paper beats rock; playing the same move leads to a draw and the round needs to be replayed. RPS is a very simple game with straightforward rules. As long as we \"forbid\" pure random moves, that are very difficult to beat, it is an interesting testbed to develop AIs that compete with Humans. Unlike deep games such as chess or go, the power is not really in the brute force exploration of possible outcomes but in getting some level of understanding of how the opponent plays to be able to anticipate their moves. A good read on the subject of AI and RPS is this article by Benjamin Peterson published by Towards AI: Towards an AI for Rock, Paper, Scissors . Now that we have better general knowledge on the game itself, let's start with the tutorial. Basics \u00b6 In the first 5 steps of the tutorial, you'll go from a blank state to a Cogment app implementing RPS with 3 different player actor implementations: a random player, a simple heuristic player and a human player. The implementations will be done in Python 3, you'll need a good knowledge of the language to follow through. Step 1: Bootstrap the RPS project and define observation & action space data structures Step 2: Implement a first actor and environment Step 3: Introduce rewards Step 4: Create a second actor implementation based on a heuristic Step 5: Add a human player in the loop Webapp \u00b6 In the sixth step of the tutorial, you'll implement your first webapp to provide a more user friendly interface for the human player. The implementation will be done in Javascript, using React. Step 6: Implement a web client for the human player Learning actors \u00b6 In the seventh step of the tutorial, you'll implement an actor trained with Reinforcement Learning. The implementation will be done in Python, using Tensorflow. Step 7: Add a player trained with Reinforcement Learning using DQN","title":"Introduction"},{"location":"cogment/tutorial/introduction/#tutorial","text":"You've reached the Cogment tutorial, the best way to learn about the concepts and the usage details of Cogment by using it to create a Rock-Paper-Scissors simulation and build AIs to play the game. Full sources for the tutorials are available at https://github.com/cogment/cogment-tutorial-rps .","title":"Tutorial"},{"location":"cogment/tutorial/introduction/#rock-paper-scissors-rps","text":"Let's quote wikipedia : Rock paper scissors [...] is a hand game usually played between two people, in which each player simultaneously forms one of three shapes with an outstretched hand. These shapes are \"rock\" (a closed fist), \"paper\" (a flat hand), and \"scissors\" (a fist with the index finger and middle finger extended, forming a V). \"Scissors\" is identical to the two-fingered V sign (also indicating \"victory\" or \"peace\") except that it is pointed horizontally instead of being held upright in the air. A simultaneous, zero-sum game, it has only two possible outcomes: a draw, or a win for one player and a loss for the other. A player who decides to play rock will beat another player who has chosen scissors (\"rock crushes scissors\"[...]), but will lose to one who has played paper (\"paper covers rock\"); a play of paper will lose to a play of scissors (\"scissors cuts paper\"). If both players choose the same shape, the game is tied and is usually immediately replayed to break the tie. The type of game originated in China and spread with increased contact with East Asia, while developing different variants in signs over time. Its rules can be expressed with the following statements: 2 players are competing to win the most rounds in a game; During each round, players play one move each, simultaneously; 3 moves are available, rock, paper and scissors; rock beats scissors, scissors beats paper and paper beats rock; playing the same move leads to a draw and the round needs to be replayed. RPS is a very simple game with straightforward rules. As long as we \"forbid\" pure random moves, that are very difficult to beat, it is an interesting testbed to develop AIs that compete with Humans. Unlike deep games such as chess or go, the power is not really in the brute force exploration of possible outcomes but in getting some level of understanding of how the opponent plays to be able to anticipate their moves. A good read on the subject of AI and RPS is this article by Benjamin Peterson published by Towards AI: Towards an AI for Rock, Paper, Scissors . Now that we have better general knowledge on the game itself, let's start with the tutorial.","title":"Rock-Paper-Scissors (RPS)"},{"location":"cogment/tutorial/introduction/#basics","text":"In the first 5 steps of the tutorial, you'll go from a blank state to a Cogment app implementing RPS with 3 different player actor implementations: a random player, a simple heuristic player and a human player. The implementations will be done in Python 3, you'll need a good knowledge of the language to follow through. Step 1: Bootstrap the RPS project and define observation & action space data structures Step 2: Implement a first actor and environment Step 3: Introduce rewards Step 4: Create a second actor implementation based on a heuristic Step 5: Add a human player in the loop","title":"Basics"},{"location":"cogment/tutorial/introduction/#webapp","text":"In the sixth step of the tutorial, you'll implement your first webapp to provide a more user friendly interface for the human player. The implementation will be done in Javascript, using React. Step 6: Implement a web client for the human player","title":"Webapp"},{"location":"cogment/tutorial/introduction/#learning-actors","text":"In the seventh step of the tutorial, you'll implement an actor trained with Reinforcement Learning. The implementation will be done in Python, using Tensorflow. Step 7: Add a player trained with Reinforcement Learning using DQN","title":"Learning actors"},{"location":"cogment-components/cli/cli/","text":"Command Line Interface (CLI) \u00b6 Cogment CLI is the out-of-the-box entry point to use Cogment. It provides a set of tools to initialize a Cogment project and run the code generations phase. Commands \u00b6 copy \u00b6 Copy all files in a list into all folders in that list, supports glob Example: cogment copy spec.yaml *.proto environment agent web-client init \u00b6 Initializes a cogment project, this will ask you a few questions about what should be included in the generated project Example: cogment init my_new_project A full tutorial on how to bootstrap a project can be found here run \u00b6 Runs a command from the commands: section of the cogment.yaml file in the current directory. Example: cogment run generate An explanation of the cogment.yaml file can be found here","title":"CLI"},{"location":"cogment-components/cli/cli/#command-line-interface-cli","text":"Cogment CLI is the out-of-the-box entry point to use Cogment. It provides a set of tools to initialize a Cogment project and run the code generations phase.","title":"Command Line Interface (CLI)"},{"location":"cogment-components/cli/cli/#commands","text":"","title":"Commands"},{"location":"cogment-components/cli/cli/#copy","text":"Copy all files in a list into all folders in that list, supports glob Example: cogment copy spec.yaml *.proto environment agent web-client","title":"copy"},{"location":"cogment-components/cli/cli/#init","text":"Initializes a cogment project, this will ask you a few questions about what should be included in the generated project Example: cogment init my_new_project A full tutorial on how to bootstrap a project can be found here","title":"init"},{"location":"cogment-components/cli/cli/#run","text":"Runs a command from the commands: section of the cogment.yaml file in the current directory. Example: cogment run generate An explanation of the cogment.yaml file can be found here","title":"run"},{"location":"cogment-components/dashboard/metrics-and-dashboard/","text":"Metrics and Dashboard \u00b6 Cogment provides two services out-of-the-box dedicated to the monitoring of a Cogment deployment: cogment-metrics and cogment-dashboard . cogment-metrics is gathering data coming from all the Cogment services: orchestrator, actors, environment, etc. These metrics can be used to gather insights regarding the performance of actor or environment implementations. They can also be used to follow the attribution of rewards, giving insight into how, or even if agents are learning. cogment-metrics is a Prometheus instance, so it can be easily augmented to visualize your own data. cogment-dashboard is used to explore the metrics data in a human-friendly way, using graphs. Some default dashboards are available, but users can create their own dashboards, as well as use their own Prometheus requests to create their own graphs. cogment-dashboard is based on Grafana . Usage \u00b6 Note After initializing your project using cogment init , you should already have everything setup for a standard usage. For a fully manual setup refer to the dedicated section . In an up-and-running Cogment deployment running on your local machine, the dashboard is accessible at http://localhost:3003/ The dashboard welcomes you with a screen giving you direct access to the default sub-dashboards. For example, the agent performances sub-dashboard gives you an idea of how long it takes for actors to handle a new set of observations as well as the number of created instances for each actor implementation. Here's an example taken after a few minutes running tutorial #7 . A similar sub-dashboard is available for environment performances. Another useful sub-dashboard pertains to the rewards. This enables you to follow the progress of the different actor implementations during training. Here's another example taken after a few minutes running tutorial #7 , the DQN agent is about to surpass the heuristic baseline. For specific use case based guides, check out the recipes section . Setup \u00b6 To setup dashboard and metrics on a docker-based Cogment deployment only two files need to be modified and a third file needs to be created: docker-compose.yaml cogment.yaml Add a metrics/prometheus.yml Setup services in docker-compose.yaml \u00b6 Metrics \u00b6 Create a service named metrics using the cogment/metrics docker image. Log level is decreased to avoid too much verbosity, the yml file is provided in a mounted volume and another one is provided for Prometheus to store its data. metrics: user: 0:0 image: cogment/metrics:latest command: --config.file=/etc/prometheus/prometheus.yml --log.level=error volumes: - ./metrics/prometheus.yml:/etc/prometheus/prometheus.yml:ro - ./metrics/data:/prometheus Warning It is recommended to use a fixed version of cogment/metrics , refer to https://github.com/cogment/cogment-dashboard to get its version number. Dashboard \u00b6 Create a service named dashboard and pick an exposed port to consult. dashboard: image: cogment/dashboard:latest ports: - 3003:3000/tcp depends_on: - metrics Warning It is recommended to use a fixed version of cogment/dashboard , refer to https://github.com/cogment/cogment-dashboard to get its version number. Launch containers in cogment.yaml \u00b6 It is recommended to start and stop dashboard and metrics alongside the other services of the Cogment deployment. The easiest way to do that is to add dashboard metrics to the start and stop commands in your cogment.yaml file. start: docker-compose up dashboard metrics orchestrator environment [...] stop: docker-compose stop dashboard metrics orchestrator environment [...] Configure Prometheus in metrics/prometheus.yml \u00b6 Prometheus will collect data from various services, from the environment and the actors. All those data will be stored in ./metrics/data . More information about how Prometheus can store data is available here . Inside metrics/prometheus.yml , each service that will be monitored should be added like below. In the following example the environment service is the only one that will be collecting data. global: scrape_interval: 5s # Set the scrape interval to every 5 seconds. Default is every 1 minute. evaluation_interval: 5s # Evaluate rules every 5 seconds. The default is every 1 minute. # A scrape configuration containing exactly one endpoint to scrape: scrape_configs: # The job name is added as a label `job=<job_name>` to any timeseries scraped from this config. - job_name: \"environment\" dns_sd_configs: - names: - \"environment\" # Hostname of the environment service (from ./docker-compose.yaml) type: \"A\" port: 8000 refresh_interval: 5s Recipes \u00b6 Retrieving services from a new service \u00b6 To add other services from which to collect data, simply add other scrape_configs . scrape_configs: # Here you should have existing configuration for other services. # Here add a new service that will be monitored - job_name: \"new_service\" dns_sd_configs: - names: - \"new_service\" # Hostname of the service as defined in ./docker-compose.yaml type: \"A\" port: 8000 # Port on which the prometheus agent is running, Cogment SDKs uses 8000 by default refresh_interval: 5s More information can be found in the Prometheus documentation Monitoring personalized metrics \u00b6 You can add your own metrics in your code by using the Prometheus API. Added metrics will be automagically discovered by the Prometheus agent that is started by the Cogment SDKs. Here's how it looks in python. from prometheus_client import Summary, Counter MY_SUMMARY = Summary('my_func', 'Time spent') MY_COUNTER = Counter('metrics_to_count', 'The stuff I want to count') #[...] @MY_SUMMARY.time() # Will automatically measure the time spent def my_func() MY_COUNTER.inc() Several types of metrics are available in Prometheus. Consult the prometheus documentation for futher reference. Using a custom registry \u00b6 By default, Cogment SDKs rely on the default Prometheus global registry. To change the used registry, it needs to be given to the context when built. Here's how it looks in python. import cog_settings import cogment import prometheus_client # [...] registry = prometheus_client.CollectorRegistry() context = cogment.Context(cog_settings=cog_settings, user_id=\"my_user_id\", prometheus_registry=registry) It is also possible to completely deactivate the gathering of the Prometheus metrics by setting prometheus_registry to None . context = cogment.Context(cog_settings=cog_settings, user_id=\"my_user_id\", prometheus_registry=None)","title":"Metrics & Dashboard"},{"location":"cogment-components/dashboard/metrics-and-dashboard/#metrics-and-dashboard","text":"Cogment provides two services out-of-the-box dedicated to the monitoring of a Cogment deployment: cogment-metrics and cogment-dashboard . cogment-metrics is gathering data coming from all the Cogment services: orchestrator, actors, environment, etc. These metrics can be used to gather insights regarding the performance of actor or environment implementations. They can also be used to follow the attribution of rewards, giving insight into how, or even if agents are learning. cogment-metrics is a Prometheus instance, so it can be easily augmented to visualize your own data. cogment-dashboard is used to explore the metrics data in a human-friendly way, using graphs. Some default dashboards are available, but users can create their own dashboards, as well as use their own Prometheus requests to create their own graphs. cogment-dashboard is based on Grafana .","title":"Metrics and Dashboard"},{"location":"cogment-components/dashboard/metrics-and-dashboard/#usage","text":"Note After initializing your project using cogment init , you should already have everything setup for a standard usage. For a fully manual setup refer to the dedicated section . In an up-and-running Cogment deployment running on your local machine, the dashboard is accessible at http://localhost:3003/ The dashboard welcomes you with a screen giving you direct access to the default sub-dashboards. For example, the agent performances sub-dashboard gives you an idea of how long it takes for actors to handle a new set of observations as well as the number of created instances for each actor implementation. Here's an example taken after a few minutes running tutorial #7 . A similar sub-dashboard is available for environment performances. Another useful sub-dashboard pertains to the rewards. This enables you to follow the progress of the different actor implementations during training. Here's another example taken after a few minutes running tutorial #7 , the DQN agent is about to surpass the heuristic baseline. For specific use case based guides, check out the recipes section .","title":"Usage"},{"location":"cogment-components/dashboard/metrics-and-dashboard/#setup","text":"To setup dashboard and metrics on a docker-based Cogment deployment only two files need to be modified and a third file needs to be created: docker-compose.yaml cogment.yaml Add a metrics/prometheus.yml","title":"Setup"},{"location":"cogment-components/dashboard/metrics-and-dashboard/#setup-services-in-docker-composeyaml","text":"","title":"Setup services in docker-compose.yaml"},{"location":"cogment-components/dashboard/metrics-and-dashboard/#metrics","text":"Create a service named metrics using the cogment/metrics docker image. Log level is decreased to avoid too much verbosity, the yml file is provided in a mounted volume and another one is provided for Prometheus to store its data. metrics: user: 0:0 image: cogment/metrics:latest command: --config.file=/etc/prometheus/prometheus.yml --log.level=error volumes: - ./metrics/prometheus.yml:/etc/prometheus/prometheus.yml:ro - ./metrics/data:/prometheus Warning It is recommended to use a fixed version of cogment/metrics , refer to https://github.com/cogment/cogment-dashboard to get its version number.","title":"Metrics"},{"location":"cogment-components/dashboard/metrics-and-dashboard/#dashboard","text":"Create a service named dashboard and pick an exposed port to consult. dashboard: image: cogment/dashboard:latest ports: - 3003:3000/tcp depends_on: - metrics Warning It is recommended to use a fixed version of cogment/dashboard , refer to https://github.com/cogment/cogment-dashboard to get its version number.","title":"Dashboard"},{"location":"cogment-components/dashboard/metrics-and-dashboard/#launch-containers-in-cogmentyaml","text":"It is recommended to start and stop dashboard and metrics alongside the other services of the Cogment deployment. The easiest way to do that is to add dashboard metrics to the start and stop commands in your cogment.yaml file. start: docker-compose up dashboard metrics orchestrator environment [...] stop: docker-compose stop dashboard metrics orchestrator environment [...]","title":"Launch containers in cogment.yaml"},{"location":"cogment-components/dashboard/metrics-and-dashboard/#configure-prometheus-in-metricsprometheusyml","text":"Prometheus will collect data from various services, from the environment and the actors. All those data will be stored in ./metrics/data . More information about how Prometheus can store data is available here . Inside metrics/prometheus.yml , each service that will be monitored should be added like below. In the following example the environment service is the only one that will be collecting data. global: scrape_interval: 5s # Set the scrape interval to every 5 seconds. Default is every 1 minute. evaluation_interval: 5s # Evaluate rules every 5 seconds. The default is every 1 minute. # A scrape configuration containing exactly one endpoint to scrape: scrape_configs: # The job name is added as a label `job=<job_name>` to any timeseries scraped from this config. - job_name: \"environment\" dns_sd_configs: - names: - \"environment\" # Hostname of the environment service (from ./docker-compose.yaml) type: \"A\" port: 8000 refresh_interval: 5s","title":"Configure Prometheus in metrics/prometheus.yml"},{"location":"cogment-components/dashboard/metrics-and-dashboard/#recipes","text":"","title":"Recipes"},{"location":"cogment-components/dashboard/metrics-and-dashboard/#retrieving-services-from-a-new-service","text":"To add other services from which to collect data, simply add other scrape_configs . scrape_configs: # Here you should have existing configuration for other services. # Here add a new service that will be monitored - job_name: \"new_service\" dns_sd_configs: - names: - \"new_service\" # Hostname of the service as defined in ./docker-compose.yaml type: \"A\" port: 8000 # Port on which the prometheus agent is running, Cogment SDKs uses 8000 by default refresh_interval: 5s More information can be found in the Prometheus documentation","title":"Retrieving services from a new service"},{"location":"cogment-components/dashboard/metrics-and-dashboard/#monitoring-personalized-metrics","text":"You can add your own metrics in your code by using the Prometheus API. Added metrics will be automagically discovered by the Prometheus agent that is started by the Cogment SDKs. Here's how it looks in python. from prometheus_client import Summary, Counter MY_SUMMARY = Summary('my_func', 'Time spent') MY_COUNTER = Counter('metrics_to_count', 'The stuff I want to count') #[...] @MY_SUMMARY.time() # Will automatically measure the time spent def my_func() MY_COUNTER.inc() Several types of metrics are available in Prometheus. Consult the prometheus documentation for futher reference.","title":"Monitoring personalized metrics"},{"location":"cogment-components/dashboard/metrics-and-dashboard/#using-a-custom-registry","text":"By default, Cogment SDKs rely on the default Prometheus global registry. To change the used registry, it needs to be given to the context when built. Here's how it looks in python. import cog_settings import cogment import prometheus_client # [...] registry = prometheus_client.CollectorRegistry() context = cogment.Context(cog_settings=cog_settings, user_id=\"my_user_id\", prometheus_registry=registry) It is also possible to completely deactivate the gathering of the Prometheus metrics by setting prometheus_registry to None . context = cogment.Context(cog_settings=cog_settings, user_id=\"my_user_id\", prometheus_registry=None)","title":"Using a custom registry"},{"location":"cogment-components/model-registry/model-registry/","text":"Model Registry \u00b6 Warning This module is only available as a prerelease. It is not yet fully documented nor stable. Cogment Model Registry is an out-of-the-box component. It is a versioned key value store dedicated to the storage of AI models used in Cogment actors. Usage \u00b6 Warning \ud83d\udea7 under construction Setup \u00b6 Cogment Model Registry is available as a docker container on dockerhub as cogment/model-registry . It can be launched using the following; docker run -p 9000:9000 -v $(pwd)/relative/path/to/model/archive:/data cogment/model-registry If you want to provide specific configuration as environment variables use docker -e option. docker run -p 9000:9000 -e COGMENT_MODEL_REGISTRY_GRPC_REFLECTION=1 -v $(pwd)/relative/path/to/model/archive:/data cogment/model-registry The following environment variables can be used to configure the server: COGMENT_MODEL_REGISTRY_PORT : The port to listen on. Defaults to 9000. COGMENT_MODEL_REGISTRY_ARCHIVE_DIR : The directory to store model archives. Docker images default to /data . COGMENT_MODEL_REGISTRY_SENT_MODEL_VERSION_DATA_CHUNK_SIZE : The size of the model version data chunk sent by the server. Defaults to 5 1024 1024 (5MB). COGMENT_MODEL_REGISTRY_GRPC_REFLECTION : Set to start a gRPC reflection server . Defaults to false . Low level gRPC API \u00b6 The Model Registry implements a gRPC endpoint that is specified as part of the Cogment API: The Model registry API ModelRegistry that defines how to create, retrieve, update and delete models and their version.","title":"Model Registry"},{"location":"cogment-components/model-registry/model-registry/#model-registry","text":"Warning This module is only available as a prerelease. It is not yet fully documented nor stable. Cogment Model Registry is an out-of-the-box component. It is a versioned key value store dedicated to the storage of AI models used in Cogment actors.","title":"Model Registry"},{"location":"cogment-components/model-registry/model-registry/#usage","text":"Warning \ud83d\udea7 under construction","title":"Usage"},{"location":"cogment-components/model-registry/model-registry/#setup","text":"Cogment Model Registry is available as a docker container on dockerhub as cogment/model-registry . It can be launched using the following; docker run -p 9000:9000 -v $(pwd)/relative/path/to/model/archive:/data cogment/model-registry If you want to provide specific configuration as environment variables use docker -e option. docker run -p 9000:9000 -e COGMENT_MODEL_REGISTRY_GRPC_REFLECTION=1 -v $(pwd)/relative/path/to/model/archive:/data cogment/model-registry The following environment variables can be used to configure the server: COGMENT_MODEL_REGISTRY_PORT : The port to listen on. Defaults to 9000. COGMENT_MODEL_REGISTRY_ARCHIVE_DIR : The directory to store model archives. Docker images default to /data . COGMENT_MODEL_REGISTRY_SENT_MODEL_VERSION_DATA_CHUNK_SIZE : The size of the model version data chunk sent by the server. Defaults to 5 1024 1024 (5MB). COGMENT_MODEL_REGISTRY_GRPC_REFLECTION : Set to start a gRPC reflection server . Defaults to false .","title":"Setup"},{"location":"cogment-components/model-registry/model-registry/#low-level-grpc-api","text":"The Model Registry implements a gRPC endpoint that is specified as part of the Cogment API: The Model registry API ModelRegistry that defines how to create, retrieve, update and delete models and their version.","title":"Low level gRPC API"},{"location":"cogment-components/orchestrator/orchestrator/","text":"Orchestrator \u00b6 The Orchestrator is the heart of Cogment. It ties all services together. It is a Linux based single executable configured through command line and some environment variables. Command line \u00b6 The Orchestrator is simply called this way $ orchestrator --lifecycle_port=9001 --actor_port=9001 --params=params.yaml --pre_trial_hooks=grpc://config:9001 All configuration is possible through the command line. The various command line options are described here: help : Outputs the list of command line arguments with a short description. Also shows the recognized environment variables . version : Outputs the version of the Orchestrator to stdout. lifecycle_port : The TCP port where to serve the trial lifecycle gRPC service . This is where the Controller connects to. Default: 9000. actor_port : The TCP port where to serve the client actor gRPC service . This is where Client Actors connect to. Default: 9000 params : The name of the YAML file containing the default parameters for new trials . If defined, these parameters will be sent to the first pre-trial hooks before trial starts. pre_trial_hooks : gRPC endpoint definitions for pre-trial hooks , separated by commas. A gRPC endpoint is a URL that starts with \"grpc://\". Hooks are called before a new trial starts. They are called in order, in a pipeline fashion to set the parameters for new trials. The first hook will receive the default parameters, the last hook result will be used as the parameters for the new trial. prometheus_port : The TCP port where to serve Prometheus metrics. If not defined, Prometheus metrics are not served. status_file : File containing simple status for the Orchestrator. This is useful when running the Orchestrator inside containers or synchronizing with external components. The file is open and stays open while the Orchestrator runs. The file will contain one to three letters: I, R, T. \"I\" indicates that the Orchestrator is initializing. When the Orchestrator starts, the file only contains this letter. \"R\" indicates that the Orchestrator is ready. This letter is added to the file (thus the file will normally contain \"IR\" at this point). \"T\" indicates that the Orchestrator has terminated (crashes will not set this file to \"T\"). Thus after a normal end, the file will contain \"IRT\". private_key : File name containg a PEM encoded private key for encrypted communication. root_cert : File name containing a PEM encoded trusted root certificate. trust_chain : File name containing a PEM encoded trust chain. log_level : Set to define the minimum level for logging. Possible values are: off , error , warning , info , debug , trace . Note however that all trace and most debug level logs will only output if running the debug compiled version of the Orchestrator. Default: info . log_file : Base file name for daily log output. The name will be suffixed with the date and a new file will be made every day. If not provided the logs go to stdout. gc_frequency : Number of (started) trials between trial garbage collection. The Orchestrator periodically deletes ended and stale trials, this parameter controls how often this cleanup happens. The garbage collection may happen on the start of any trial. Environment variables \u00b6 Environment variables correspond to one of the command line parameters. But if both are provided, the command line takes precedence. COGMENT_LIFECYCLE_PORT : This is the same as the lifecycle_port command line parameter. COGMENT_ACTOR_PORT : This is the same as the actor_port command line parameter. COGMENT_ORCHESTRATOR_PROMETHEUS_PORT : This is the same as the prometheus_port command line parameter. COGMENT_PRE_TRIAL_HOOKS : This is the same as the pre_trial_hooks command line parameter. COGMENT_DEFAULT_PARAMS_FILE : This is the same as the params command line parameter.","title":"Orchestrator"},{"location":"cogment-components/orchestrator/orchestrator/#orchestrator","text":"The Orchestrator is the heart of Cogment. It ties all services together. It is a Linux based single executable configured through command line and some environment variables.","title":"Orchestrator"},{"location":"cogment-components/orchestrator/orchestrator/#command-line","text":"The Orchestrator is simply called this way $ orchestrator --lifecycle_port=9001 --actor_port=9001 --params=params.yaml --pre_trial_hooks=grpc://config:9001 All configuration is possible through the command line. The various command line options are described here: help : Outputs the list of command line arguments with a short description. Also shows the recognized environment variables . version : Outputs the version of the Orchestrator to stdout. lifecycle_port : The TCP port where to serve the trial lifecycle gRPC service . This is where the Controller connects to. Default: 9000. actor_port : The TCP port where to serve the client actor gRPC service . This is where Client Actors connect to. Default: 9000 params : The name of the YAML file containing the default parameters for new trials . If defined, these parameters will be sent to the first pre-trial hooks before trial starts. pre_trial_hooks : gRPC endpoint definitions for pre-trial hooks , separated by commas. A gRPC endpoint is a URL that starts with \"grpc://\". Hooks are called before a new trial starts. They are called in order, in a pipeline fashion to set the parameters for new trials. The first hook will receive the default parameters, the last hook result will be used as the parameters for the new trial. prometheus_port : The TCP port where to serve Prometheus metrics. If not defined, Prometheus metrics are not served. status_file : File containing simple status for the Orchestrator. This is useful when running the Orchestrator inside containers or synchronizing with external components. The file is open and stays open while the Orchestrator runs. The file will contain one to three letters: I, R, T. \"I\" indicates that the Orchestrator is initializing. When the Orchestrator starts, the file only contains this letter. \"R\" indicates that the Orchestrator is ready. This letter is added to the file (thus the file will normally contain \"IR\" at this point). \"T\" indicates that the Orchestrator has terminated (crashes will not set this file to \"T\"). Thus after a normal end, the file will contain \"IRT\". private_key : File name containg a PEM encoded private key for encrypted communication. root_cert : File name containing a PEM encoded trusted root certificate. trust_chain : File name containing a PEM encoded trust chain. log_level : Set to define the minimum level for logging. Possible values are: off , error , warning , info , debug , trace . Note however that all trace and most debug level logs will only output if running the debug compiled version of the Orchestrator. Default: info . log_file : Base file name for daily log output. The name will be suffixed with the date and a new file will be made every day. If not provided the logs go to stdout. gc_frequency : Number of (started) trials between trial garbage collection. The Orchestrator periodically deletes ended and stale trials, this parameter controls how often this cleanup happens. The garbage collection may happen on the start of any trial.","title":"Command line"},{"location":"cogment-components/orchestrator/orchestrator/#environment-variables","text":"Environment variables correspond to one of the command line parameters. But if both are provided, the command line takes precedence. COGMENT_LIFECYCLE_PORT : This is the same as the lifecycle_port command line parameter. COGMENT_ACTOR_PORT : This is the same as the actor_port command line parameter. COGMENT_ORCHESTRATOR_PROMETHEUS_PORT : This is the same as the prometheus_port command line parameter. COGMENT_PRE_TRIAL_HOOKS : This is the same as the pre_trial_hooks command line parameter. COGMENT_DEFAULT_PARAMS_FILE : This is the same as the params command line parameter.","title":"Environment variables"},{"location":"cogment-components/trial-datastore/trial-datastore/","text":"Trial Datastore \u00b6 Warning This module is upcoming Cogment Trial Datastore is an upcoming out-of-the-box component implementing the datalog API . It is designed to store the trajectory data generated by the trials for online and offline usage. Usage \u00b6 Warning \ud83d\udea7 under construction Setup \u00b6 Warning \ud83d\udea7 under construction Low level gRPC API \u00b6 The Trial Datastore implements two gRPC endpoints that is specified as part of the Cogment API: The Data/Log API LogExporter The Model Registry API ModelRegistry that defines how to create, retrieve, update and delete models and their version.","title":"Trial Datastore"},{"location":"cogment-components/trial-datastore/trial-datastore/#trial-datastore","text":"Warning This module is upcoming Cogment Trial Datastore is an upcoming out-of-the-box component implementing the datalog API . It is designed to store the trajectory data generated by the trials for online and offline usage.","title":"Trial Datastore"},{"location":"cogment-components/trial-datastore/trial-datastore/#usage","text":"Warning \ud83d\udea7 under construction","title":"Usage"},{"location":"cogment-components/trial-datastore/trial-datastore/#setup","text":"Warning \ud83d\udea7 under construction","title":"Setup"},{"location":"cogment-components/trial-datastore/trial-datastore/#low-level-grpc-api","text":"The Trial Datastore implements two gRPC endpoints that is specified as part of the Cogment API: The Data/Log API LogExporter The Model Registry API ModelRegistry that defines how to create, retrieve, update and delete models and their version.","title":"Low level gRPC API"},{"location":"concepts/core-concepts/","text":"Cogment Core Concepts Guide \u00b6 Welcome to the Cogment core concepts guide. It contains information that is pertinent to both the high-level SDK and the low-level API . Core Concepts \u00b6 Cogment is built around concepts adapted from multi-agent systems (agents, environment), Markov decision processes (action and observation space) and reinforcement learning (trials, rewards). Trials \u00b6 Trials are what a Cogment deployment runs. They enable Actors to interact with their Environment . Trials are started by clients connecting to Cogment. A trial can end either by being terminated from a client or end by itself, for example once a specific state of the Environment is reached. During the trial: The Environment generates observations of its internal state and sends them to the actors . Given these observations , each actor chooses and sends an action . The Environment receives the actions and updates its state. Rewards can be sent to the actors from either the environment or other actors. Actors receive rewards . The actors or the environment can send messages to actors or the environment. A log of the activity during the trial (observations, actions, rewards & messages) is produced and can be stored. A trial is defined by the participating Actors and the host Environment . As a concept, Trials are quite close to Reinforcement Learning's Episodes , i.e. all the states that come between an initial state and a terminal state. However, because Cogment can be used outside of an RL context, we prefer using the more generic term of Trial. Actors \u00b6 Actors within a trial instantiate actor classes defined by the nature of the information they receive from the environment , their observation space , and what actions they can perform, their action space . In Cogment, the observation and action space are defined as typed data structures. In particular, Cogment uses protobuf as a format to specify these data structures. This typing defines both an interface contract between the Actors and the Environment and helps convey semantic information, thus facilitating the independent design and development of both. An Actor might be controlled either by a software Agent , or by a Human. Whichever the case, the process of generating actions based on observations remains the same, and the Environment treats them the same. Some actors connect to the trial (we call them \"client\" actors) and others will wait for the trial to connect to them (we call these \"service\" actors). Environment \u00b6 The Environment is the context within which the Trial takes place. The Environment receives the actions done by the actors, usually updates an internal state, and generates an observation for each Actor . The Environment is the main integration point between Cogment and an external system, either a simulation or a real world system . The specifications file \u00b6 At the heart of every Cogment project is a YAML file typically called cogment.yaml . Its primary role is to define the actor classes present within the project, including their action & observation spaces . Architecture \u00b6 Running trials with Cogment usually involves the deployment of a cluster of services and clients. These components are either provided by the Cogment framework, depicted below in blue, or implemented for a particular project, depicted below in orange. User implemented components use one of the Cogment SDKs or directly implement the underlying protocol . Components communicate using gRPC , clients can also communicate in a web-friendly way using gRPC-Web and grpcwebproxy . Orchestrator \u00b6 The Orchestrator is the glue that binds everything together. It is responsible for running the trials and contacting other services as needed to ensure their execution. The key aspect of Cogment's orchestrator is its capacity to handle a number of network connections in parallel while keeping its responsiveness. Controller \u00b6 The Controller is a key part of using Cogment, it initiates communication with the Orchestrator to control the execution of trials . It is responsible for starting Trials , retrieving and watching their state (including the end of the trial), or requesting trial termination. Environment \u00b6 The Environment implementation is accessed by the Orchestrator to run the Environment during Trials . Using one of Cogment's SDKs , the Environment can be implemented as a function integrating a \"state of the world\" with the Trial . This function performs the following tasks during the Trial: Generate Observations from the current state of the world , for example retrieving the visible objects from a 3D simulation. Apply the Actions , thus updating the state of the world , for example changing the velocity of a moving vehicle in a race simulation. Evaluate the performance of Actors and send them Rewards , for example by checking if a vehicle crossed the finish line in a race simulation. Send and receive direct messages. Actors \u00b6 Actors can be implemented in two different ways, either as a service or as a client. Service Actor implementations are accessed by the Orchestrator during Trials , while Client Actor implementations join a Trial by initiating the communication with the Orchestrator. Client Actors implementations can reach a Cogment deployment through NAT traversal . This makes them particularly well-suited to implement human-driven Actors, in web-browsers for example. Using one of Cogment's SDKs Actors can be implemented as functions handling the integration between a decision-making Actor ( software agent or Human) and the Trial . This function performs the following tasks during the Trial: Receive Observations and do Actions in response, for example vectorizing the retrieved observation, feeding it to a neural network and converting its output to an Action. Receive Rewards , for example using them to update a neural network. Send and receive direct messages. Please note that rewards can also be retrieved after the fact using an activity logger . Additional components \u00b6 On top of the core components described above, a Cogment deployment can include these additional ones: CLI is the command line tool used to bootstrap and build Cogment projects. Datalog services can be used to listen to the activity during a trial (actions, observations, rewards, messages) in order to, for example, store these data for the offline training of AI agents. Trial Datastore is an out-of-the-box implementation of this. Model Registry handles the storage and dispatch of AI models trained with Cogment and used by the actors. Pre-Trial Hooks can be used to dynamically setup Trials from a given configuration, for example changing the number of Actors or pointing to other Environment or Actor implementations. Metrics & Dasboard provides a solution to monitor and visualize various metrics from the services. Components availability summary \u00b6 The following table summarizes how each component can either be implemented or used out of the box. Component Out-of-the-box Python SDK Javascript SDK gRPC API Orchestrator \u2705 cogment-orchestrator \u2705 implement Control API & Client Actor API Controller \u2705 get controller \u2705 get controller \u2705 use Control API Environment \u2705 register environment impl & serve \u2705 implement Environment API Actor (Service) \u2705 register actor impl & serve \u2705 implement Service Actor API Actor (Client) \u2705 register actor impl & join trial \u2705 register actor impl & join trial \u2705 use Client Actor API CLI \u2705 cogment-cli Trial Datastore \u2705 cogment-trial-datastore \u2705 register datalog impl & serve \u2705 implement Datalog API & Trial Datastore API (\ud83d\udea7) Model Registry \u2705 cogment-model-registry \u2705 implement Model Registry API (\ud83d\udea7) Pre Trial Hook \u2705 register pre trial hook impl & serve \u2705 implement Pre Trial Hook API Metrics \u2705 cogment-metrics Dashboard \u2705 cogment-dashboard","title":"Core Concepts"},{"location":"concepts/core-concepts/#cogment-core-concepts-guide","text":"Welcome to the Cogment core concepts guide. It contains information that is pertinent to both the high-level SDK and the low-level API .","title":"Cogment Core Concepts Guide"},{"location":"concepts/core-concepts/#core-concepts","text":"Cogment is built around concepts adapted from multi-agent systems (agents, environment), Markov decision processes (action and observation space) and reinforcement learning (trials, rewards).","title":"Core Concepts"},{"location":"concepts/core-concepts/#trials","text":"Trials are what a Cogment deployment runs. They enable Actors to interact with their Environment . Trials are started by clients connecting to Cogment. A trial can end either by being terminated from a client or end by itself, for example once a specific state of the Environment is reached. During the trial: The Environment generates observations of its internal state and sends them to the actors . Given these observations , each actor chooses and sends an action . The Environment receives the actions and updates its state. Rewards can be sent to the actors from either the environment or other actors. Actors receive rewards . The actors or the environment can send messages to actors or the environment. A log of the activity during the trial (observations, actions, rewards & messages) is produced and can be stored. A trial is defined by the participating Actors and the host Environment . As a concept, Trials are quite close to Reinforcement Learning's Episodes , i.e. all the states that come between an initial state and a terminal state. However, because Cogment can be used outside of an RL context, we prefer using the more generic term of Trial.","title":"Trials"},{"location":"concepts/core-concepts/#actors","text":"Actors within a trial instantiate actor classes defined by the nature of the information they receive from the environment , their observation space , and what actions they can perform, their action space . In Cogment, the observation and action space are defined as typed data structures. In particular, Cogment uses protobuf as a format to specify these data structures. This typing defines both an interface contract between the Actors and the Environment and helps convey semantic information, thus facilitating the independent design and development of both. An Actor might be controlled either by a software Agent , or by a Human. Whichever the case, the process of generating actions based on observations remains the same, and the Environment treats them the same. Some actors connect to the trial (we call them \"client\" actors) and others will wait for the trial to connect to them (we call these \"service\" actors).","title":"Actors"},{"location":"concepts/core-concepts/#environment","text":"The Environment is the context within which the Trial takes place. The Environment receives the actions done by the actors, usually updates an internal state, and generates an observation for each Actor . The Environment is the main integration point between Cogment and an external system, either a simulation or a real world system .","title":"Environment"},{"location":"concepts/core-concepts/#the-specifications-file","text":"At the heart of every Cogment project is a YAML file typically called cogment.yaml . Its primary role is to define the actor classes present within the project, including their action & observation spaces .","title":"The specifications file"},{"location":"concepts/core-concepts/#architecture","text":"Running trials with Cogment usually involves the deployment of a cluster of services and clients. These components are either provided by the Cogment framework, depicted below in blue, or implemented for a particular project, depicted below in orange. User implemented components use one of the Cogment SDKs or directly implement the underlying protocol . Components communicate using gRPC , clients can also communicate in a web-friendly way using gRPC-Web and grpcwebproxy .","title":"Architecture"},{"location":"concepts/core-concepts/#orchestrator","text":"The Orchestrator is the glue that binds everything together. It is responsible for running the trials and contacting other services as needed to ensure their execution. The key aspect of Cogment's orchestrator is its capacity to handle a number of network connections in parallel while keeping its responsiveness.","title":"Orchestrator"},{"location":"concepts/core-concepts/#controller","text":"The Controller is a key part of using Cogment, it initiates communication with the Orchestrator to control the execution of trials . It is responsible for starting Trials , retrieving and watching their state (including the end of the trial), or requesting trial termination.","title":"Controller"},{"location":"concepts/core-concepts/#environment_1","text":"The Environment implementation is accessed by the Orchestrator to run the Environment during Trials . Using one of Cogment's SDKs , the Environment can be implemented as a function integrating a \"state of the world\" with the Trial . This function performs the following tasks during the Trial: Generate Observations from the current state of the world , for example retrieving the visible objects from a 3D simulation. Apply the Actions , thus updating the state of the world , for example changing the velocity of a moving vehicle in a race simulation. Evaluate the performance of Actors and send them Rewards , for example by checking if a vehicle crossed the finish line in a race simulation. Send and receive direct messages.","title":"Environment"},{"location":"concepts/core-concepts/#actors_1","text":"Actors can be implemented in two different ways, either as a service or as a client. Service Actor implementations are accessed by the Orchestrator during Trials , while Client Actor implementations join a Trial by initiating the communication with the Orchestrator. Client Actors implementations can reach a Cogment deployment through NAT traversal . This makes them particularly well-suited to implement human-driven Actors, in web-browsers for example. Using one of Cogment's SDKs Actors can be implemented as functions handling the integration between a decision-making Actor ( software agent or Human) and the Trial . This function performs the following tasks during the Trial: Receive Observations and do Actions in response, for example vectorizing the retrieved observation, feeding it to a neural network and converting its output to an Action. Receive Rewards , for example using them to update a neural network. Send and receive direct messages. Please note that rewards can also be retrieved after the fact using an activity logger .","title":"Actors"},{"location":"concepts/core-concepts/#additional-components","text":"On top of the core components described above, a Cogment deployment can include these additional ones: CLI is the command line tool used to bootstrap and build Cogment projects. Datalog services can be used to listen to the activity during a trial (actions, observations, rewards, messages) in order to, for example, store these data for the offline training of AI agents. Trial Datastore is an out-of-the-box implementation of this. Model Registry handles the storage and dispatch of AI models trained with Cogment and used by the actors. Pre-Trial Hooks can be used to dynamically setup Trials from a given configuration, for example changing the number of Actors or pointing to other Environment or Actor implementations. Metrics & Dasboard provides a solution to monitor and visualize various metrics from the services.","title":"Additional components"},{"location":"concepts/core-concepts/#components-availability-summary","text":"The following table summarizes how each component can either be implemented or used out of the box. Component Out-of-the-box Python SDK Javascript SDK gRPC API Orchestrator \u2705 cogment-orchestrator \u2705 implement Control API & Client Actor API Controller \u2705 get controller \u2705 get controller \u2705 use Control API Environment \u2705 register environment impl & serve \u2705 implement Environment API Actor (Service) \u2705 register actor impl & serve \u2705 implement Service Actor API Actor (Client) \u2705 register actor impl & join trial \u2705 register actor impl & join trial \u2705 use Client Actor API CLI \u2705 cogment-cli Trial Datastore \u2705 cogment-trial-datastore \u2705 register datalog impl & serve \u2705 implement Datalog API & Trial Datastore API (\ud83d\udea7) Model Registry \u2705 cogment-model-registry \u2705 implement Model Registry API (\ud83d\udea7) Pre Trial Hook \u2705 register pre trial hook impl & serve \u2705 implement Pre Trial Hook API Metrics \u2705 cogment-metrics Dashboard \u2705 cogment-dashboard","title":"Components availability summary"},{"location":"concepts/glossary/","text":"Glossary \u00b6 Terminology is a very important part of understanding new concepts and learning how to use new technology. The words we use throughout our documentation may cause problems if one is not familiar with how we use those words; this is a glossary of terms for newcomers and seasoned developers alike. Some familiar terms may have additional caveats specifically added to their definition in the context of the Cogment Framework (generally for clarity). A \u2014B\u2014C\u2014D\u2014 E \u2014 F \u2014G\u2014 H \u2014I\u2014J\u2014K\u2014L\u2014 M \u2014N\u2014 O \u2014 P \u2014Q\u2014 R \u2014S\u2014 T \u2014 U \u2014V\u2014W\u2014X\u2014Y A \u00b6 Actor \u00b6 An actor is somebody or something who/which interacts with the environment by executing certain actions, taking observations in, and receiving rewards (positive or negative) for this interaction. An Actor can be an Agent (of any level of complexity and any type of flexibility, from bots to ML agents), or a human user. Actor Class \u00b6 Each Actor always belongs to a single Actor Class. An Actor Class is primarily defined by its associated Action Space , as a property of an environment . For example, pilot and passenger could be two different Actor Classes. Action \u00b6 An Action is an interaction an Actor performs on the environment. Actions are picked from the Action Space , A single element of an Action Space. Agent \u00b6 We usually call agent any non-human Actor . Agents can use any sort of decision-making underlying system, able to learn or not. C \u00b6 Configurations \u00b6 The configurations (or \"configs\") are defined, set and referenced by users for user components and do not affect the rest of Cogment. They refer to the protobuf messages defined in the trial specifications in the config sections. A \"trial config\" may be given at the start of a new trial. Ultimately, the configurations and parameters for a trial are managed by the pre-trial hooks. E \u00b6 Environment \u00b6 The environment is the set of rules defining how a trial evolves over time for any given use case. For example, to train a pilot agent , a flight simulation would be the environment. Actors can interact with the environment itself, or with each other through the environment, within the boundaries of the environment ruleset (i.e. how an environment can change, from environmental rulesets or the actions of Actors in the environment). A stateful instance of an environment. Environment State \u00b6 An environment state is the specific set of conditions in which the environment is at a specific time (for example, when it is first instantiated). These conditions can be observable or not, and our Framework does not concern itself with the ones that are not. F \u00b6 Framework \u00b6 These two elements combined are what we call the framework: Orchestrator SDKs Frontend \u00b6 The interface, usually an app, that humans use to interact with the rest of the system; the software that turns humans into Actors . H \u00b6 Human - Artificial Intelligence Interaction Loop Training \u00b6 We call Human - AI interaction loop training the fundamental paradigm our Framework was build for: a continuous loop between humans and agents where they learn from each other. It\u2019s a way to train agents in an environment where direct human interactions, whether between humans, between humans and the environment, or between humans and agents, provide live data to the agents (first part of the loop), as well as a way for agents to interact with humans, either directly or through the environment (second part of the loop). M \u00b6 Message \u00b6 Messages can be sent from any actor or the environment to any actor or the environment . The message can be any protobuf class. This creates channels between any set of actors and the environment . These channels can be used for applications where communication between actors and the environment need to be outside of the standard observation and action spaces. Model \u00b6 A model is a representation, usually a mathematical one in our context, of a concept, structure, system, or an aspect of the real world. It is usually a simplified and abstracted representation. O \u00b6 Observation \u00b6 An observation is the subset of the environment state that an Actor based its choice of Action (or lack thereof) on. Observation transition \u00b6 An observation transition is an observation delta between two consecutive observations . Observation space \u00b6 An Observation space is the set of all possible observations an Actor can make of an environment . Orchestrator \u00b6 The Orchestrator is the central piece of our framework ; it\u2019s an executable that handles several things: It circulates data flows between Actors and Environments . It dumps datasets in the chosen storage location. It compresses & encrypts data. It collates various reward sources (usually environment or actors ) into a single reward for an Actor. It instantiates the trials . P \u00b6 Parameters \u00b6 The parameters (or \"params\") define everything that is specific to a trial, and control aspects of Cogment for that trial. Default parameters can be given at the start of the Orchestrator. Ultimately, the configurations and parameters for a trial are managed by the pre-trial hooks. Plugin/extension \u00b6 A plugin or extension adds functionality to our core framework . We provide plugins that handle special features such as Deployment, Dataset storage destinations, Analytics, that one may or may not choose to use alongside the core framework, depending on their specific needs. Protocol Buffer \u00b6 A binary data format for serialized communication, .proto files are used to specify the available data structures. You can learn more at https://developers.google.com/protocol-buffers/ . R \u00b6 Reward \u00b6 A sent reward is a measure of an Actor\u2019s performance within the environment at a given tick . The reward can be sent by the environment, and/or a different Actor. They are sent to the Orchestrator , which collates them before they are received by the target actor. A received reward is a single measure of an Actor\u2019s performance. It is produced when at least one reward is sent to the actor at a given tick . Reward function \u00b6 A reward function describes how an agent \"ought\" to behave; what behaviours lead to Rewards . Note that in our case, Reward functions can be used to reward any Actor , regardless of it being human or not. Reinforcement Learning (RL) \u00b6 RL is a specific method to train agents , using reward functions . S \u00b6 Specifications \u00b6 The specifications (or \u201cspecs\u201d) are the operational aspects of a type of trial (typically found in a file named \"cogment.yaml\"). The file is fed to the Cogment CLI to generate helpful SDK modules (e.g. \"cog_settings.py\" and various \"xxx_pb2.py\" for the Python SDK). These modules are required by the Cogment SDKs. The Orchestrator is independent of the specifications, but some of the trial parameters may be dependent on these specifications (e.g. class name of actors). T \u00b6 Tick \u00b6 A tick is a discrete timestep between two states of the environment . In our Framework , ticks within a trial are numbered. Trial \u00b6 A trial is a single run of a use case , with a beginning and end, populated with a single instance of the use case\u2019s environment and its actors . U \u00b6 Use case \u00b6 The problem one wants to solve.","title":"Glossary"},{"location":"concepts/glossary/#glossary","text":"Terminology is a very important part of understanding new concepts and learning how to use new technology. The words we use throughout our documentation may cause problems if one is not familiar with how we use those words; this is a glossary of terms for newcomers and seasoned developers alike. Some familiar terms may have additional caveats specifically added to their definition in the context of the Cogment Framework (generally for clarity). A \u2014B\u2014C\u2014D\u2014 E \u2014 F \u2014G\u2014 H \u2014I\u2014J\u2014K\u2014L\u2014 M \u2014N\u2014 O \u2014 P \u2014Q\u2014 R \u2014S\u2014 T \u2014 U \u2014V\u2014W\u2014X\u2014Y","title":"Glossary"},{"location":"concepts/glossary/#a","text":"","title":"A"},{"location":"concepts/glossary/#actor","text":"An actor is somebody or something who/which interacts with the environment by executing certain actions, taking observations in, and receiving rewards (positive or negative) for this interaction. An Actor can be an Agent (of any level of complexity and any type of flexibility, from bots to ML agents), or a human user.","title":"Actor"},{"location":"concepts/glossary/#actor-class","text":"Each Actor always belongs to a single Actor Class. An Actor Class is primarily defined by its associated Action Space , as a property of an environment . For example, pilot and passenger could be two different Actor Classes.","title":"Actor Class"},{"location":"concepts/glossary/#action","text":"An Action is an interaction an Actor performs on the environment. Actions are picked from the Action Space , A single element of an Action Space.","title":"Action"},{"location":"concepts/glossary/#agent","text":"We usually call agent any non-human Actor . Agents can use any sort of decision-making underlying system, able to learn or not.","title":"Agent"},{"location":"concepts/glossary/#c","text":"","title":"C"},{"location":"concepts/glossary/#configurations","text":"The configurations (or \"configs\") are defined, set and referenced by users for user components and do not affect the rest of Cogment. They refer to the protobuf messages defined in the trial specifications in the config sections. A \"trial config\" may be given at the start of a new trial. Ultimately, the configurations and parameters for a trial are managed by the pre-trial hooks.","title":"Configurations"},{"location":"concepts/glossary/#e","text":"","title":"E"},{"location":"concepts/glossary/#environment","text":"The environment is the set of rules defining how a trial evolves over time for any given use case. For example, to train a pilot agent , a flight simulation would be the environment. Actors can interact with the environment itself, or with each other through the environment, within the boundaries of the environment ruleset (i.e. how an environment can change, from environmental rulesets or the actions of Actors in the environment). A stateful instance of an environment.","title":"Environment"},{"location":"concepts/glossary/#environment-state","text":"An environment state is the specific set of conditions in which the environment is at a specific time (for example, when it is first instantiated). These conditions can be observable or not, and our Framework does not concern itself with the ones that are not.","title":"Environment State"},{"location":"concepts/glossary/#f","text":"","title":"F"},{"location":"concepts/glossary/#framework","text":"These two elements combined are what we call the framework: Orchestrator SDKs","title":"Framework"},{"location":"concepts/glossary/#frontend","text":"The interface, usually an app, that humans use to interact with the rest of the system; the software that turns humans into Actors .","title":"Frontend"},{"location":"concepts/glossary/#h","text":"","title":"H"},{"location":"concepts/glossary/#human-artificial-intelligence-interaction-loop-training","text":"We call Human - AI interaction loop training the fundamental paradigm our Framework was build for: a continuous loop between humans and agents where they learn from each other. It\u2019s a way to train agents in an environment where direct human interactions, whether between humans, between humans and the environment, or between humans and agents, provide live data to the agents (first part of the loop), as well as a way for agents to interact with humans, either directly or through the environment (second part of the loop).","title":"Human - Artificial Intelligence Interaction Loop Training"},{"location":"concepts/glossary/#m","text":"","title":"M"},{"location":"concepts/glossary/#message","text":"Messages can be sent from any actor or the environment to any actor or the environment . The message can be any protobuf class. This creates channels between any set of actors and the environment . These channels can be used for applications where communication between actors and the environment need to be outside of the standard observation and action spaces.","title":"Message"},{"location":"concepts/glossary/#model","text":"A model is a representation, usually a mathematical one in our context, of a concept, structure, system, or an aspect of the real world. It is usually a simplified and abstracted representation.","title":"Model"},{"location":"concepts/glossary/#o","text":"","title":"O"},{"location":"concepts/glossary/#observation","text":"An observation is the subset of the environment state that an Actor based its choice of Action (or lack thereof) on.","title":"Observation"},{"location":"concepts/glossary/#observation-transition","text":"An observation transition is an observation delta between two consecutive observations .","title":"Observation transition"},{"location":"concepts/glossary/#observation-space","text":"An Observation space is the set of all possible observations an Actor can make of an environment .","title":"Observation space"},{"location":"concepts/glossary/#orchestrator","text":"The Orchestrator is the central piece of our framework ; it\u2019s an executable that handles several things: It circulates data flows between Actors and Environments . It dumps datasets in the chosen storage location. It compresses & encrypts data. It collates various reward sources (usually environment or actors ) into a single reward for an Actor. It instantiates the trials .","title":"Orchestrator"},{"location":"concepts/glossary/#p","text":"","title":"P"},{"location":"concepts/glossary/#parameters","text":"The parameters (or \"params\") define everything that is specific to a trial, and control aspects of Cogment for that trial. Default parameters can be given at the start of the Orchestrator. Ultimately, the configurations and parameters for a trial are managed by the pre-trial hooks.","title":"Parameters"},{"location":"concepts/glossary/#pluginextension","text":"A plugin or extension adds functionality to our core framework . We provide plugins that handle special features such as Deployment, Dataset storage destinations, Analytics, that one may or may not choose to use alongside the core framework, depending on their specific needs.","title":"Plugin/extension"},{"location":"concepts/glossary/#protocol-buffer","text":"A binary data format for serialized communication, .proto files are used to specify the available data structures. You can learn more at https://developers.google.com/protocol-buffers/ .","title":"Protocol Buffer"},{"location":"concepts/glossary/#r","text":"","title":"R"},{"location":"concepts/glossary/#reward","text":"A sent reward is a measure of an Actor\u2019s performance within the environment at a given tick . The reward can be sent by the environment, and/or a different Actor. They are sent to the Orchestrator , which collates them before they are received by the target actor. A received reward is a single measure of an Actor\u2019s performance. It is produced when at least one reward is sent to the actor at a given tick .","title":"Reward"},{"location":"concepts/glossary/#reward-function","text":"A reward function describes how an agent \"ought\" to behave; what behaviours lead to Rewards . Note that in our case, Reward functions can be used to reward any Actor , regardless of it being human or not.","title":"Reward function"},{"location":"concepts/glossary/#reinforcement-learning-rl","text":"RL is a specific method to train agents , using reward functions .","title":"Reinforcement Learning (RL)"},{"location":"concepts/glossary/#s","text":"","title":"S"},{"location":"concepts/glossary/#specifications","text":"The specifications (or \u201cspecs\u201d) are the operational aspects of a type of trial (typically found in a file named \"cogment.yaml\"). The file is fed to the Cogment CLI to generate helpful SDK modules (e.g. \"cog_settings.py\" and various \"xxx_pb2.py\" for the Python SDK). These modules are required by the Cogment SDKs. The Orchestrator is independent of the specifications, but some of the trial parameters may be dependent on these specifications (e.g. class name of actors).","title":"Specifications"},{"location":"concepts/glossary/#t","text":"","title":"T"},{"location":"concepts/glossary/#tick","text":"A tick is a discrete timestep between two states of the environment . In our Framework , ticks within a trial are numbered.","title":"Tick"},{"location":"concepts/glossary/#trial","text":"A trial is a single run of a use case , with a beginning and end, populated with a single instance of the use case\u2019s environment and its actors .","title":"Trial"},{"location":"concepts/glossary/#u","text":"","title":"U"},{"location":"concepts/glossary/#use-case","text":"The problem one wants to solve.","title":"Use case"},{"location":"introduction/installation/","text":"How to Download and Install Cogment \u00b6 Pre-Requisites \u00b6 Please install: Docker and docker-compose protoc Install the latest Cogment CLI \u00b6 Installation script (compatible with linux and macOS for x86_64 architectures) \u00b6 To install the latest version of the Cogment CLI for virtually any Linux distribution, macOS and WSL2 on windows, run the the following command: curl --silent -L https://raw.githubusercontent.com/cogment/cogment-cli/main/install.sh | sudo bash To install a specific version (here v1.0.0) run the following command: curl --silent -L https://raw.githubusercontent.com/cogment/cogment-cli/main/install.sh | sudo bash -s -- --version v1.0.0 Uninstall is as simple as running: sudo rm $(which cogment) Manual installation (compatible with linux, macOS and windows for x86_64 architectures) \u00b6 For windows user (and also if you prefer to do a manual install) you can go through those instructions. Download the desired version from here from your platform. Copy it as cogment in a location that already belongs to your PATH (e.g. /usr/local/bin ) or that you'll add to your PATH and make sure it is executable (e.g. using chmod +x /usr/local/bin/cogment ). Unsupported platform \u00b6 If your platform is not supported, especially if you are using an arm64 architecture, add an issue listing your platform details and do not hesitate to contact us . Check that Cogment CLI is accessible. \u00b6 With a working installation you can run the following in a terminal: $ cogment version You can then list all the commands by typing: $ cogment help or for help on each individual command: $ cogment help <command> Test your installation \u00b6 In order to test that your installation is fully working, run an existing Cogment app, for example one of the steps of the tutorial. Download or clone the sources for the official Rock-Paper-Scissors ( RPS ) tutorial from https://github.com/cogment/cogment-tutorial-rps . Once it is done, run the following in the directory you retrieved: $ cd 5-human-player $ cogment run copy $ cogment run build $ cogment run start The first cogment command will run a simple copy that copies the cogment.yaml, and every referenced proto file, to each build directory. This is so they are made available to docker's build system in each respective build context The second will build docker images for the services of this Cogment app. If everything runs fine it means the docker and docker-compose installations are functional. Finally, the third command will start the Cogment app. In another terminal you can connect to it and play a few games of RPS against a simple AI agent. $ cogment run client Congratulations, you have a working installation of Cogment! We recommend you head to the Cogment tutorial to learn how to implement this RPS app from scratch.","title":"Installation & Setup"},{"location":"introduction/installation/#how-to-download-and-install-cogment","text":"","title":"How to Download and Install Cogment"},{"location":"introduction/installation/#pre-requisites","text":"Please install: Docker and docker-compose protoc","title":"Pre-Requisites"},{"location":"introduction/installation/#install-the-latest-cogment-cli","text":"","title":"Install the latest Cogment CLI"},{"location":"introduction/installation/#installation-script-compatible-with-linux-and-macos-for-x86_64-architectures","text":"To install the latest version of the Cogment CLI for virtually any Linux distribution, macOS and WSL2 on windows, run the the following command: curl --silent -L https://raw.githubusercontent.com/cogment/cogment-cli/main/install.sh | sudo bash To install a specific version (here v1.0.0) run the following command: curl --silent -L https://raw.githubusercontent.com/cogment/cogment-cli/main/install.sh | sudo bash -s -- --version v1.0.0 Uninstall is as simple as running: sudo rm $(which cogment)","title":"Installation script (compatible with linux and macOS for x86_64 architectures)"},{"location":"introduction/installation/#manual-installation-compatible-with-linux-macos-and-windows-for-x86_64-architectures","text":"For windows user (and also if you prefer to do a manual install) you can go through those instructions. Download the desired version from here from your platform. Copy it as cogment in a location that already belongs to your PATH (e.g. /usr/local/bin ) or that you'll add to your PATH and make sure it is executable (e.g. using chmod +x /usr/local/bin/cogment ).","title":"Manual installation (compatible with linux, macOS and windows for x86_64 architectures)"},{"location":"introduction/installation/#unsupported-platform","text":"If your platform is not supported, especially if you are using an arm64 architecture, add an issue listing your platform details and do not hesitate to contact us .","title":"Unsupported platform"},{"location":"introduction/installation/#check-that-cogment-cli-is-accessible","text":"With a working installation you can run the following in a terminal: $ cogment version You can then list all the commands by typing: $ cogment help or for help on each individual command: $ cogment help <command>","title":"Check that Cogment CLI is accessible."},{"location":"introduction/installation/#test-your-installation","text":"In order to test that your installation is fully working, run an existing Cogment app, for example one of the steps of the tutorial. Download or clone the sources for the official Rock-Paper-Scissors ( RPS ) tutorial from https://github.com/cogment/cogment-tutorial-rps . Once it is done, run the following in the directory you retrieved: $ cd 5-human-player $ cogment run copy $ cogment run build $ cogment run start The first cogment command will run a simple copy that copies the cogment.yaml, and every referenced proto file, to each build directory. This is so they are made available to docker's build system in each respective build context The second will build docker images for the services of this Cogment app. If everything runs fine it means the docker and docker-compose installations are functional. Finally, the third command will start the Cogment app. In another terminal you can connect to it and play a few games of RPS against a simple AI agent. $ cogment run client Congratulations, you have a working installation of Cogment! We recommend you head to the Cogment tutorial to learn how to implement this RPS app from scratch.","title":"Test your installation"},{"location":"support/community-channels/","text":"Community \u00b6 The best way to interact with the Cogment community is to use Discord and join our server. If you're unfamiliar with Discord , it's a community tool allowing people to regroup, chat via text and voice and interact, that can be used either through any web browser, or through its dedicated client applications for computers and mobile devices . Cogment Discord Server \u00b6 To join our Discord server, simply click on the link below. If you have the dedicated client application, it will open it there, if not, it will use your web browser. Find us on Cogment's Discord server. Cogment subreddit \u00b6 Cogment also has an official subreddit you can explore.","title":"Community channels"},{"location":"support/community-channels/#community","text":"The best way to interact with the Cogment community is to use Discord and join our server. If you're unfamiliar with Discord , it's a community tool allowing people to regroup, chat via text and voice and interact, that can be used either through any web browser, or through its dedicated client applications for computers and mobile devices .","title":"Community"},{"location":"support/community-channels/#cogment-discord-server","text":"To join our Discord server, simply click on the link below. If you have the dedicated client application, it will open it there, if not, it will use your web browser. Find us on Cogment's Discord server.","title":"Cogment Discord Server"},{"location":"support/community-channels/#cogment-subreddit","text":"Cogment also has an official subreddit you can explore.","title":"Cogment subreddit"}]}