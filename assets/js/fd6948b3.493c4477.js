"use strict";(self.webpackChunkcogment_doc=self.webpackChunkcogment_doc||[]).push([[427],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return d}});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),s=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=s(e.components);return a.createElement(l.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,p=c(e,["components","mdxType","originalType","parentName"]),u=s(n),d=o,f=u["".concat(l,".").concat(d)]||u[d]||m[d]||r;return n?a.createElement(f,i(i({ref:t},p),{},{components:n})):a.createElement(f,i({ref:t},p))}));function d(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=u;var c={};for(var l in t)hasOwnProperty.call(t,l)&&(c[l]=t[l]);c.originalType=e,c.mdxType="string"==typeof e?e:o,i[1]=c;for(var s=2;s<r;s++)i[s]=n[s];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},8452:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return c},contentTitle:function(){return l},metadata:function(){return s},toc:function(){return p},default:function(){return u}});var a=n(7462),o=n(3366),r=(n(7294),n(3905)),i=["components"],c={},l="Spec File",s={unversionedId:"cogment/cogment-api-reference/cogment-yaml",id:"cogment/cogment-api-reference/cogment-yaml",title:"Spec File",description:"The spec file (typically named cogment.yaml) is central to every Cogment project that use a Cogment SDK. This file is used to define the specifics of a type of trials. It can also contain data (the commands section) used by the Cogment CLI tool. A generator tool specific to each SDK takes this file as its main input to, among other things, configure the SDK.",source:"@site/docs/cogment/cogment-api-reference/cogment-yaml.md",sourceDirName:"cogment/cogment-api-reference",slug:"/cogment/cogment-api-reference/cogment-yaml",permalink:"/docs/cogment/cogment-api-reference/cogment-yaml",tags:[],version:"current",lastUpdatedAt:1645720139,formattedLastUpdatedAt:"2/24/2022",frontMatter:{},sidebar:"docSidebar",previous:{title:"Cogment 2.0",permalink:"/docs/cogment/cogment-api-reference/cogment-v2-changes"},next:{title:"Javascript SDK",permalink:"/docs/cogment/cogment-api-reference/javascript"}},p=[{value:"Import",id:"import",children:[],level:2},{value:"Commands",id:"commands",children:[],level:2},{value:"Trial",id:"trial",children:[],level:2},{value:"Environment",id:"environment",children:[],level:2},{value:"Actor Classes",id:"actor-classes",children:[],level:2}],m={toc:p};function u(e){var t=e.components,n=(0,o.Z)(e,i);return(0,r.kt)("wrapper",(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"spec-file"},"Spec File"),(0,r.kt)("p",null,"The spec file (typically named ",(0,r.kt)("inlineCode",{parentName:"p"},"cogment.yaml"),") is central to every Cogment project that use a Cogment SDK. This file is used to define the specifics of a type of trials. It can also contain data (the ",(0,r.kt)("inlineCode",{parentName:"p"},"commands")," section) used by the Cogment CLI tool. A generator tool specific to each SDK takes this file as its main input to, among other things, configure the SDK."),(0,r.kt)("p",null,"The top level sections in the file are:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#import"},"import"),": Used to import other proto files into the definition of the project"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#commands"},"commands"),": Optional. Defines commands that can be run by the Cogment CLI"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#trial"},"trial"),": Define trial speficic properties"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#environment"},"environment"),": Define environment specific properties"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#actor-classes"},"actor_classes"),": Define actor specific properties (for each actor class)")),(0,r.kt)("p",null,'In this document, "section" refers to YAML mappings.'),(0,r.kt)("h2",{id:"import"},"Import"),(0,r.kt)("p",null,"The import section is used to specify external data structures, and optionally code, that is referenced in other parts of the file. The referenced files must be in the same folder as the spec file. The import sections are:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"proto"),": List of protobuf definition files. Message types defined in these files are used to communicate between the various components")),(0,r.kt)("p",null,"All Cogment projects will need at least one ",(0,r.kt)("inlineCode",{parentName:"p"},"proto")," import to define the data structures exchanged between the various components."),(0,r.kt)("p",null,"E.g.:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"import:\n    proto:\n        - filename1.proto\n        - filename2.proto\n")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"\u26a0\ufe0f ",(0,r.kt)("strong",{parentName:"p"},"N.B.")," When using message types imported from a ",(0,r.kt)("inlineCode",{parentName:"p"},".proto")," file, types need to be referred through their ",(0,r.kt)("em",{parentName:"p"},"package")," namespace, not the filename containing them.")),(0,r.kt)("h2",{id:"commands"},"Commands"),(0,r.kt)("p",null,"This section is optional and defines commands that can then be executed using the Cogment CLI ",(0,r.kt)("inlineCode",{parentName:"p"},"run")," command. The commands will be executed by a sub-shell and thus can be any shell command. The commands can also recursively call Cogment, either built-in CLI commands, or other commands defined here. But care should be taken not to create infinite recursive calls."),(0,r.kt)("p",null,"E.g.:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"commands:\n    generate: |\n        cd client && python -m cogment.generate --spec cogment.yaml && cd ..\n        cd environment && python -m cogment.generate --spec cogment.yaml && cd ..\n    copy: cogment copy cogment.yaml *.proto params.yaml client environment\n    start: docker-compose up orchestrator agent env\n    play: cogment run start && docker-compose run launcher\n")),(0,r.kt)("p",null,"To run one of these commands, the Cogment CLI command ",(0,r.kt)("inlineCode",{parentName:"p"},"run")," must be used, e.g.: ",(0,r.kt)("inlineCode",{parentName:"p"},"cogment run start"),". And as such there is no problem differentiating between ",(0,r.kt)("inlineCode",{parentName:"p"},"cogment run copy")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"cogment copy")," (the latter is the builtin CLI command, and the former is the command defined in the ",(0,r.kt)("inlineCode",{parentName:"p"},"cogment.yaml")," file)."),(0,r.kt)("p",null,"The cogment command section exists so that commands can be executed in a platform independant manner."),(0,r.kt)("h2",{id:"trial"},"Trial"),(0,r.kt)("p",null,"This section defines properties related to the trial and trial management. It has the properties:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"config_type"),": (optional) The protobuf message type (data structure) that will be passed on to the pre-trial hooks.")),(0,r.kt)("p",null,"E.g.:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"trial:\n    config_type: namespace.DataType\n")),(0,r.kt)("h2",{id:"environment"},"Environment"),(0,r.kt)("p",null,"This section defines properties related to the environment. It has the properties:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"config_type"),": (optional) The protobuf message type used to configure the environment")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"environment:\n    config_type: namespace.DataType\n")),(0,r.kt)("h2",{id:"actor-classes"},"Actor Classes"),(0,r.kt)("p",null,"Arguably the most important section of the spec file, the actor classes section describes the actor types that can be present in the project's trials."),(0,r.kt)("p",null,"The content of this section is a list of actor classes, each containing the necessary properties to define an actor class. These properties are:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"name"),": The name by which this actor class is known"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"action"),": Mapping of properties- ",(0,r.kt)("inlineCode",{parentName:"li"},"space"),": The protobuf message type that represents all the possible actions that this actor class can perform (its action space)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"observation"),": Mapping of properties",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"space"),": The protobuf message type that represents a snapshot of the data that this actor class has access to (its observation space)"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"config_type"),": (optional) Defines the protobuf message type used to configure this actor class")),(0,r.kt)("p",null,"Each actor class should define both an observation and action space as protobuf message types."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"actor_classes:\n    - name: BigPlayer\n      action:\n          space: namespace.PlayerAction\n      observation:\n          space: namespace.PlayerObservation\n      config_type: namespace.PlayerConfig\n\n    - name: SmallPlayer\n      action:\n          space: namespace.PlayerAction\n      observation:\n          space: namespace.PlayerObservation\n      config_type: namespace.PlayerConfig\n\n    - name: Referee\n      action:\n          space: namespace.RefereeAction\n      observation:\n          space: namespace.RefereeObservation\n      config_type: namespace.RefereeConfig\n")))}u.isMDXComponent=!0}}]);